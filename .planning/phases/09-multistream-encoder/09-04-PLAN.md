---
phase: 09-multistream-encoder
plan: 04
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - internal/multistream/libopus_test.go
autonomous: true

must_haves:
  truths:
    - "Multistream packets decode with opusdec (libopus)"
    - "Ogg Opus container correctly formatted for multistream (mapping family 1)"
    - "All standard configurations validated against libopus"
  artifacts:
    - path: "internal/multistream/libopus_test.go"
      provides: "Libopus cross-validation tests"
      min_lines: 200
      exports: ["TestLibopus"]
  key_links:
    - from: "internal/multistream/libopus_test.go"
      to: "internal/multistream/encoder.go"
      via: "Encoder.Encode"
      pattern: "encoder\\.Encode"
---

<objective>
Validate multistream encoder output against libopus using opusdec tool.

Purpose: Ensure encoder produces standard-compliant packets decodable by reference implementation.
Output: Cross-validation tests using Ogg Opus container and opusdec.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/09-multistream-encoder/09-CONTEXT.md
@.planning/phases/09-multistream-encoder/09-RESEARCH.md
@.planning/phases/09-multistream-encoder/09-02-SUMMARY.md
@internal/celt/libopus_test.go
@internal/encoder/libopus_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Ogg Opus multistream container helper</name>
  <files>internal/multistream/libopus_test.go</files>
  <action>
Create `internal/multistream/libopus_test.go` with Ogg Opus container support for multistream:

```go
package multistream

import (
    "bytes"
    "encoding/binary"
    "hash/crc32"
    "math"
    "os"
    "os/exec"
    "path/filepath"
    "testing"
)

// CRC32 polynomial for Ogg pages (same as celt/libopus_test.go)
var oggCrcTable = crc32.MakeTable(0x04c11db7)

func oggCRC(data []byte) uint32 {
    // Ogg CRC is computed with CRC field set to 0
    return crc32.Update(0, oggCrcTable, data)
}

// makeOggPage creates an Ogg page with proper CRC.
func makeOggPage(granulePos uint64, serialNo, pageNo uint32, headerType byte, segments [][]byte) []byte {
    // Calculate segment table
    var segmentTable []byte
    for _, seg := range segments {
        remaining := len(seg)
        for remaining >= 255 {
            segmentTable = append(segmentTable, 255)
            remaining -= 255
        }
        segmentTable = append(segmentTable, byte(remaining))
    }

    // Build header (27 bytes + segment table)
    header := make([]byte, 27+len(segmentTable))
    copy(header[0:4], "OggS")
    header[4] = 0 // Version
    header[5] = headerType
    binary.LittleEndian.PutUint64(header[6:14], granulePos)
    binary.LittleEndian.PutUint32(header[14:18], serialNo)
    binary.LittleEndian.PutUint32(header[18:22], pageNo)
    // CRC at 22:26, set to 0 for calculation
    header[26] = byte(len(segmentTable))
    copy(header[27:], segmentTable)

    // Combine header and payload
    var payload []byte
    for _, seg := range segments {
        payload = append(payload, seg...)
    }
    page := append(header, payload...)

    // Calculate and insert CRC
    crc := oggCRC(page)
    binary.LittleEndian.PutUint32(page[22:26], crc)

    return page
}

// makeOpusHeadMultistream creates OpusHead for multistream (mapping family 1).
// Per RFC 7845 Section 5.1.1
func makeOpusHeadMultistream(channels, sampleRate, streams, coupledStreams int, mapping []byte) []byte {
    // 19 bytes base + 2 bytes (stream count + coupled count) + mapping table
    size := 21 + len(mapping)
    head := make([]byte, size)

    copy(head[0:8], "OpusHead")
    head[8] = 1 // Version
    head[9] = byte(channels)
    binary.LittleEndian.PutUint16(head[10:12], 312) // Pre-skip
    binary.LittleEndian.PutUint32(head[12:16], uint32(sampleRate))
    binary.LittleEndian.PutUint16(head[16:18], 0) // Output gain
    head[18] = 1 // Channel mapping family 1 (Vorbis)
    head[19] = byte(streams)
    head[20] = byte(coupledStreams)
    copy(head[21:], mapping)

    return head
}

// makeOpusTags creates a minimal OpusTags header.
func makeOpusTags() []byte {
    tags := make([]byte, 16)
    copy(tags[0:8], "OpusTags")
    binary.LittleEndian.PutUint32(tags[8:12], 5) // Vendor length
    copy(tags[12:17], "gopus")
    // Comment count = 0 (4 bytes would be needed, but this minimal version works)
    return tags[:16]
}

// writeOggOpusMultistream writes a multistream Ogg Opus file.
func writeOggOpusMultistream(filename string, packets [][]byte, channels, sampleRate, streams, coupledStreams int, mapping []byte) error {
    var buf bytes.Buffer

    serialNo := uint32(0x12345678)
    pageNo := uint32(0)

    // Page 0: OpusHead (BOS)
    opusHead := makeOpusHeadMultistream(channels, sampleRate, streams, coupledStreams, mapping)
    page0 := makeOggPage(0, serialNo, pageNo, 0x02, [][]byte{opusHead}) // BOS flag
    buf.Write(page0)
    pageNo++

    // Page 1: OpusTags
    opusTags := makeOpusTags()
    page1 := makeOggPage(0, serialNo, pageNo, 0x00, [][]byte{opusTags})
    buf.Write(page1)
    pageNo++

    // Audio pages
    const samplesPerFrame = 960 // 20ms at 48kHz
    granulePos := uint64(312)   // Start after pre-skip

    for _, packet := range packets {
        granulePos += uint64(samplesPerFrame)
        page := makeOggPage(granulePos, serialNo, pageNo, 0x00, [][]byte{packet})
        buf.Write(page)
        pageNo++
    }

    // Final page with EOS flag
    finalPage := makeOggPage(granulePos, serialNo, pageNo, 0x04, [][]byte{}) // EOS
    buf.Write(finalPage)

    return os.WriteFile(filename, buf.Bytes(), 0644)
}
```
  </action>
  <verify>
Run `go build ./internal/multistream/` compiles.
  </verify>
  <done>
Ogg Opus multistream container writer implemented with mapping family 1 support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement libopus cross-validation tests</name>
  <files>internal/multistream/libopus_test.go</files>
  <action>
Add cross-validation tests using opusdec:

```go
// checkOpusdec verifies opusdec is available.
func checkOpusdec(t *testing.T) string {
    path, err := exec.LookPath("opusdec")
    if err != nil {
        t.Skip("opusdec not found, skipping libopus cross-validation")
    }
    return path
}

func TestLibopus_Stereo(t *testing.T) {
    testLibopusMultistream(t, 2, "stereo")
}

func TestLibopus_51Surround(t *testing.T) {
    testLibopusMultistream(t, 6, "5.1 surround")
}

func TestLibopus_71Surround(t *testing.T) {
    testLibopusMultistream(t, 8, "7.1 surround")
}

func testLibopusMultistream(t *testing.T, channels int, name string) {
    opusdecPath := checkOpusdec(t)

    const sampleRate = 48000
    const frameSize = 960
    const numFrames = 20

    // Get default mapping
    streams, coupled, mapping, err := DefaultMapping(channels)
    if err != nil {
        t.Fatalf("%s: DefaultMapping failed: %v", name, err)
    }

    // Create encoder
    encoder, err := NewEncoderDefault(sampleRate, channels)
    if err != nil {
        t.Fatalf("%s: NewEncoderDefault failed: %v", name, err)
    }
    encoder.SetBitrate(256000)

    // Generate and encode frames
    var packets [][]byte
    var totalInputEnergy float64

    for frame := 0; frame < numFrames; frame++ {
        input := make([]float64, frameSize*channels)
        for ch := 0; ch < channels; ch++ {
            freq := 220.0 * float64(ch+1)
            for s := 0; s < frameSize; s++ {
                globalSample := frame*frameSize + s
                t := float64(globalSample) / float64(sampleRate)
                input[s*channels+ch] = 0.5 * math.Sin(2*math.Pi*freq*t)
            }
        }
        totalInputEnergy += computeEnergy(input)

        packet, err := encoder.Encode(input, frameSize)
        if err != nil {
            t.Fatalf("%s: Frame %d Encode failed: %v", name, frame, err)
        }
        if packet != nil {
            packets = append(packets, packet)
        }
    }

    // Write Ogg Opus file
    tempDir := t.TempDir()
    opusFile := filepath.Join(tempDir, "test.opus")
    wavFile := filepath.Join(tempDir, "test.wav")

    err = writeOggOpusMultistream(opusFile, packets, channels, sampleRate, streams, coupled, mapping)
    if err != nil {
        t.Fatalf("%s: writeOggOpusMultistream failed: %v", name, err)
    }
    t.Logf("%s: wrote %s (%d packets)", name, opusFile, len(packets))

    // Decode with opusdec
    cmd := exec.Command(opusdecPath, opusFile, wavFile)
    output, err := cmd.CombinedOutput()
    if err != nil {
        // Check for macOS provenance restrictions
        if bytes.Contains(output, []byte("cannot be opened")) ||
            bytes.Contains(output, []byte("killed")) {
            t.Skipf("%s: opusdec blocked by macOS security, skipping", name)
        }
        t.Logf("%s: opusdec output: %s", name, string(output))
        t.Fatalf("%s: opusdec failed: %v", name, err)
    }

    // Verify WAV file was created
    wavInfo, err := os.Stat(wavFile)
    if err != nil {
        t.Fatalf("%s: WAV file not created: %v", name, err)
    }
    t.Logf("%s: decoded WAV size: %d bytes", name, wavInfo.Size())

    // Read and analyze WAV file
    wavData, err := os.ReadFile(wavFile)
    if err != nil {
        t.Fatalf("%s: Failed to read WAV: %v", name, err)
    }

    // Parse WAV header to find data
    if len(wavData) < 44 {
        t.Fatalf("%s: WAV file too short", name)
    }
    if string(wavData[0:4]) != "RIFF" || string(wavData[8:12]) != "WAVE" {
        t.Fatalf("%s: Invalid WAV header", name)
    }

    // Find data chunk
    offset := 12
    var dataSize int
    for offset < len(wavData)-8 {
        chunkID := string(wavData[offset : offset+4])
        chunkSize := int(binary.LittleEndian.Uint32(wavData[offset+4 : offset+8]))
        if chunkID == "data" {
            dataSize = chunkSize
            offset += 8
            break
        }
        offset += 8 + chunkSize
        if chunkSize%2 == 1 {
            offset++ // Padding byte
        }
    }

    if dataSize == 0 {
        t.Fatalf("%s: No data chunk in WAV", name)
    }

    // Calculate output energy (16-bit samples)
    numSamples := dataSize / 2
    var outputEnergy float64
    for i := 0; i < numSamples && offset+2*i+1 < len(wavData); i++ {
        sample := int16(binary.LittleEndian.Uint16(wavData[offset+2*i : offset+2*i+2]))
        normalized := float64(sample) / 32768.0
        outputEnergy += normalized * normalized
    }

    // Report results
    energyRatio := outputEnergy / totalInputEnergy
    t.Logf("%s: libopus decode - input energy: %.4f, output energy: %.4f, ratio: %.2f%%",
        name, totalInputEnergy, outputEnergy, energyRatio*100)

    // Warn but don't fail if energy is low (encoder tuning may be needed)
    if energyRatio < 0.01 {
        t.Logf("%s: WARNING: Low energy ratio (%.2f%%), encoder may need tuning",
            name, energyRatio*100)
    }
}
```
  </action>
  <verify>
Run `go test -v ./internal/multistream/ -run 'TestLibopus'` - tests pass or skip appropriately.
  </verify>
  <done>
Libopus cross-validation tests implemented. Tests skip gracefully on macOS with security restrictions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add informational quality metrics</name>
  <files>internal/multistream/libopus_test.go</files>
  <action>
Add additional quality tests that log informational metrics:

```go
func TestLibopus_BitrateQuality(t *testing.T) {
    opusdecPath := checkOpusdec(t)

    const sampleRate = 48000
    const frameSize = 960
    const numFrames = 50
    const channels = 6 // 5.1

    bitrates := []int{128000, 256000, 384000}

    for _, bitrate := range bitrates {
        t.Run(fmt.Sprintf("%dkbps", bitrate/1000), func(t *testing.T) {
            streams, coupled, mapping, _ := DefaultMapping(channels)
            encoder, _ := NewEncoderDefault(sampleRate, channels)
            encoder.SetBitrate(bitrate)

            var packets [][]byte
            var totalSize int
            var totalInputEnergy float64

            for frame := 0; frame < numFrames; frame++ {
                input := make([]float64, frameSize*channels)
                for ch := 0; ch < channels; ch++ {
                    freq := 220.0 * float64(ch+1)
                    for s := 0; s < frameSize; s++ {
                        globalSample := frame*frameSize + s
                        tSec := float64(globalSample) / float64(sampleRate)
                        input[s*channels+ch] = 0.5 * math.Sin(2*math.Pi*freq*tSec)
                    }
                }
                totalInputEnergy += computeEnergy(input)

                packet, _ := encoder.Encode(input, frameSize)
                if packet != nil {
                    packets = append(packets, packet)
                    totalSize += len(packet)
                }
            }

            // Calculate actual bitrate
            durationSec := float64(numFrames) * float64(frameSize) / float64(sampleRate)
            actualBitrate := float64(totalSize*8) / durationSec

            t.Logf("Target: %d kbps, Actual: %.1f kbps (%.1f%% of target)",
                bitrate/1000, actualBitrate/1000, actualBitrate*100/float64(bitrate))

            // Write and decode with libopus
            tempDir := t.TempDir()
            opusFile := filepath.Join(tempDir, "test.opus")
            wavFile := filepath.Join(tempDir, "test.wav")

            writeOggOpusMultistream(opusFile, packets, channels, sampleRate, streams, coupled, mapping)

            cmd := exec.Command(opusdecPath, opusFile, wavFile)
            output, err := cmd.CombinedOutput()
            if err != nil {
                if bytes.Contains(output, []byte("cannot be opened")) {
                    t.Skip("opusdec blocked by macOS security")
                }
                t.Fatalf("opusdec failed: %v\n%s", err, output)
            }

            t.Logf("libopus successfully decoded %d-channel multistream at %d kbps",
                channels, bitrate/1000)
        })
    }
}
```

Add import for "fmt" at the top of the file.
  </action>
  <verify>
Run `go test -v ./internal/multistream/ -run 'TestLibopus_BitrateQuality'` - tests pass or skip.
  </verify>
  <done>
Bitrate quality tests added, logging actual vs target bitrate and libopus decode success.
  </done>
</task>

</tasks>

<verification>
- [ ] `go test ./internal/multistream/ -run 'TestLibopus'` passes or skips appropriately
- [ ] Ogg Opus files with mapping family 1 are correctly formatted
- [ ] opusdec successfully decodes multistream files when available
- [ ] Tests skip gracefully on systems without opusdec or with security restrictions
</verification>

<success_criteria>
- Ogg Opus multistream container correctly formatted (mapping family 1)
- opusdec decodes encoded multistream packets without errors
- Tests handle missing opusdec or macOS security restrictions gracefully
- Quality metrics logged for encoder tuning guidance
</success_criteria>

<output>
After completion, create `.planning/phases/09-multistream-encoder/09-04-SUMMARY.md`
</output>
