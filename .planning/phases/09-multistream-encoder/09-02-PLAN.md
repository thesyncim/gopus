---
phase: 09-multistream-encoder
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - internal/multistream/encoder.go
  - internal/multistream/encoder_test.go
autonomous: true

must_haves:
  truths:
    - "Self-delimiting length encoding produces correct 1-2 byte format"
    - "Multistream packets have N-1 length-prefixed streams plus one standard stream"
    - "Encoder.Encode produces complete multistream packets"
    - "Bitrate distributes across streams with weighted allocation"
  artifacts:
    - path: "internal/multistream/encoder.go"
      provides: "writeSelfDelimitedLength, assembleMultistreamPacket, Encode, SetBitrate"
      exports: ["Encode", "SetBitrate", "Bitrate"]
  key_links:
    - from: "internal/multistream/encoder.go (Encode)"
      to: "internal/encoder/encoder.go (Encode)"
      via: "per-stream encoding"
      pattern: "e\\.encoders\\[i\\]\\.Encode"
    - from: "internal/multistream/encoder.go (assembleMultistreamPacket)"
      to: "internal/multistream/stream.go (parseSelfDelimitedLength)"
      via: "inverse encoding"
      pattern: "writeSelfDelimitedLength"
---

<objective>
Implement self-delimiting packet assembly and the complete Encode method for multistream encoding.

Purpose: Complete the core encoding pipeline that produces valid multistream packets.
Output: Working Encode() method that produces packets following RFC 6716 multistream format.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/09-multistream-encoder/09-CONTEXT.md
@.planning/phases/09-multistream-encoder/09-RESEARCH.md
@.planning/phases/09-multistream-encoder/09-01-SUMMARY.md
@internal/multistream/stream.go
@internal/encoder/encoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement self-delimiting length encoding</name>
  <files>internal/multistream/encoder.go</files>
  <action>
Add self-delimiting length encoding functions (inverse of parseSelfDelimitedLength):

```go
// writeSelfDelimitedLength writes a self-delimiting length to dst.
// Per RFC 6716 Section 3.2.1:
// - If length < 252: single byte = length
// - If length >= 252: two bytes where length = 4*secondByte + firstByte
//
// Returns number of bytes written (1 or 2).
func writeSelfDelimitedLength(dst []byte, length int) int {
    if length < 252 {
        dst[0] = byte(length)
        return 1
    }
    // length = 4*secondByte + firstByte
    // Choose firstByte in [252, 255] based on length % 4
    dst[0] = byte(252 + (length % 4))
    dst[1] = byte((length - int(dst[0])) / 4)
    return 2
}

// selfDelimitedLengthBytes returns the number of bytes needed to encode a length.
func selfDelimitedLengthBytes(length int) int {
    if length < 252 {
        return 1
    }
    return 2
}
```

Note: The formula must match parseSelfDelimitedLength exactly: `length = 4*secondByte + firstByte`.
  </action>
  <verify>
Write a quick test verifying writeSelfDelimitedLength round-trips with parseSelfDelimitedLength for lengths 0, 1, 251, 252, 253, 500, 1000.
  </verify>
  <done>
writeSelfDelimitedLength correctly encodes lengths. Round-trip verified with parseSelfDelimitedLength.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement packet assembly and Encode method</name>
  <files>internal/multistream/encoder.go</files>
  <action>
Add assembleMultistreamPacket and the main Encode method:

```go
// assembleMultistreamPacket combines stream packets into a multistream packet.
// Per RFC 6716 Appendix B:
// - First N-1 packets get self-delimiting framing (length prefix)
// - Last packet uses standard framing (remaining bytes, no prefix)
func assembleMultistreamPacket(streamPackets [][]byte) []byte {
    if len(streamPackets) == 0 {
        return nil
    }
    if len(streamPackets) == 1 {
        return streamPackets[0] // Single stream = no framing needed
    }

    // Calculate total size
    totalSize := 0
    for i, packet := range streamPackets {
        if i < len(streamPackets)-1 {
            totalSize += selfDelimitedLengthBytes(len(packet))
        }
        totalSize += len(packet)
    }

    output := make([]byte, totalSize)
    offset := 0

    // Write first N-1 packets with length prefix
    for i := 0; i < len(streamPackets)-1; i++ {
        n := writeSelfDelimitedLength(output[offset:], len(streamPackets[i]))
        offset += n
        copy(output[offset:], streamPackets[i])
        offset += len(streamPackets[i])
    }

    // Last packet: no prefix, uses remaining bytes
    copy(output[offset:], streamPackets[len(streamPackets)-1])

    return output
}

// Encode encodes PCM samples to a multistream Opus packet.
//
// Parameters:
//   - pcm: sample-interleaved input [ch0_s0, ch1_s0, ..., chN_s0, ch0_s1, ...]
//   - frameSize: samples per channel at 48kHz (e.g., 960 for 20ms)
//
// Returns the encoded multistream packet ready for transmission.
// Returns nil, nil if all streams return nil (DTX suppression).
func (e *Encoder) Encode(pcm []float64, frameSize int) ([]byte, error) {
    expectedLen := frameSize * e.inputChannels
    if len(pcm) != expectedLen {
        return nil, ErrInvalidInput
    }

    // Route input channels to stream buffers
    streamBuffers := routeChannelsToStreams(
        pcm, e.mapping, e.coupledStreams,
        frameSize, e.inputChannels, e.streams,
    )

    // Encode each stream
    streamPackets := make([][]byte, e.streams)
    allNil := true
    for i := 0; i < e.streams; i++ {
        packet, err := e.encoders[i].Encode(streamBuffers[i], frameSize)
        if err != nil {
            return nil, fmt.Errorf("multistream: stream %d encode error: %w", i, err)
        }
        streamPackets[i] = packet
        if packet != nil {
            allNil = false
        }
    }

    // If all streams returned nil (DTX), return nil
    if allNil {
        return nil, nil
    }

    // Replace nil packets with minimal valid packet (DTX partial)
    for i := range streamPackets {
        if streamPackets[i] == nil {
            // Generate minimal packet: single-byte TOC with no payload
            // Use same config as this encoder would use
            streamPackets[i] = []byte{0xFC} // CELT NB 20ms mono, code 0
        }
    }

    // Assemble multistream packet
    return assembleMultistreamPacket(streamPackets), nil
}
```

Add ErrInvalidInput error:
```go
var ErrInvalidInput = errors.New("multistream: invalid input length")
```
  </action>
  <verify>
Run `go build ./internal/multistream/` - must compile.
Run `go vet ./internal/multistream/` - no issues.
  </verify>
  <done>
Encode method complete. Routes channels, encodes streams, assembles with self-delimiting framing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement bitrate distribution and control methods</name>
  <files>internal/multistream/encoder.go</files>
  <action>
Add bitrate distribution and encoder control methods:

```go
// SetBitrate sets the total bitrate and distributes across streams.
// Uses weighted allocation: coupled streams get 3 units, mono streams get 2 units.
// This approximates libopus default of 96 kbps per coupled, 64 kbps per mono.
func (e *Encoder) SetBitrate(totalBitrate int) {
    e.bitrate = totalBitrate

    // Calculate weighted units
    // 3 units for coupled (stereo), 2 units for uncoupled (mono)
    monoStreams := e.streams - e.coupledStreams
    totalUnits := e.coupledStreams*3 + monoStreams*2

    if totalUnits == 0 {
        return // No streams to configure
    }

    bitratePerUnit := totalBitrate / totalUnits

    // Apply to each encoder
    for i := 0; i < e.streams; i++ {
        if i < e.coupledStreams {
            e.encoders[i].SetBitrate(bitratePerUnit * 3)
        } else {
            e.encoders[i].SetBitrate(bitratePerUnit * 2)
        }
    }
}

// Bitrate returns the current total bitrate setting.
func (e *Encoder) Bitrate() int {
    return e.bitrate
}

// SetComplexity sets the complexity for all stream encoders.
func (e *Encoder) SetComplexity(complexity int) {
    for _, enc := range e.encoders {
        enc.SetComplexity(complexity)
    }
}

// SetFEC enables or disables FEC for all stream encoders.
func (e *Encoder) SetFEC(enabled bool) {
    for _, enc := range e.encoders {
        enc.SetFEC(enabled)
    }
}

// SetPacketLoss sets expected packet loss for all stream encoders.
func (e *Encoder) SetPacketLoss(lossPercent int) {
    for _, enc := range e.encoders {
        enc.SetPacketLoss(lossPercent)
    }
}

// SetDTX enables or disables DTX for all stream encoders.
func (e *Encoder) SetDTX(enabled bool) {
    for _, enc := range e.encoders {
        enc.SetDTX(enabled)
    }
}

// Reset resets all stream encoders for a new stream.
func (e *Encoder) Reset() {
    for _, enc := range e.encoders {
        enc.Reset()
    }
}

// Accessor methods
func (e *Encoder) SampleRate() int     { return e.sampleRate }
func (e *Encoder) Channels() int       { return e.inputChannels }
func (e *Encoder) Streams() int        { return e.streams }
func (e *Encoder) CoupledStreams() int { return e.coupledStreams }
```

Default bitrate in NewEncoder: set e.bitrate = 256000 (256 kbps, good for 5.1) and call SetBitrate(256000) at end of NewEncoder.
  </action>
  <verify>
Run `go build ./internal/multistream/` compiles.
  </verify>
  <done>
Bitrate distribution implemented with weighted allocation. All control methods propagate to stream encoders.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add encoding and assembly unit tests</name>
  <files>internal/multistream/encoder_test.go</files>
  <action>
Add tests for encoding functionality:

1. **TestWriteSelfDelimitedLength**:
- Test lengths: 0, 1, 100, 251, 252, 253, 255, 500, 1000
- For each: write, then parse with parseSelfDelimitedLength, verify match

2. **TestAssembleMultistreamPacket**:
- Single packet: no framing added
- Two packets: first has length prefix, second doesn't
- Four packets: first 3 have length prefixes, last doesn't
- Verify total length = sum of packets + length prefix bytes

3. **TestEncode_Basic**:
- Create stereo encoder (2 channels)
- Generate 20ms of simple sine wave (960 samples per channel)
- Encode, verify non-nil packet returned
- Verify packet length > 0

4. **TestEncode_51Surround**:
- Create 5.1 encoder (6 channels)
- Generate 20ms test signal
- Encode, verify packet returned
- Parse packet with parseMultistreamPacket, verify 4 stream packets

5. **TestEncode_71Surround**:
- Create 7.1 encoder (8 channels)
- Generate 20ms test signal
- Encode, verify packet has 5 streams

6. **TestSetBitrate_Distribution**:
- Create 5.1 encoder
- SetBitrate(256000)
- Verify coupled streams get ~96k (3/10 * 256k = 76.8k rounded)
- Verify mono streams get ~64k (2/10 * 256k = 51.2k rounded)
- (Use approximate checks due to integer division)

7. **TestEncode_InputValidation**:
- Wrong length input -> ErrInvalidInput
  </action>
  <verify>
Run `go test -v ./internal/multistream/ -run 'TestWrite|TestAssemble|TestEncode|TestSetBitrate'` - all pass.
  </verify>
  <done>
All encoding tests pass. Self-delimiting round-trips correctly. Multistream packets assemble with proper framing.
  </done>
</task>

</tasks>

<verification>
- [ ] `go build ./internal/multistream/` compiles
- [ ] `go test ./internal/multistream/ -run 'TestWrite|TestAssemble|TestEncode'` passes
- [ ] writeSelfDelimitedLength round-trips with parseSelfDelimitedLength
- [ ] assembleMultistreamPacket produces correct framing
- [ ] Encode produces valid multistream packets
- [ ] Bitrate distributes with weighted allocation
</verification>

<success_criteria>
- Self-delimiting length encoding matches RFC 6716 Section 3.2.1
- Packet assembly follows RFC 6716 Appendix B (N-1 prefixed, last standard)
- Encode() produces complete multistream packets
- SetBitrate distributes across streams with 3:2 ratio (coupled:mono)
- All encoder control methods propagate to stream encoders
</success_criteria>

<output>
After completion, create `.planning/phases/09-multistream-encoder/09-02-SUMMARY.md`
</output>
