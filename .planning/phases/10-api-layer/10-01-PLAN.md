---
phase: 10-api-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - decoder.go
  - encoder.go
  - errors.go
  - decoder_test.go
  - encoder_test.go
autonomous: true

must_haves:
  truths:
    - "NewDecoder creates a decoder that can decode Opus packets"
    - "Decoder.Decode accepts packet bytes and returns PCM samples"
    - "NewEncoder creates an encoder that can encode PCM to Opus packets"
    - "Encoder.Encode accepts PCM samples and returns packet bytes"
    - "Both int16 and float32 sample formats work correctly"
    - "Decode with nil data triggers packet loss concealment"
  artifacts:
    - path: "decoder.go"
      provides: "Public Decoder type wrapping internal/hybrid"
      exports: ["Decoder", "NewDecoder", "Decode", "DecodeFloat32", "DecodeInt16"]
    - path: "encoder.go"
      provides: "Public Encoder type wrapping internal/encoder"
      exports: ["Encoder", "NewEncoder", "Encode", "EncodeFloat32", "EncodeInt16"]
    - path: "errors.go"
      provides: "Public error types"
      exports: ["ErrInvalidSampleRate", "ErrInvalidChannels", "ErrBufferTooSmall", "ErrInvalidFrameSize"]
  key_links:
    - from: "decoder.go"
      to: "internal/hybrid/decoder.go"
      via: "wraps hybrid.Decoder"
      pattern: "hybrid\\.NewDecoder"
    - from: "encoder.go"
      to: "internal/encoder/encoder.go"
      via: "wraps encoder.Encoder"
      pattern: "encoder\\.NewEncoder"
---

<objective>
Implement the production-ready frame-based Encoder and Decoder public API in the root gopus package.

Purpose: Provide clean, documented public interfaces that wrap the internal encoder/decoder implementations, following established Go audio codec API conventions (pion/opus, hraban/opus patterns).

Output: Public Encoder and Decoder types with constructor functions, Encode/Decode methods supporting both float32 and int16 PCM formats, and comprehensive test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-api-layer/10-RESEARCH.md

# Internal implementations to wrap
@internal/hybrid/hybrid.go
@internal/hybrid/decoder.go
@internal/encoder/encoder.go

# Existing root package files
@doc.go
@packet.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create public error types and Decoder API</name>
  <files>errors.go, decoder.go, decoder_test.go</files>
  <action>
Create errors.go with public error types:
- ErrInvalidSampleRate: invalid sample rate (must be 8000, 12000, 16000, 24000, or 48000)
- ErrInvalidChannels: invalid channel count (must be 1 or 2)
- ErrBufferTooSmall: output buffer too small for decoded frame
- ErrInvalidFrameSize: input frame size doesn't match expected

Create decoder.go with public Decoder type:
- Decoder struct wrapping *hybrid.Decoder from internal/hybrid
- Fields: dec *hybrid.Decoder, sampleRate int, channels int, lastFrameSize int

Constructor:
- NewDecoder(sampleRate, channels int) (*Decoder, error)
- Validate sampleRate is one of: 8000, 12000, 16000, 24000, 48000
- Validate channels is 1 or 2
- Create internal hybrid.Decoder with appropriate channel count

Methods:
- Decode(data []byte, pcm []float32) (int, error): decode to float32 buffer
  - Parse TOC from data[0] to get frame size
  - If data is nil, use lastFrameSize for PLC
  - Validate pcm buffer is large enough (frameSize * channels)
  - Call internal decoder.DecodeToFloat32 or DecodeStereoToFloat32
  - Store frameSize in lastFrameSize
  - Return samples per channel

- DecodeInt16(data []byte, pcm []int16) (int, error): decode to int16 buffer
  - Internally decode to float32
  - Convert to int16 with proper clamping (multiply by 32767, clamp to [-32768, 32767])

- DecodeFloat32(data []byte) ([]float32, error): convenience returning new slice
  - Allocate buffer based on TOC frame size
  - Call Decode, return slice

- DecodeInt16Slice(data []byte) ([]int16, error): convenience returning new slice
  - Allocate buffer based on TOC frame size
  - Call DecodeInt16, return slice

- Reset(): clear decoder state
- Channels() int: return channel count
- SampleRate() int: return sample rate

Create decoder_test.go with tests:
- TestNewDecoder_ValidParams: valid sample rates and channels
- TestNewDecoder_InvalidSampleRate: returns ErrInvalidSampleRate
- TestNewDecoder_InvalidChannels: returns ErrInvalidChannels
- TestDecoder_Decode_Float32: encode with internal encoder, decode with public API
- TestDecoder_Decode_Int16: verify int16 conversion with clamping
- TestDecoder_Decode_BufferTooSmall: returns ErrBufferTooSmall
- TestDecoder_Decode_PLC: nil data triggers packet loss concealment
- TestDecoder_Reset: state clears properly
  </action>
  <verify>
go test -v -run TestDecoder ./...
go test -v -run TestNewDecoder ./...
  </verify>
  <done>
- NewDecoder validates parameters and creates working decoder
- Decode methods produce PCM output from Opus packets
- int16 and float32 formats both work with correct conversion
- nil data triggers PLC (packet loss concealment)
- All decoder tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Create public Encoder API</name>
  <files>encoder.go, encoder_test.go</files>
  <action>
Create encoder.go with public Encoder type:
- Encoder struct wrapping *encoder.Encoder from internal/encoder
- Fields: enc *encoder.Encoder, sampleRate int, channels int, frameSize int

Application hint type:
- Application type (int) with constants:
  - ApplicationVoIP: optimize for speech (prefers SILK mode)
  - ApplicationAudio: optimize for music (prefers CELT mode)
  - ApplicationLowDelay: minimize latency (CELT with small frames)

Constructor:
- NewEncoder(sampleRate, channels int, application Application) (*Encoder, error)
- Validate sampleRate is one of: 8000, 12000, 16000, 24000, 48000
- Validate channels is 1 or 2
- Create internal encoder.Encoder
- Apply application hint via mode/bandwidth settings:
  - ApplicationVoIP: ModeAuto with Wideband (prefers SILK)
  - ApplicationAudio: ModeAuto with Fullband (prefers CELT/Hybrid)
  - ApplicationLowDelay: ModeCELT with Fullband
- Default frame size: 960 (20ms at 48kHz)

Encode methods:
- Encode(pcm []float32, data []byte) (int, error): encode float32 to packet
  - Validate pcm length matches frameSize * channels
  - Convert float32 to float64 for internal encoder
  - Call internal encoder.Encode
  - Handle DTX (nil return means silence suppressed, return 0 bytes)
  - Copy to data buffer, return bytes written
  - Return ErrBufferTooSmall if data buffer insufficient

- EncodeInt16(pcm []int16, data []byte) (int, error): encode int16 to packet
  - Convert int16 to float32 (divide by 32768.0)
  - Call Encode

- EncodeFloat32(pcm []float32) ([]byte, error): convenience returning new slice
  - Allocate 4000-byte buffer (max Opus packet)
  - Call Encode, return trimmed slice

- EncodeInt16Slice(pcm []int16) ([]byte, error): convenience returning new slice

Configuration methods:
- SetBitrate(bitrate int) error: 6000-510000 bps
- Bitrate() int
- SetComplexity(complexity int) error: 0-10
- Complexity() int
- SetFEC(enabled bool)
- FECEnabled() bool
- SetDTX(enabled bool)
- DTXEnabled() bool
- SetFrameSize(samples int) error: validate for mode
- FrameSize() int
- Reset()
- Channels() int
- SampleRate() int

Create encoder_test.go with tests:
- TestNewEncoder_ValidParams: valid sample rates, channels, applications
- TestNewEncoder_InvalidParams: invalid sample rate/channels
- TestEncoder_Encode_Float32: encode sine wave, verify non-zero output
- TestEncoder_Encode_Int16: encode int16 input
- TestEncoder_Encode_RoundTrip: encode then decode, verify signal
- TestEncoder_SetBitrate: valid and invalid values
- TestEncoder_SetComplexity: valid and invalid values
- TestEncoder_DTX_Silence: silence produces nil/0-byte output
- TestEncoder_Reset: state clears properly
  </action>
  <verify>
go test -v -run TestEncoder ./...
go test -v -run TestNewEncoder ./...
  </verify>
  <done>
- NewEncoder validates parameters and creates working encoder
- Encode methods produce valid Opus packets from PCM
- int16 and float32 input formats both work
- Configuration methods (bitrate, complexity, FEC, DTX) work
- Round-trip encode/decode produces audible output
- All encoder tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration tests and documentation</name>
  <files>api_test.go, doc.go</files>
  <action>
Create api_test.go with integration tests:
- TestRoundTrip_Mono_Float32: encode/decode mono signal, verify energy preserved
- TestRoundTrip_Stereo_Float32: encode/decode stereo signal
- TestRoundTrip_Mono_Int16: int16 round-trip
- TestRoundTrip_Stereo_Int16: stereo int16 round-trip
- TestRoundTrip_MultipleFrames: encode/decode 10 consecutive frames, verify no artifacts
- TestRoundTrip_AllSampleRates: test all valid sample rates (8k, 12k, 16k, 24k, 48k)
- TestApplication_VoIP: verify VoIP application uses appropriate mode
- TestApplication_Audio: verify Audio application uses appropriate mode
- TestPLC_SingleLoss: verify PLC produces audio on single packet loss
- TestPLC_MultipleLoss: verify PLC fades gracefully on multiple losses

Test helpers:
- generateSineWave(sampleRate, freq, duration, channels): generate test signal
- computeEnergy(samples []float32): compute signal energy
- computeCorrelation(a, b []float32): compute correlation coefficient

Update doc.go with complete package documentation:
- Package overview with usage examples
- Encoder usage example (create, configure, encode)
- Decoder usage example (create, decode, handle PLC)
- Sample format guidance (when to use int16 vs float32)
- Thread safety note (types NOT safe for concurrent use)
- Buffer sizing guidance (max frame size is 2880 * channels for 60ms)

Document in doc.go:
```go
// Package gopus implements the Opus audio codec in pure Go.
//
// # Quick Start
//
// Encoding:
//
//   enc, err := gopus.NewEncoder(48000, 2, gopus.ApplicationAudio)
//   if err != nil {
//       log.Fatal(err)
//   }
//
//   pcm := make([]float32, 960*2) // 20ms stereo at 48kHz
//   // ... fill pcm with audio samples ...
//
//   packet, err := enc.EncodeFloat32(pcm)
//   if err != nil {
//       log.Fatal(err)
//   }
//
// Decoding:
//
//   dec, err := gopus.NewDecoder(48000, 2)
//   if err != nil {
//       log.Fatal(err)
//   }
//
//   pcm, err := dec.DecodeFloat32(packet)
//   if err != nil {
//       log.Fatal(err)
//   }
//
// # Sample Formats
//
// Both int16 and float32 PCM formats are supported. float32 is the
// internal format and avoids conversion overhead. int16 is provided
// for compatibility with common audio APIs.
//
// # Thread Safety
//
// Encoder and Decoder instances are NOT safe for concurrent use.
// Each goroutine should create its own instance.
//
// # Buffer Sizing
//
// For caller-provided buffers:
//   - Decode output: max 2880 * channels samples (60ms at 48kHz)
//   - Encode output: 4000 bytes is sufficient for any Opus packet
```
  </action>
  <verify>
go test -v ./... 2>&1 | head -100
go doc gopus | head -50
  </verify>
  <done>
- All integration tests pass
- Round-trip tests verify signal quality
- doc.go has complete usage examples
- Thread safety documented
- Buffer sizing documented
  </done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
go test -v ./...
```

Verify documentation renders:
```bash
go doc gopus
go doc gopus.Encoder
go doc gopus.Decoder
```

Verify no circular imports:
```bash
go build ./...
```
</verification>

<success_criteria>
- All tests pass (decoder, encoder, integration)
- Public API follows pion/opus and hraban/opus conventions
- Both int16 and float32 formats work correctly
- PLC works when Decode receives nil data
- Documentation complete with examples
- No breaking changes to existing packet.go API
</success_criteria>

<output>
After completion, create `.planning/phases/10-api-layer/10-01-SUMMARY.md`
</output>
