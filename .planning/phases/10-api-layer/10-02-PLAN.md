---
phase: 10-api-layer
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - stream.go
  - stream_test.go
autonomous: true

must_haves:
  truths:
    - "Reader wraps decoder for streaming decode of packet sequences"
    - "Writer wraps encoder for streaming encode to packet sequences"
    - "Reader implements io.Reader interface"
    - "Writer implements io.Writer interface"
    - "Frame boundaries handled internally with buffering"
  artifacts:
    - path: "stream.go"
      provides: "io.Reader/Writer streaming wrappers"
      exports: ["Reader", "NewReader", "Writer", "NewWriter", "PacketSource", "PacketSink"]
  key_links:
    - from: "stream.go"
      to: "decoder.go"
      via: "Reader uses Decoder"
      pattern: "Decoder\\)"
    - from: "stream.go"
      to: "encoder.go"
      via: "Writer uses Encoder"
      pattern: "Encoder\\)"
---

<objective>
Implement io.Reader and io.Writer streaming wrappers for continuous encode/decode operations.

Purpose: Provide streaming interfaces that handle frame boundaries internally, allowing Opus to integrate with Go's standard io patterns for streaming audio applications.

Output: Reader type implementing io.Reader for streaming decode, Writer type implementing io.Writer for streaming encode, with proper internal frame buffering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-api-layer/10-RESEARCH.md

# Plan 01 provides Encoder/Decoder types
@decoder.go
@encoder.go
@errors.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PacketSource/PacketSink interfaces and Reader</name>
  <files>stream.go, stream_test.go</files>
  <action>
Create stream.go with streaming infrastructure:

PacketSource interface for streaming decode:
```go
// PacketSource provides Opus packets for streaming decode.
// Implementations should return io.EOF when no more packets are available.
type PacketSource interface {
    // NextPacket returns the next Opus packet.
    // Returns io.EOF when stream ends.
    // Returns nil packet for PLC (packet loss).
    NextPacket() ([]byte, error)
}
```

PacketSink interface for streaming encode:
```go
// PacketSink receives encoded Opus packets from streaming encode.
type PacketSink interface {
    // WritePacket writes an encoded Opus packet.
    // Returns number of bytes written and any error.
    WritePacket(packet []byte) (int, error)
}
```

Reader struct for streaming decode:
```go
// Reader decodes an Opus stream, implementing io.Reader.
// Output is PCM samples in the configured format.
//
// The Reader handles frame boundaries internally, buffering decoded
// PCM samples and serving byte-oriented reads.
//
// Example:
//   reader, err := gopus.NewReader(48000, 2, source, gopus.FormatFloat32LE)
//   io.Copy(audioOutput, reader)
type Reader struct {
    dec      *Decoder
    source   PacketSource
    format   SampleFormat  // Output sample format

    pcmBuf   []float32     // Decoded PCM samples
    byteBuf  []byte        // PCM as bytes
    offset   int           // Current read position in byteBuf

    eof      bool          // Source exhausted
}
```

SampleFormat type:
```go
// SampleFormat specifies the PCM sample format for streaming.
type SampleFormat int

const (
    // FormatFloat32LE is 32-bit float, little-endian (4 bytes per sample).
    FormatFloat32LE SampleFormat = iota
    // FormatInt16LE is 16-bit signed integer, little-endian (2 bytes per sample).
    FormatInt16LE
)

// BytesPerSample returns the number of bytes per sample for the format.
func (f SampleFormat) BytesPerSample() int {
    switch f {
    case FormatFloat32LE:
        return 4
    case FormatInt16LE:
        return 2
    default:
        return 4
    }
}
```

NewReader constructor:
```go
// NewReader creates a streaming decoder.
//
// Parameters:
//   - sampleRate: output sample rate (8000, 12000, 16000, 24000, or 48000)
//   - channels: number of audio channels (1 or 2)
//   - source: provides Opus packets for decoding
//   - format: output sample format (FormatFloat32LE or FormatInt16LE)
func NewReader(sampleRate, channels int, source PacketSource, format SampleFormat) (*Reader, error)
```

Reader.Read implementing io.Reader:
- If byteBuf exhausted and not EOF, fetch next packet from source
- Handle io.EOF from source gracefully
- Handle nil packet (PLC) by calling Decode(nil, ...)
- Convert decoded PCM to bytes based on format:
  - FormatFloat32LE: use math.Float32bits, little-endian
  - FormatInt16LE: clamp and convert to int16, little-endian
- Copy available bytes to p, update offset
- Return n, nil (or io.EOF if source exhausted and buffer empty)

Additional Reader methods:
- SampleRate() int
- Channels() int
- Reset(): clear buffers and decoder state

Create stream_test.go with Reader tests:
- TestNewReader_ValidParams
- TestNewReader_InvalidParams
- TestReader_Read_SinglePacket: read from single-packet source
- TestReader_Read_MultiplePackets: read across packet boundaries
- TestReader_Read_PartialRead: verify partial reads work correctly
- TestReader_Read_EOF: verify EOF handling
- TestReader_Read_PLC: verify nil packet triggers PLC
- TestReader_Format_Float32LE: verify float32 byte format
- TestReader_Format_Int16LE: verify int16 byte format

Helper for tests:
```go
// slicePacketSource implements PacketSource for testing.
type slicePacketSource struct {
    packets [][]byte
    index   int
}

func (s *slicePacketSource) NextPacket() ([]byte, error) {
    if s.index >= len(s.packets) {
        return nil, io.EOF
    }
    packet := s.packets[s.index]
    s.index++
    return packet, nil
}
```
  </action>
  <verify>
go test -v -run TestReader ./...
go test -v -run TestNewReader ./...
  </verify>
  <done>
- PacketSource interface defined
- Reader implements io.Reader
- Frame boundaries handled with internal buffering
- Both FormatFloat32LE and FormatInt16LE work
- EOF and PLC handled correctly
- All Reader tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Writer for streaming encode</name>
  <files>stream.go, stream_test.go</files>
  <action>
Add Writer struct to stream.go:
```go
// Writer encodes PCM samples to an Opus stream, implementing io.Writer.
// Input is PCM samples in the configured format.
//
// The Writer buffers input samples until a complete frame is accumulated,
// then encodes and sends the packet to the sink.
//
// Example:
//   writer, err := gopus.NewWriter(48000, 2, sink, gopus.FormatFloat32LE, gopus.ApplicationAudio)
//   io.Copy(writer, audioInput)
//   writer.Flush() // encode any remaining buffered samples
type Writer struct {
    enc      *Encoder
    sink     PacketSink
    format   SampleFormat  // Input sample format

    sampleBuf []byte       // Buffered input bytes
    frameBytes int         // Bytes needed for one frame

    packetBuf []byte       // Buffer for encoded packet (4000 bytes)
}
```

NewWriter constructor:
```go
// NewWriter creates a streaming encoder.
//
// Parameters:
//   - sampleRate: input sample rate (8000, 12000, 16000, 24000, or 48000)
//   - channels: number of audio channels (1 or 2)
//   - sink: receives encoded Opus packets
//   - format: input sample format (FormatFloat32LE or FormatInt16LE)
//   - application: encoder application hint
func NewWriter(sampleRate, channels int, sink PacketSink, format SampleFormat, application Application) (*Writer, error)
```

Writer.Write implementing io.Writer:
- Append p to sampleBuf
- While sampleBuf has >= frameBytes:
  - Extract frame samples from sampleBuf
  - Convert bytes to PCM based on format:
    - FormatFloat32LE: math.Float32frombits, little-endian
    - FormatInt16LE: convert int16 to float32 (divide by 32768)
  - Call Encode
  - If packet not nil (not DTX suppressed), call sink.WritePacket
  - Remove consumed bytes from sampleBuf
- Return len(p), nil

Writer.Flush():
```go
// Flush encodes any buffered samples.
// If samples don't fill a complete frame, they are zero-padded.
// Call Flush before closing the stream to ensure all audio is encoded.
func (w *Writer) Flush() error
```
- If sampleBuf has remaining bytes:
  - Zero-pad to frameBytes
  - Encode and send to sink

Additional Writer methods:
- SetBitrate(bitrate int) error: pass through to encoder
- SetComplexity(complexity int) error
- SetFEC(enabled bool)
- SetDTX(enabled bool)
- Reset(): clear buffers and encoder state
- SampleRate() int
- Channels() int

Add Writer tests to stream_test.go:
- TestNewWriter_ValidParams
- TestNewWriter_InvalidParams
- TestWriter_Write_SingleFrame: write exactly one frame worth
- TestWriter_Write_MultipleFrames: write multiple frames
- TestWriter_Write_PartialFrame: verify buffering works
- TestWriter_Write_CrossFrameBoundary: write spanning frame boundary
- TestWriter_Flush: verify remaining samples encoded
- TestWriter_Format_Float32LE: verify float32 input parsing
- TestWriter_Format_Int16LE: verify int16 input parsing
- TestWriter_DTX: verify silence produces no packets

Helper for tests:
```go
// slicePacketSink implements PacketSink for testing.
type slicePacketSink struct {
    packets [][]byte
}

func (s *slicePacketSink) WritePacket(packet []byte) (int, error) {
    cp := make([]byte, len(packet))
    copy(cp, packet)
    s.packets = append(s.packets, cp)
    return len(packet), nil
}
```
  </action>
  <verify>
go test -v -run TestWriter ./...
go test -v -run TestNewWriter ./...
  </verify>
  <done>
- PacketSink interface defined
- Writer implements io.Writer
- Frame buffering works correctly
- Flush encodes remaining samples
- Both FormatFloat32LE and FormatInt16LE work
- All Writer tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration tests and documentation</name>
  <files>stream_test.go, stream.go</files>
  <action>
Add integration tests to stream_test.go:

TestStream_RoundTrip_Float32:
- Create Writer with slicePacketSink
- Write multiple frames of sine wave as float32 bytes
- Flush
- Create Reader with slicePacketSource from captured packets
- Read all bytes
- Convert back to float32, verify signal energy

TestStream_RoundTrip_Int16:
- Same as above but with FormatInt16LE

TestStream_Pipe:
- Create pipe: packetChan := make(chan []byte, 10)
- Create channelPacketSink/Source wrappers
- In goroutine: Writer writes audio, then Flush
- Main: Reader reads until EOF
- Verify output signal

TestStream_LargeTransfer:
- Write 1 second of audio (48000 * channels samples)
- Verify all encoded packets received
- Verify all decoded samples received

TestStream_io_Copy:
- Use io.Copy from Reader to bytes.Buffer
- Verify output size matches expected

Add documentation comments to stream.go:
```go
// Streaming API
//
// The Reader and Writer types provide io.Reader and io.Writer interfaces
// for streaming Opus encode/decode operations. They handle frame boundaries
// internally, allowing integration with Go's standard io patterns.
//
// # Streaming Decode
//
// To decode a stream of Opus packets:
//
//   source := &MyPacketSource{} // implements PacketSource
//   reader, err := gopus.NewReader(48000, 2, source, gopus.FormatFloat32LE)
//   if err != nil {
//       log.Fatal(err)
//   }
//
//   // Read decoded PCM bytes
//   buf := make([]byte, 4096)
//   for {
//       n, err := reader.Read(buf)
//       if err == io.EOF {
//           break
//       }
//       if err != nil {
//           log.Fatal(err)
//       }
//       processAudio(buf[:n])
//   }
//
// # Streaming Encode
//
// To encode PCM audio to a stream of Opus packets:
//
//   sink := &MyPacketSink{} // implements PacketSink
//   writer, err := gopus.NewWriter(48000, 2, sink, gopus.FormatFloat32LE, gopus.ApplicationAudio)
//   if err != nil {
//       log.Fatal(err)
//   }
//
//   // Write PCM bytes
//   pcmBytes := getPCMData() // float32 little-endian bytes
//   _, err = writer.Write(pcmBytes)
//   if err != nil {
//       log.Fatal(err)
//   }
//
//   // Flush remaining buffered samples
//   if err := writer.Flush(); err != nil {
//       log.Fatal(err)
//   }
//
// # Sample Format
//
// Both Reader and Writer support two sample formats:
//   - FormatFloat32LE: 32-bit float, little-endian (4 bytes per sample)
//   - FormatInt16LE: 16-bit signed integer, little-endian (2 bytes per sample)
//
// Samples are interleaved for stereo: [L0, R0, L1, R1, ...]
```
  </action>
  <verify>
go test -v -run TestStream ./...
go doc gopus.Reader
go doc gopus.Writer
  </verify>
  <done>
- Round-trip streaming tests pass
- io.Copy works with Reader
- Large transfer test validates complete audio processing
- Documentation complete with examples
  </done>
</task>

</tasks>

<verification>
Run full test suite:
```bash
go test -v ./...
```

Verify Reader implements io.Reader:
```bash
go build -o /dev/null -gcflags="-m" ./... 2>&1 | grep -i "implements io.Reader" || echo "Check interface compliance"
```

Verify documentation:
```bash
go doc gopus.Reader
go doc gopus.Writer
go doc gopus.PacketSource
go doc gopus.PacketSink
```
</verification>

<success_criteria>
- Reader implements io.Reader interface
- Writer implements io.Writer interface
- Frame boundaries handled transparently
- Both sample formats work correctly
- Round-trip streaming preserves audio
- Flush works correctly for partial frames
- Documentation complete with streaming examples
</success_criteria>

<output>
After completion, create `.planning/phases/10-api-layer/10-02-SUMMARY.md`
</output>
