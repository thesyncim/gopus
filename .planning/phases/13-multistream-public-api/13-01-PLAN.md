---
phase: 13-multistream-public-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - multistream.go
  - multistream_test.go
  - errors.go
  - doc.go
autonomous: true

must_haves:
  truths:
    - "User can create MultistreamEncoder with default 5.1/7.1 configuration"
    - "User can create MultistreamDecoder with default 5.1/7.1 configuration"
    - "User can encode 6-channel PCM to multistream packet"
    - "User can decode multistream packet to 6-channel PCM"
    - "Round-trip encode/decode produces valid audio for 5.1 surround"
    - "Round-trip encode/decode produces valid audio for 7.1 surround"
  artifacts:
    - path: "multistream.go"
      provides: "MultistreamEncoder and MultistreamDecoder public types"
      min_lines: 200
      exports: ["MultistreamEncoder", "MultistreamDecoder", "NewMultistreamEncoder", "NewMultistreamEncoderDefault", "NewMultistreamDecoder", "NewMultistreamDecoderDefault"]
    - path: "multistream_test.go"
      provides: "Tests for multistream public API"
      min_lines: 200
      contains: "TestMultistreamRoundTrip_51"
    - path: "errors.go"
      provides: "Multistream error types"
      exports: ["ErrInvalidStreams", "ErrInvalidCoupledStreams", "ErrInvalidMapping"]
  key_links:
    - from: "multistream.go"
      to: "internal/multistream.Encoder"
      via: "wrapper composition"
      pattern: "enc\\s+\\*multistream\\.Encoder"
    - from: "multistream.go"
      to: "internal/multistream.Decoder"
      via: "wrapper composition"
      pattern: "dec\\s+\\*multistream\\.Decoder"
    - from: "multistream_test.go"
      to: "multistream.go"
      via: "import gopus"
      pattern: "NewMultistreamEncoderDefault|NewMultistreamDecoderDefault"
---

<objective>
Create public API wrappers for multistream encoder and decoder

Purpose: Expose the complete internal/multistream implementation to gopus users for surround sound (5.1, 7.1) encoding and decoding. This closes the audit gap between completed internal multistream and missing public API.

Output:
- gopus.MultistreamEncoder wrapping internal/multistream.Encoder
- gopus.MultistreamDecoder wrapping internal/multistream.Decoder
- NewMultistreamEncoder/NewMultistreamEncoderDefault constructors
- NewMultistreamDecoder/NewMultistreamDecoderDefault constructors
- Round-trip tests for 5.1 and 7.1 channel layouts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-multistream-public-api/13-RESEARCH.md

# Existing patterns to follow
@encoder.go
@decoder.go
@errors.go
@api_test.go

# Internal implementation to wrap
@internal/multistream/encoder.go
@internal/multistream/decoder.go
@internal/multistream/multistream.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MultistreamEncoder and MultistreamDecoder wrappers</name>
  <files>multistream.go, errors.go</files>
  <action>
Create `multistream.go` in the gopus package root with:

**MultistreamEncoder struct:**
- Wraps `*multistream.Encoder`
- Stores sampleRate, channels, frameSize for validation
- Follows exact pattern from encoder.go

**MultistreamEncoder constructors:**
1. `NewMultistreamEncoder(sampleRate, channels, streams, coupledStreams int, mapping []byte, application Application) (*MultistreamEncoder, error)`
   - Validate sampleRate with validSampleRate()
   - Delegate to multistream.NewEncoder()
   - Apply application hints by calling SetBandwidth/SetMode on underlying encoder if needed
   - Return new wrapper

2. `NewMultistreamEncoderDefault(sampleRate, channels int, application Application) (*MultistreamEncoder, error)`
   - Validate sampleRate
   - Delegate to multistream.NewEncoderDefault()
   - Return new wrapper

**MultistreamEncoder methods (mirror Encoder pattern):**
- `Encode(pcm []float32, data []byte) (int, error)` - convert float32 to float64, call internal Encode
- `EncodeInt16(pcm []int16, data []byte) (int, error)` - convert int16 to float32, call Encode
- `EncodeFloat32(pcm []float32) ([]byte, error)` - convenience, allocates output
- `EncodeInt16Slice(pcm []int16) ([]byte, error)` - convenience
- `SetBitrate(bitrate int) error` - delegate to enc.SetBitrate
- `Bitrate() int` - delegate
- `SetComplexity(complexity int) error` - validate 0-10, delegate
- `Complexity() int` - delegate
- `SetFEC(enabled bool)` - delegate
- `FECEnabled() bool` - delegate
- `SetDTX(enabled bool)` - delegate
- `DTXEnabled() bool` - delegate
- `Reset()` - delegate
- `Channels() int` - return channels
- `SampleRate() int` - return sampleRate
- `Streams() int` - delegate
- `CoupledStreams() int` - delegate

**MultistreamDecoder struct:**
- Wraps `*multistream.Decoder`
- Stores sampleRate, channels, lastFrameSize

**MultistreamDecoder constructors:**
1. `NewMultistreamDecoder(sampleRate, channels, streams, coupledStreams int, mapping []byte) (*MultistreamDecoder, error)`
   - Validate sampleRate
   - Delegate to multistream.NewDecoder()

2. `NewMultistreamDecoderDefault(sampleRate, channels int) (*MultistreamDecoder, error)`
   - Validate sampleRate
   - Delegate to multistream.NewDecoderDefault()

**MultistreamDecoder methods (mirror Decoder pattern):**
- `Decode(data []byte, pcm []float32) (int, error)` - call internal Decode, convert float64 to float32
- `DecodeInt16(data []byte, pcm []int16) (int, error)` - decode to float32, convert
- `DecodeFloat32(data []byte) ([]float32, error)` - convenience
- `DecodeInt16Slice(data []byte) ([]int16, error)` - convenience
- `Reset()` - delegate
- `Channels() int` - return channels
- `SampleRate() int` - return sampleRate
- `Streams() int` - delegate
- `CoupledStreams() int` - delegate

**Error handling:**
- Re-use ErrInvalidSampleRate from errors.go
- Add to errors.go:
  - `ErrInvalidStreams = errors.New("gopus: invalid stream count (must be 1-255)")`
  - `ErrInvalidCoupledStreams = errors.New("gopus: invalid coupled streams (must be 0 to streams)")`
  - `ErrInvalidMapping = errors.New("gopus: invalid mapping table")`

**Key implementation detail:**
The internal multistream uses float64 internally. The public API should:
1. Accept float32 from users (consistent with Encoder/Decoder)
2. Convert to float64 for internal call
3. Convert result back to float32

For decoder, get frame size from packet TOC. The internal Decode expects frameSize as parameter.
Parse first stream's TOC to get frame size: `toc := ParseTOC(data[0])` then use `toc.FrameSize`.
But note multistream packets have length prefixes! Need to skip length bytes to get to first TOC.
Use internal/multistream.parseSelfDelimitedLength if needed, or simply pass a default frameSize (960) and let internal decoder handle it.

Actually, looking at internal multistream.Decode signature: `Decode(data []byte, frameSize int)` - it expects frameSize to be passed in. For convenience methods, use lastFrameSize like Decoder does. For buffer-based Decode, require caller to pass frameSize or infer from packet.

Simplest approach: Let Decode accept frameSize as parameter OR determine from packet. For public API consistency with gopus.Decoder, we'll parse the first TOC after skipping any length prefix.

Alternative: Add optional frameSize parameter or use 960 default (20ms). The internal multistream.validateStreamDurations already handles frame size validation.

Decision: Mirror Decoder API - parse TOC to get frameSize, or use lastFrameSize for PLC.
  </action>
  <verify>go build ./... compiles without errors</verify>
  <done>MultistreamEncoder and MultistreamDecoder types exist with all constructors and methods</done>
</task>

<task type="auto">
  <name>Task 2: Create multistream round-trip tests</name>
  <files>multistream_test.go</files>
  <action>
Create `multistream_test.go` in the gopus package with tests following api_test.go patterns:

**Helper functions:**
- `generateSurroundTestSignal(sampleRate, frameSize, channels int) []float32` - generate unique frequency per channel
- `computeEnergyFloat32(samples []float32) float64` - compute RMS energy
- `computeChannelEnergy(samples []float32, channels, targetChannel int) float64` - compute energy for single channel

**Test functions:**

1. `TestMultistreamEncoder_Creation(t *testing.T)`
   - Test NewMultistreamEncoderDefault for channels 1-8
   - Verify Channels(), SampleRate(), Streams(), CoupledStreams() return correct values
   - Test invalid sample rates return ErrInvalidSampleRate
   - Test invalid channels return error

2. `TestMultistreamDecoder_Creation(t *testing.T)`
   - Test NewMultistreamDecoderDefault for channels 1-8
   - Verify getters return correct values
   - Test invalid parameters return errors

3. `TestMultistreamRoundTrip_51(t *testing.T)` - 5.1 surround (6 channels)
   - Create encoder/decoder with NewMultistreamEncoderDefault/NewMultistreamDecoderDefault
   - Generate 6-channel test signal (unique frequency per channel)
   - Encode with EncodeFloat32
   - Decode with DecodeFloat32
   - Verify output length matches input (frameSize * channels)
   - Compute and log energy ratio
   - Verify non-zero output energy

4. `TestMultistreamRoundTrip_71(t *testing.T)` - 7.1 surround (8 channels)
   - Same pattern as 5.1 but with 8 channels

5. `TestMultistreamRoundTrip_Stereo(t *testing.T)` - 2 channels
   - Verify multistream API works for stereo (edge case)

6. `TestMultistreamRoundTrip_MultipleFrames(t *testing.T)`
   - Encode/decode 10 consecutive frames
   - Verify state continuity (no crashes, valid output each frame)

7. `TestMultistreamEncoder_Controls(t *testing.T)`
   - Test SetBitrate, SetComplexity, SetFEC, SetDTX
   - Verify getters return set values
   - Encode a frame after setting controls to verify no errors

8. `TestMultistreamDecoder_PLC(t *testing.T)`
   - Decode one valid packet
   - Call DecodeFloat32(nil) for PLC
   - Verify PLC produces output without error

9. `TestMultistreamRoundTrip_Int16(t *testing.T)`
   - Test int16 encode/decode path
   - Use EncodeInt16Slice and DecodeInt16Slice

10. `TestMultistreamEncoder_Reset(t *testing.T)`
    - Encode frames, Reset(), encode more
    - Verify no crashes

Log energy ratios and packet sizes for diagnostic purposes. Tests should not fail on energy thresholds (known decoder issues), but should fail on:
- Encode/decode errors
- Zero output length
- Unexpected panics
  </action>
  <verify>go test -v -run TestMultistream ./... passes all tests</verify>
  <done>Multistream public API tests exist covering 5.1, 7.1, controls, PLC, and edge cases</done>
</task>

<task type="auto">
  <name>Task 3: Update documentation and verify full test suite</name>
  <files>doc.go</files>
  <action>
1. Update `doc.go` to document multistream API:
   - Add section about multistream encoding/decoding
   - Document supported channel configurations (1-8 channels)
   - Reference MultistreamEncoder and MultistreamDecoder
   - Add example showing 5.1 surround usage

2. Run full test suite to verify no regressions:
   ```
   go test ./...
   ```

3. Verify build with no cgo:
   ```
   CGO_ENABLED=0 go build ./...
   ```

4. Check that multistream exports are accessible:
   - NewMultistreamEncoder
   - NewMultistreamEncoderDefault
   - NewMultistreamDecoder
   - NewMultistreamDecoderDefault
   - MultistreamEncoder type and methods
   - MultistreamDecoder type and methods
  </action>
  <verify>go test ./... passes, CGO_ENABLED=0 go build ./... succeeds</verify>
  <done>Documentation updated, all tests pass, no cgo dependencies, multistream API fully exported</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./...` succeeds
2. `go test ./...` passes all tests (including new multistream tests)
3. `CGO_ENABLED=0 go build ./...` succeeds (pure Go)
4. The following code compiles and runs:
   ```go
   enc, _ := gopus.NewMultistreamEncoderDefault(48000, 6, gopus.ApplicationAudio)
   dec, _ := gopus.NewMultistreamDecoderDefault(48000, 6)
   pcm := make([]float32, 960*6)
   packet, _ := enc.EncodeFloat32(pcm)
   out, _ := dec.DecodeFloat32(packet)
   ```
</verification>

<success_criteria>
- MultistreamEncoder and MultistreamDecoder exported from gopus package
- NewMultistreamEncoder and NewMultistreamEncoderDefault constructors work
- NewMultistreamDecoder and NewMultistreamDecoderDefault constructors work
- Round-trip tests pass for 5.1 and 7.1 channel layouts
- All existing tests continue to pass (no regressions)
- Zero cgo dependencies verified
</success_criteria>

<output>
After completion, create `.planning/phases/13-multistream-public-api/13-01-SUMMARY.md`
</output>
