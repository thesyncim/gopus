---
phase: 07-celt-encoder
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/celt/bands_encode.go
  - internal/celt/bands_encode_test.go
autonomous: true

must_haves:
  truths:
    - "Band normalization divides MDCT coefficients by energy to get unit-norm shapes"
    - "vectorToPulses converts normalized float vector to integer pulse vector with L1 norm = K"
    - "PVQ encoding produces indices decodable by existing DecodePulses"
    - "Shape encode -> decode round-trip reconstructs normalized shape"
  artifacts:
    - path: "internal/celt/bands_encode.go"
      provides: "Band normalization and PVQ encoding"
      exports: ["NormalizeBands", "vectorToPulses", "EncodeBandPVQ", "EncodeBands"]
  key_links:
    - from: "internal/celt/bands_encode.go"
      to: "internal/celt/cwrs.go"
      via: "Uses existing EncodePulses"
      pattern: "EncodePulses"
    - from: "internal/celt/bands_encode.go"
      to: "internal/celt/pvq.go"
      via: "Uses existing PVQ_V, NormalizeVector"
      pattern: "PVQ_V|NormalizeVector"
---

<objective>
Implement CELT PVQ band encoding: normalize bands to unit vectors, quantize to pulse vectors, encode with CWRS.

Purpose: PVQ (Pyramid Vector Quantization) encodes the shape of each frequency band as a sparse pulse vector. The existing EncodePulses function from Phase 3 converts pulse vectors to indices. The encoder must convert normalized float vectors to integer pulses that, when decoded, reconstruct the original shape.

Output: NormalizeBands, vectorToPulses, EncodeBandPVQ, EncodeBands with shape encode->decode tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-celt-encoder/07-RESEARCH.md

# Existing PVQ/CWRS code from Phase 3
@internal/celt/cwrs.go
@internal/celt/pvq.go
@internal/celt/bands.go
@internal/celt/alloc.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement band normalization</name>
  <files>internal/celt/bands_encode.go</files>
  <action>
Create bands_encode.go with band normalization:

```go
// NormalizeBands divides each band's MDCT coefficients by its energy,
// producing unit-norm shapes ready for PVQ quantization.
// Returns shapes[band] = normalized coefficients for that band.
func (e *Encoder) NormalizeBands(mdctCoeffs []float64, energies []float64, nbBands, frameSize int) [][]float64
```

Implementation:
1. For each channel and band:
   - Get band boundaries: ScaledBandStart/End
   - Extract coefficients for this band
   - Compute gain = 2^energy (energy is log2 scale)
   - Divide coefficients by gain: shape[i] = coeff[i] / gain
   - Call existing NormalizeVector() to ensure unit L2 norm
   - Store in shapes[c*nbBands + band]

2. Handle degenerate cases:
   - gain near zero: set shape to first-unit-vector [1, 0, 0, ...]
   - all coeffs zero: same fallback

The decoder does: output = shape * gain (denormalization)
So encoder does: shape = input / gain (normalization)
  </action>
  <verify>`go build ./internal/celt/` compiles</verify>
  <done>NormalizeBands produces unit-norm shape vectors for each band</done>
</task>

<task type="auto">
  <name>Task 2: Implement vectorToPulses and PVQ encoding</name>
  <files>internal/celt/bands_encode.go</files>
  <action>
Add PVQ quantization to bands_encode.go:

```go
// vectorToPulses converts a normalized float vector to integer pulse vector.
// The result has L1 norm (sum of absolute values) equal to k.
// This is the encoder's inverse of decoder's pulse-to-vector reconstruction.
func vectorToPulses(shape []float64, k int) []int
```

Implementation of vectorToPulses:
1. Compute L1 norm of shape
2. Scale shape so L1 norm = k: scaledShape[i] = shape[i] * k / l1norm
3. Round each component: pulses[i] = round(scaledShape[i])
4. Track remaining = k - sum(|pulses[i]|)
5. Distribute remaining pulses:
   - Find positions with largest fractional error
   - Add/subtract pulses to minimize distortion
6. Verify sum(|pulses|) == k

```go
// EncodeBandPVQ encodes a normalized band shape using PVQ.
// k is the number of pulses (determined by bit allocation via bitsToK).
func (e *Encoder) EncodeBandPVQ(shape []float64, n, k int)
```

Implementation:
1. Convert shape to pulses: pulses = vectorToPulses(shape, k)
2. Encode to index: index = EncodePulses(pulses, n, k) // existing function
3. Encode index uniformly: e.rangeEncoder.EncodeUniform(index, PVQ_V(n, k))

Add helper: `bitsToKEncode(bits, n int) int` - convert allocated bits to pulse count
(mirrors decoder's bitsToK)
  </action>
  <verify>`go build ./internal/celt/` compiles</verify>
  <done>vectorToPulses and EncodeBandPVQ implemented</done>
</task>

<task type="auto">
  <name>Task 3: Implement EncodeBands and tests</name>
  <files>internal/celt/bands_encode.go, internal/celt/bands_encode_test.go</files>
  <action>
1. Add EncodeBands to bands_encode.go:

```go
// EncodeBands encodes all bands using PVQ.
// shapes: normalized band shapes from NormalizeBands
// bandBits: bit allocation per band from ComputeAllocation
func (e *Encoder) EncodeBands(shapes [][]float64, bandBits []int, nbBands, frameSize int)
```

Implementation:
- For each band:
  - Get shape and allocated bits
  - If bits <= 0: skip (band will be folded by decoder)
  - Compute k = bitsToKEncode(bandBits[band], bandWidth)
  - Call EncodeBandPVQ(shape, bandWidth, k)

2. Create bands_encode_test.go:

a) TestVectorToPulses:
   - Input: [0.6, 0.8, 0, 0] normalized
   - k = 10
   - Verify sum(|output|) == 10
   - Verify output preserves shape direction

b) TestVectorToPulsesRoundTrip:
   - Create normalized vector
   - Convert to pulses with k
   - Normalize pulses back to float
   - Verify direction preserved (dot product close to 1)

c) TestPVQEncodeDecodeRoundTrip:
   - Create encoder and decoder
   - Generate random normalized shape
   - Determine k from bits
   - Encode shape with EncodeBandPVQ
   - Get bytes, init range decoder
   - Decode with DecodePVQ (or DecodePulses + normalize)
   - Verify decoded shape is close to original

d) TestEncodeBandsAllSizes:
   - Test with frameSize = 120, 240, 480, 960
   - Verify all bands encode without error

e) TestPVQEncodingPreservesEnergy:
   - Verify L2 norm of decoded shape is 1.0
  </action>
  <verify>`go test ./internal/celt/ -run "Pulse|PVQ.*Encode|EncodeBand" -v` passes</verify>
  <done>EncodeBands implemented, PVQ encode->decode round-trip verified</done>
</task>

</tasks>

<verification>
After all tasks:
1. `go build ./internal/celt/` - compiles without errors
2. `go test ./internal/celt/ -v` - all tests pass
3. vectorToPulses produces valid pulse vectors (L1 norm = k)
4. PVQ encode->decode preserves shape direction
5. EncodeBands works for all frame sizes
6. Existing decoder tests still pass
</verification>

<success_criteria>
- NormalizeBands produces unit-norm shapes
- vectorToPulses converts floats to integers with correct L1 norm
- EncodePulses (existing) + EncodeUniform produces valid indices
- Decode(Encode(shape)) reconstructs shape direction (dot product > 0.9)
- All frame sizes supported
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-celt-encoder/07-03-SUMMARY.md`
</output>
