---
phase: 07-celt-encoder
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/rangecoding/encoder.go
  - internal/rangecoding/roundtrip_test.go
  - internal/celt/roundtrip_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Range encoder produces bytes that decoder can correctly decode"
    - "Encoded bits round-trip through encode->decode cycle"
    - "CELT encoded audio has non-zero energy after decode"
  artifacts:
    - path: "internal/rangecoding/encoder.go"
      provides: "Fixed range encoder with libopus-compatible byte format"
      exports: ["Encoder", "Init", "Encode", "EncodeICDF", "Done"]
    - path: "internal/rangecoding/roundtrip_test.go"
      provides: "Round-trip tests proving encoder-decoder compatibility"
      contains: "TestEncodeDecodeBitRoundTrip"
    - path: "internal/celt/roundtrip_test.go"
      provides: "Updated tests verifying non-zero decoded energy"
      contains: "hasNonZeroSamples"
  key_links:
    - from: "internal/rangecoding/encoder.go"
      to: "internal/rangecoding/decoder.go"
      via: "byte format compatibility"
      pattern: "normalize|Done"
---

<objective>
Fix range encoder byte format to match decoder expectations, enabling true encode-decode round-trips with correct signal reconstruction.

Purpose: The encoder produces valid packet structure but the byte-level format differs from what the decoder expects. This causes decoded audio to have low/zero energy, making the encoder non-functional for actual audio encoding. This is the ROOT CAUSE blocking success criteria #3 (perceptually acceptable audio).

Output: Range encoder that produces bytes correctly decodable by the range decoder, with round-trip tests proving compatibility.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-celt-encoder/07-01-SUMMARY.md
@internal/rangecoding/encoder.go
@internal/rangecoding/decoder.go
@internal/rangecoding/constants.go

Key context from STATE.md:
- D01-02-02: Round-trip verification deferred (known gap from Phase 1)
- D07-01-04: Round-trip verification deferred for EncodeUniform (extends to all encoding)
- Root cause: encoder's byte-format alignment differs from decoder expectations

From encoder.go analysis:
- The normalize() function handles carry propagation and byte output
- Done() finalizes encoding and produces the byte stream
- The key asymmetry is likely in how bytes are written vs how decoder reads them

From decoder.go analysis:
- Init() reads first byte and computes initial value via: val = rng - 1 - (byte >> shift)
- normalize() reads bytes and updates val via: val = ((val << 8) + (255 ^ sym)) & mask
- The decoder expects a specific byte ordering that encoder may not match
</context>

<tasks>

<task type="auto">
  <name>Task 1: Analyze and fix range encoder byte format</name>
  <files>internal/rangecoding/encoder.go</files>
  <action>
The encoder and decoder must be symmetric inverses. Study the exact byte format expected by decoder:

1. **Decoder initialization** (decoder.go Init):
   - Reads first byte
   - val = rng - 1 - (byte >> (8 - EC_CODE_EXTRA))
   - rng starts at 1 << EC_CODE_EXTRA (128)

2. **Decoder normalize** (decoder.go normalize):
   - For each byte: val = ((val << 8) + (255 ^ sym)) & (EC_CODE_TOP - 1)
   - The XOR with 255 inverts the byte

3. **Expected encoder behavior**:
   - Encoder must output bytes that, when XORed with 255 and shifted into val, reconstruct the encoded symbols
   - The Done() function must produce bytes in the exact order decoder expects

Fix the encoder by:
a) Reviewing libopus ec_enc_done() in celt/entenc.c for exact byte output logic
b) Ensuring normalize() outputs bytes in the correct order for decoder consumption
c) Ensuring Done() finalizes the stream with correct padding/termination

The key insight: libopus encoder outputs bytes such that decoder can XOR with 255 and shift left. The current encoder may be writing bytes in the wrong order or with incorrect carry handling.

Specific areas to check:
- In normalize(): The extension byte handling (ext counter and 0xFF bytes)
- In Done(): The final byte output order and masking
- Byte ordering: MSB-first vs LSB-first alignment

If the issue is in Done(), the fix likely involves:
- Computing the correct final value to output
- Outputting bytes in the order decoder expects (high bits first)
- Handling the carry propagation correctly
  </action>
  <verify>
Run `go test -v ./internal/rangecoding/... -run Round` to verify round-trip tests.
  </verify>
  <done>
Range encoder Done() produces bytes that decoder Init()+normalize() can correctly consume.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive encoder-decoder round-trip tests</name>
  <files>internal/rangecoding/roundtrip_test.go</files>
  <action>
Add tests that verify true encode->decode round-trips. These tests MUST pass, not just verify "determinism".

Tests to add:

1. **TestEncodeDecodeBitRoundTrip**: Single bit encode->decode
   - Encode a bit with EncodeBit(val, logp)
   - Call Done() to get bytes
   - Init decoder with those bytes
   - DecodeBit(logp) must return same val
   - Test both val=0 and val=1 with various logp values

2. **TestEncodeDecodeICDFRoundTrip**: ICDF symbol encode->decode
   - Encode symbol with EncodeICDF(s, icdf, ftb)
   - Decode with DecodeICDF(icdf, ftb)
   - Decoded symbol must equal encoded symbol

3. **TestEncodeDecodeUniformRoundTrip**: Uniform value encode->decode
   - Encode value with EncodeUniform(val, ft)
   - Decode with DecodeUniform(ft)
   - Decoded value must equal encoded value

4. **TestEncodeDecodeMultipleBitsRoundTrip**: Multiple bits sequence
   - Encode sequence of bits
   - Decode sequence, verify all match

5. **TestEncodeDecodeRawBitsRoundTrip**: Raw bits at end of buffer
   - Encode regular data + raw bits
   - Decode and verify raw bits match

Each test should:
- Create encoder, encode data, call Done()
- Create decoder with encoded bytes
- Decode data
- Assert decoded == encoded

IMPORTANT: These tests must PASS, not skip. If encoder is fixed correctly in Task 1, these will pass. If any fail, Task 1 fix is incomplete.
  </action>
  <verify>
`go test -v ./internal/rangecoding/... -run RoundTrip` - all tests must PASS (not skip, not log "deferred").
  </verify>
  <done>
Round-trip tests prove encoder output is correctly decodable by decoder.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update CELT round-trip tests to verify signal quality</name>
  <files>internal/celt/roundtrip_test.go</files>
  <action>
Update the CELT round-trip tests to verify decoded output has actual signal content, not just "completion without panic".

Changes:

1. **Remove "known gap" caveats**: The comments about D07-01-04 should be removed or updated once the range coder is fixed.

2. **Add signal energy verification**: In TestCELTRoundTripMono and TestCELTRoundTripStereo:
   - After decoding, compute RMS energy of output
   - Verify energy is above a reasonable threshold (e.g., > 0.01 for sine wave input of amplitude 0.5)
   - FAIL the test if decoded output is all zeros or near-zero

3. **Update hasNonZeroSamples checks**: Change from informational logging to actual assertions:
   ```go
   if !hasNonZeroSamples(decoded) {
       t.Errorf("Decoded output has no energy - range coding issue not fixed")
   }
   ```

4. **Add energy comparison** (optional but valuable):
   - Compute input energy and output energy
   - Log the ratio (for debugging)
   - At minimum, output energy should be > 1% of input energy

The goal: Tests should FAIL if decoded audio is silent/zeros, not just log a note about it.
  </action>
  <verify>
`go test -v ./internal/celt/... -run RoundTrip` - tests pass AND log shows non-zero decoded energy.
  </verify>
  <done>
CELT round-trip tests fail if decoded output has no energy, proving range coder fix works end-to-end.
  </done>
</task>

</tasks>

<verification>
1. `go test -v ./internal/rangecoding/... -run RoundTrip` - All round-trip tests PASS
2. `go test -v ./internal/celt/... -run RoundTrip` - All tests PASS with non-zero output energy
3. `go test ./...` - All existing tests still pass (no regressions)
</verification>

<success_criteria>
- Range encoder produces bytes that decoder correctly decodes
- EncodeBit -> DecodeBit round-trip works for all bit values and logp settings
- EncodeICDF -> DecodeICDF round-trip works for all symbol values
- EncodeUniform -> DecodeUniform round-trip works for all value/ft combinations
- CELT encoded audio decodes to non-zero energy output
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-celt-encoder/07-05-SUMMARY.md`
</output>
