---
phase: 07-celt-encoder
plan: 06
type: execute
wave: 2
depends_on: ["07-05"]
files_modified:
  - internal/celt/libopus_test.go
  - internal/celt/crossval_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "gopus CELT encoder packets are decodable by libopus opusdec"
    - "Cross-validation tests compare gopus output with libopus reference"
    - "Signal quality verified with energy ratio >10% of input"
  artifacts:
    - path: "internal/celt/libopus_test.go"
      provides: "Cross-validation tests using opusdec command-line tool"
      contains: "TestLibopusCrossValidation"
    - path: "internal/celt/crossval_test.go"
      provides: "Helper functions for libopus integration"
      exports: ["decodeWithOpusdec", "compareWaveforms"]
  key_links:
    - from: "internal/celt/crossval_test.go"
      to: "opusdec"
      via: "exec.Command shell out"
      pattern: "exec\\.Command.*opusdec"
---

<objective>
Add cross-validation tests that verify gopus CELT encoder packets are decodable by libopus reference implementation.

Purpose: Success criteria #2 requires "CELT encoder produces packets decodable by libopus". Currently only self-validation exists (encode with gopus, decode with gopus). Cross-validation with libopus proves interoperability with the reference implementation.

Output: Test suite that encodes audio with gopus, decodes with libopus opusdec, and verifies signal quality.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-celt-encoder/07-05-SUMMARY.md
@internal/celt/celt_encode.go
@internal/celt/roundtrip_test.go

Key constraints:
- Project is pure Go - no cgo allowed in production code
- Tests can use exec.Command to shell out to external tools
- opusdec is available at /opt/homebrew/bin/opusdec

Cross-validation approach:
1. Encode PCM with gopus CELT encoder to get Opus packet bytes
2. Wrap packet in minimal Ogg container (required by opusdec)
3. Run opusdec to decode the Ogg file to WAV
4. Read WAV file and compare with original input

Alternative approach (simpler):
1. Create a raw Opus file (no Ogg container) with header
2. Use opusdec --rate to decode raw packets
3. Note: opusdec requires Ogg container, so we need minimal Ogg support in tests only

Simplest approach:
1. Use "opus-tools" test mode or create minimal wrapper
2. Or: skip opusdec and use a cgo-based decoder IN TESTS ONLY (build tag: +build cgo)
3. Build tag ensures production builds remain pure Go

Recommended: Shell out to opusdec with Ogg container. The Ogg format is simple enough to construct manually for single-frame test cases.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cross-validation test helpers</name>
  <files>internal/celt/crossval_test.go</files>
  <action>
Create helper functions for libopus cross-validation. These helpers construct Ogg Opus files from raw packets and invoke opusdec.

**IMPORTANT: Minimal Ogg implementation for test purposes only.**
This is NOT a general-purpose Ogg library. The implementation is intentionally minimal:
- Single-frame test cases only (no multi-frame streaming)
- One packet per Ogg page (no segment aggregation)
- Fixed-size headers: OpusHead (19 bytes), OpusTags (~30 bytes)
- No pagination complexity - each test encodes 1-5 frames max
- No seeking, no chaining, no multiplexing

Functions to implement:

1. **checkOpusdecAvailable()**: Check if opusdec is in PATH
   - Run `opusdec --version` and check exit code
   - Return bool indicating availability
   - Tests should skip if opusdec not available

2. **writeOggOpus(w io.Writer, packets [][]byte, sampleRate, channels int) error**: Write minimal Ogg Opus file
   - Write Ogg page with OpusHead header (RFC 7845)
   - Write Ogg page with OpusTags header (minimal: "gopus" vendor string)
   - Write Ogg page(s) with audio packets
   - Each packet gets its own Ogg page for simplicity (no segment table complexity)

   OpusHead format (19 bytes):
   - "OpusHead" magic (8 bytes)
   - Version: 1 (1 byte)
   - Channel count (1 byte)
   - Pre-skip: 0 (2 bytes LE)
   - Input sample rate (4 bytes LE)
   - Output gain: 0 (2 bytes LE)
   - Channel mapping family: 0 (1 byte)

   Ogg page format (minimal):
   - "OggS" capture pattern (4 bytes)
   - Stream structure version: 0 (1 byte)
   - Header type flag (1 byte)
   - Granule position (8 bytes LE)
   - Bitstream serial number (4 bytes LE)
   - Page sequence number (4 bytes LE)
   - CRC checksum (4 bytes LE) - use hash/crc32 with polynomial 0x04C11DB7
   - Number of segments (1 byte)
   - Segment table (N bytes) - one entry per packet
   - Segment data

3. **decodeWithOpusdec(oggData []byte) ([]float32, error)**: Decode Ogg Opus with opusdec
   - Write oggData to temp file
   - Run: opusdec --float input.opus output.wav
   - Parse WAV file to extract float32 samples
   - Clean up temp files
   - Return decoded samples

4. **parseWAV(data []byte) ([]float32, int, int, error)**: Parse WAV file
   - Parse RIFF/WAVE header
   - Extract sample rate, channels, sample format
   - Read PCM data as float32 (if float) or convert from int16

5. **computeSNR(original, decoded []float32) float64**: Compute Signal-to-Noise Ratio
   - Handle length differences (trim or pad)
   - SNR = 10 * log10(signal_power / noise_power)
   - noise = decoded - original
   - Return SNR in dB

6. **computeEnergy(samples []float32) float64**: Compute RMS energy
   - sqrt(sum(s^2) / len(s))
  </action>
  <verify>
`go build ./internal/celt/` compiles successfully (helpers are in test file, should not affect main build).
  </verify>
  <done>
Helper functions exist for writing minimal Ogg Opus files (single-frame test support), decoding with opusdec, and comparing waveforms.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add libopus cross-validation tests</name>
  <files>internal/celt/libopus_test.go</files>
  <action>
Create cross-validation tests that encode with gopus and decode with libopus opusdec.

Tests to add:

1. **TestLibopusCrossValidationMono**: Mono CELT encode->decode
   - Skip if opusdec not available
   - Generate 20ms sine wave (960 samples at 48kHz)
   - Encode with gopus CELT encoder
   - Wrap in Ogg Opus container
   - Decode with opusdec
   - Verify decoded output has reasonable energy (not silent)
   - Compute and log SNR (informational, don't fail on low SNR yet)
   - PASS if opusdec decodes without error

2. **TestLibopusCrossValidationStereo**: Stereo CELT encode->decode
   - Same as mono but with stereo signal
   - Verify both channels have content

3. **TestLibopusCrossValidationAllFrameSizes**: All frame sizes
   - Test 2.5ms, 5ms, 10ms, 20ms frames
   - Each should decode without error

4. **TestLibopusCrossValidationSilence**: Silence frame
   - Encode silence, verify opusdec handles it

5. **TestLibopusCrossValidationMultipleFrames**: Multiple consecutive frames
   - Encode 5 frames of varying content
   - Write all to single Ogg file
   - Decode and verify no errors

Test structure:
```go
func TestLibopusCrossValidationMono(t *testing.T) {
    if !checkOpusdecAvailable() {
        t.Skip("opusdec not available in PATH")
    }

    // Generate test signal
    pcm := generateSineWave(440.0, 960)

    // Encode with gopus
    encoded, err := celt.Encode(pcm, 960)
    if err != nil {
        t.Fatalf("Encode failed: %v", err)
    }

    // Wrap in Ogg Opus
    var ogg bytes.Buffer
    err = writeOggOpus(&ogg, [][]byte{encoded}, 48000, 1)
    if err != nil {
        t.Fatalf("writeOggOpus failed: %v", err)
    }

    // Decode with opusdec
    decoded, err := decodeWithOpusdec(ogg.Bytes())
    if err != nil {
        t.Fatalf("opusdec failed: %v", err)
    }

    // Verify output
    if len(decoded) == 0 {
        t.Fatal("opusdec produced empty output")
    }

    energy := computeEnergy(decoded)
    t.Logf("Decoded energy: %v", energy)

    if energy < 0.01 {
        t.Errorf("Decoded output has low energy: %v", energy)
    }

    // Informational SNR
    snr := computeSNR(float32Slice(pcm), decoded)
    t.Logf("SNR: %.1f dB", snr)
}
```

IMPORTANT: Tests should be skipped (not failed) if opusdec is not available. This allows CI to run without opus-tools installed.
  </action>
  <verify>
`go test -v ./internal/celt/... -run Libopus` - tests PASS (or SKIP if opusdec not available).
  </verify>
  <done>
Cross-validation tests prove gopus CELT encoder packets are decodable by libopus opusdec.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add signal quality metrics to test output</name>
  <files>internal/celt/libopus_test.go</files>
  <action>
Enhance cross-validation tests with signal quality metrics.

Add to existing tests:

1. **Energy ratio check**:
   - Compute input energy and output energy
   - Verify output energy is at least 10% of input energy
   - Log the ratio for debugging

2. **Peak detection**:
   - Find peak amplitude in decoded output
   - Verify it's in reasonable range (not clipped, not silent)

3. **Zero-crossing rate** (optional):
   - Compare zero-crossing rate of input vs output
   - Similar rates indicate similar frequency content

4. **Summary logging**:
   - Log comprehensive quality report for each test:
     - Input: samples, energy, peak
     - Encoded: bytes
     - Decoded: samples, energy, peak, SNR
     - Verdict: PASS/FAIL with reason

The goal is to make test output informative for debugging signal quality issues.

Example output format:
```
=== RUN   TestLibopusCrossValidationMono
    libopus_test.go:50: Input: 960 samples, energy=0.354, peak=0.500
    libopus_test.go:55: Encoded: 125 bytes
    libopus_test.go:70: Decoded: 960 samples, energy=0.312, peak=0.487
    libopus_test.go:75: Energy ratio: 88.1% (threshold: 10%)
    libopus_test.go:80: SNR: 18.5 dB
    libopus_test.go:85: Cross-validation PASSED
--- PASS: TestLibopusCrossValidationMono (0.15s)
```
  </action>
  <verify>
`go test -v ./internal/celt/... -run Libopus` - shows quality metrics in output.
  </verify>
  <done>
Cross-validation tests report signal quality metrics (energy ratio >10% threshold, SNR) for debugging.
  </done>
</task>

</tasks>

<verification>
1. `go test -v ./internal/celt/... -run Libopus` - All cross-validation tests PASS (or SKIP if no opusdec)
2. `go test ./...` - All existing tests still pass (no regressions)
3. Manual verification: Run with opusdec available, confirm tests PASS with reasonable quality metrics
</verification>

<success_criteria>
- Helper functions exist for minimal Ogg Opus writing (single-frame test support) and WAV parsing
- opusdec successfully decodes gopus-encoded packets
- Decoded output has non-zero energy (not silent)
- Energy ratio check enforces >10% threshold
- Tests skip gracefully if opusdec not available
- Quality metrics logged for debugging
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-celt-encoder/07-06-SUMMARY.md`
</output>
