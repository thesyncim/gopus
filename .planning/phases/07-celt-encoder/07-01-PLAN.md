---
phase: 07-celt-encoder
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/rangecoding/encoder.go
  - internal/celt/encoder.go
  - internal/celt/mdct_encode.go
  - internal/celt/preemph.go
  - internal/celt/encoder_test.go
autonomous: true

must_haves:
  truths:
    - "EncodeUniform encodes values decodable by DecodeUniform"
    - "CELT encoder struct mirrors decoder state for synchronized prediction"
    - "Forward MDCT produces frequency coefficients from time samples"
    - "MDCT -> IMDCT round-trip reconstructs original signal (without quantization)"
    - "Pre-emphasis filter prepares audio for MDCT analysis"
  artifacts:
    - path: "internal/rangecoding/encoder.go"
      provides: "Range encoder with EncodeUniform"
      exports: ["Encoder", "EncodeUniform"]
    - path: "internal/celt/encoder.go"
      provides: "Encoder struct with state mirroring decoder"
      exports: ["Encoder", "NewEncoder", "Reset"]
    - path: "internal/celt/mdct_encode.go"
      provides: "Forward MDCT transform"
      exports: ["MDCT", "MDCTShort"]
    - path: "internal/celt/preemph.go"
      provides: "Pre-emphasis filter"
      exports: ["ApplyPreemphasis"]
  key_links:
    - from: "internal/rangecoding/encoder.go"
      to: "internal/rangecoding/decoder.go"
      via: "EncodeUniform is symmetric inverse of DecodeUniform"
      pattern: "EncodeUniform.*DecodeUniform"
    - from: "internal/celt/encoder.go"
      to: "internal/rangecoding/encoder.go"
      via: "rangeEncoder field"
      pattern: "rangecoding\\.Encoder"
    - from: "internal/celt/mdct_encode.go"
      to: "internal/celt/mdct.go"
      via: "MDCT is transpose of IMDCT"
      pattern: "IMDCT.*spectrum"
---

<objective>
Create the CELT encoder foundation: extend range encoder with EncodeUniform, create encoder struct, forward MDCT, and pre-emphasis filter.

Purpose: Establish the encoding infrastructure that mirrors the Phase 3 decoder. EncodeUniform is required by Plans 02 and 03 for fine energy and PVQ encoding. The encoder struct maintains state for inter-frame prediction (energy, overlap). Forward MDCT converts time-domain samples to frequency-domain coefficients for quantization.

Output: EncodeUniform method, Encoder struct, MDCT function, pre-emphasis filter, with round-trip tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-celt-encoder/07-RESEARCH.md

# Phase 3 decoder for reference
@internal/celt/decoder.go
@internal/celt/mdct.go
@internal/celt/tables.go
@internal/rangecoding/encoder.go
@internal/rangecoding/decoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EncodeUniform to range encoder</name>
  <files>internal/rangecoding/encoder.go</files>
  <action>
Add EncodeUniform method to the existing range encoder. This is the symmetric inverse of DecodeUniform.

```go
// EncodeUniform encodes a uniformly distributed value in the range [0, ft).
// This is used for fine energy bits and PVQ indices.
// Reference: libopus celt/entenc.c ec_enc_uint()
func (e *Encoder) EncodeUniform(val uint32, ft uint32)
```

Implementation (mirrors DecodeUniform exactly):

1. Handle edge case: if ft <= 1, do nothing (only one possible value)

2. Calculate number of bits: ftb := ilog(ft - 1)

3. If ftb > EC_SYM_BITS (multi-byte case):
   - ftb -= EC_SYM_BITS
   - ft1 := (ft - 1) >> ftb
   - Encode high bits: e.encodeUniformInternal(val >> ftb, ft1 + 1)
   - Encode low bits raw: e.EncodeRawBits(val & ((1 << ftb) - 1), ftb)

4. If ftb <= EC_SYM_BITS (single-byte case):
   - e.encodeUniformInternal(val, ft)

Add helper method:

```go
// encodeUniformInternal encodes a uniform value when ft <= 256.
func (e *Encoder) encodeUniformInternal(val uint32, ft uint32) {
    r := e.rng / ft
    if val+1 < ft {
        e.val += val * r
        e.rng = r
    } else {
        e.val += val * r
        e.rng -= val * r
    }
    e.normalize()
}
```

Also add EncodeRawBits method if not present:

```go
// EncodeRawBits writes raw bits to the end of the buffer.
// This is the inverse of DecodeRawBits.
func (e *Encoder) EncodeRawBits(val uint32, bits uint) {
    e.endWindow |= val << e.nendBits
    e.nendBits += int(bits)
    for e.nendBits >= 8 {
        e.writeEndByte(byte(e.endWindow))
        e.endWindow >>= 8
        e.nendBits -= 8
    }
}

// writeEndByte writes a byte to the end of the buffer (growing backwards).
func (e *Encoder) writeEndByte(b byte) {
    e.endOffs++
    if e.endOffs <= e.storage-e.offs {
        e.buf[e.storage-e.endOffs] = b
    }
}
```

Update Done() to flush any remaining raw bits to the end.

Key: EncodeUniform(x, ft) followed by DecodeUniform(ft) must return x.
  </action>
  <verify>`go build ./internal/rangecoding/` compiles and `go test ./internal/rangecoding/ -v` passes</verify>
  <done>EncodeUniform added to range encoder, round-trip with DecodeUniform verified</done>
</task>

<task type="auto">
  <name>Task 2: Create CELT Encoder struct</name>
  <files>internal/celt/encoder.go</files>
  <action>
Create Encoder struct mirroring Decoder state from decoder.go:

```go
type Encoder struct {
    // Range encoder reference (set per frame)
    rangeEncoder *rangecoding.Encoder

    // Configuration (mirrors decoder)
    channels   int
    sampleRate int // Always 48000

    // Energy state (persists across frames, mirrors decoder)
    prevEnergy  []float64 // Previous frame band energies [MaxBands * channels]
    prevEnergy2 []float64 // Two frames ago

    // Synthesis state for overlap (mirrors decoder)
    overlapBuffer []float64 // MDCT overlap [Overlap * channels]
    preemphState  []float64 // Pre-emphasis filter state [channels]

    // RNG state (for deterministic folding decisions)
    rng uint32

    // Analysis buffers (encoder-specific)
    inputBuffer []float64 // Input sample lookahead
    mdctBuffer  []float64 // MDCT output
}
```

Implement:
- `NewEncoder(channels int) *Encoder` - mirrors NewDecoder exactly
- `Reset()` - clears all state
- `SetRangeEncoder(re *rangecoding.Encoder)`
- Getters for state: Channels(), SampleRate(), PrevEnergy(), etc.
- `SetPrevEnergy(energies []float64)` - shifts prev to prev2, sets new prev

Use same initial values as decoder (D03-01-01, D03-01-02):
- prevEnergy initialized to -28.0 (low but finite)
- rng seed 22222
  </action>
  <verify>File compiles: `go build ./internal/celt/`</verify>
  <done>Encoder struct exists with state mirroring decoder, NewEncoder creates properly initialized instance</done>
</task>

<task type="auto">
  <name>Task 3: Implement forward MDCT, pre-emphasis, and tests</name>
  <files>internal/celt/mdct_encode.go, internal/celt/preemph.go, internal/celt/encoder_test.go</files>
  <action>
1. Implement forward MDCT (time to frequency transform) in mdct_encode.go.

The forward MDCT is the transpose of IMDCT:
- Input: 2N time samples (windowed)
- Output: N frequency coefficients

Formula: X[k] = sum_{n=0}^{2N-1} x[n] * cos(pi/N * (n + 0.5 + N/2) * (k + 0.5))

Implement:

a) `MDCT(samples []float64) []float64` - forward MDCT
   - Takes 2*N samples, returns N coefficients
   - Apply Vorbis window from window.go (same as decoder)
   - Direct computation initially (can optimize later)
   - Normalization: no additional scaling needed (IMDCT has 2/N)

b) `MDCTShort(samples []float64, shortBlocks int) []float64` - for transient frames
   - Process multiple short blocks
   - Interleave coefficients same way decoder expects

Use existing VorbisWindow from window.go for windowing.

2. Create preemph.go with pre-emphasis filter:

```go
// ApplyPreemphasis applies the pre-emphasis filter to PCM input.
// Pre-emphasis: y[n] = x[n] - PreemphCoef * x[n-1]
// This is the inverse of decoder's de-emphasis.
func (e *Encoder) ApplyPreemphasis(pcm []float64) []float64
```

Uses PreemphCoef = 0.85 from tables.go (D03-05-03).
Maintains state in e.preemphState for frame continuity.

3. Create encoder_test.go with tests:

a) TestNewEncoder - verify initialization matches decoder
b) TestMDCTRoundTrip - MDCT -> IMDCT reconstructs original
   - Create sine wave input (2*N samples)
   - Apply MDCT to get N coefficients
   - Apply IMDCT to get 2*N samples back
   - Verify output matches input (within tolerance for windowing overlap)

c) TestPreemphasisDeemphasis - pre-emphasis -> de-emphasis round-trip
   - Apply pre-emphasis
   - Apply de-emphasis (using decoder's applyDeemphasis logic)
   - Verify reconstruction

d) TestMDCTShortRoundTrip - test with 2, 4, 8 short blocks

e) TestEncodeUniformRoundTrip - test in rangecoding package
   - Encode value with EncodeUniform
   - Decode with DecodeUniform
   - Verify match for various values and ft ranges
  </action>
  <verify>`go test ./internal/celt/ -run "Encoder|MDCT.*Round|Preemph" -v` and `go test ./internal/rangecoding/ -run "Uniform" -v` pass</verify>
  <done>Pre-emphasis implemented, MDCT->IMDCT round-trip verified, EncodeUniform round-trip verified, all tests pass</done>
</task>

</tasks>

<verification>
After all tasks:
1. `go build ./internal/rangecoding/` - compiles without errors
2. `go build ./internal/celt/` - compiles without errors
3. `go test ./internal/rangecoding/ -v` - all tests pass including EncodeUniform round-trip
4. `go test ./internal/celt/ -v` - all tests pass including new encoder tests
5. EncodeUniform -> DecodeUniform round-trip produces matching values
6. MDCT -> IMDCT round-trip produces matching output (verify in test)
7. Pre-emphasis -> de-emphasis round-trip reconstructs original
</verification>

<success_criteria>
- EncodeUniform exists and produces values decodable by DecodeUniform
- Encoder struct mirrors Decoder state (same fields for energy, overlap, preemph)
- NewEncoder initializes with same defaults as NewDecoder
- Forward MDCT produces correct frequency coefficients
- MDCT -> IMDCT round-trip works (tested)
- Pre-emphasis filter implemented and tested
- All existing CELT decoder tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-celt-encoder/07-01-SUMMARY.md`
</output>
