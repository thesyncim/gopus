---
phase: 07-celt-encoder
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - internal/celt/transient.go
  - internal/celt/stereo_encode.go
  - internal/celt/encode_frame.go
  - internal/celt/celt_encode.go
  - internal/celt/roundtrip_test.go
autonomous: true

must_haves:
  truths:
    - "Transient detection identifies frames needing short MDCT blocks"
    - "Complete frame encoding produces packets decodable by Phase 3 decoder"
    - "Encoder round-trip (encode -> decode) produces audible output"
    - "Stereo encoding uses mid-side mode and encodes dual_stereo=0, intensity=-1"
  artifacts:
    - path: "internal/celt/transient.go"
      provides: "Transient detection"
      exports: ["DetectTransient"]
    - path: "internal/celt/stereo_encode.go"
      provides: "Stereo encoding modes"
      exports: ["EncodeStereoParams", "EncodeMidSide"]
    - path: "internal/celt/encode_frame.go"
      provides: "Frame encoding pipeline"
      exports: ["EncodeFrame"]
    - path: "internal/celt/celt_encode.go"
      provides: "Public encoding API"
      exports: ["Encode", "EncodeStereo"]
  key_links:
    - from: "internal/celt/encode_frame.go"
      to: "internal/celt/decoder.go"
      via: "Encoded packets decode via DecodeFrame"
      pattern: "DecodeFrame"
    - from: "internal/celt/celt_encode.go"
      to: "internal/rangecoding/encoder.go"
      via: "Creates range encoder for frame"
      pattern: "rangecoding\\.NewEncoder"
---

<objective>
Complete the CELT encoder: transient detection, stereo modes, frame pipeline, public API, and round-trip tests.

Purpose: Integrate all encoding components into a complete frame encoder. The EncodeFrame function takes PCM samples and produces CELT packets. Round-trip testing verifies packets decode through the Phase 3 decoder without errors.

Output: DetectTransient, EncodeFrame, Encode/EncodeStereo API with comprehensive round-trip tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-celt-encoder/07-RESEARCH.md

# Decoder for round-trip testing
@internal/celt/decoder.go
@internal/celt/modes.go
@internal/celt/stereo.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement transient detection and stereo encoding</name>
  <files>internal/celt/transient.go, internal/celt/stereo_encode.go</files>
  <action>
1. Create transient.go with transient detection:

```go
// DetectTransient analyzes PCM for sudden energy changes.
// Returns true if frame should use short MDCT blocks.
func (e *Encoder) DetectTransient(pcm []float64, frameSize int) bool
```

Implementation:
- Divide frame into 8 short blocks
- Compute energy per block: sum of squares
- Find max energy ratio between adjacent blocks
- Return true if maxRatio > 4.0 (6dB threshold, per research)

Short blocks are triggered when:
- Sharp attack (drum hit, pluck)
- Sudden silence
- Energy jumps > 6dB between sub-blocks

2. Create stereo_encode.go with stereo mode encoding:

```go
// EncodeStereoParams encodes stereo mode parameters to the bitstream.
// For initial implementation: mid-side only (dual_stereo=0, intensity_stereo=-1).
// Returns intensity band (-1 since intensity stereo is disabled).
func (e *Encoder) EncodeStereoParams(nbBands int) int
```

**Stereo mode flag encoding (critical for decoder compatibility):**

The decoder reads stereo params in decodeStereoParams() which expects:
- `intensity` band index encoded with Laplace model (if bits available)
- `dual_stereo` flag encoded as single bit (if bits available)

For initial implementation (mid-side only, no intensity stereo):
1. When encoding stereo frames and bits available for intensity:
   - Encode intensity = nbBands (meaning: no intensity stereo, all bands are mid-side)
   - Use: `encodeLaplace(nbBands, intensityDecay)` where intensityDecay matches decoder
2. When encoding dual_stereo flag:
   - Encode dual_stereo = 0 (meaning: use mid-side, not independent L/R)
   - Use: `e.rangeEncoder.EncodeBit(0, 1)` (50% probability bit)

Reference decoder's decodeStereoParams in stereo.go to ensure exact format match.

```go
// ConvertToMidSide converts L/R to mid/side representation.
func ConvertToMidSide(left, right []float64) (mid, side []float64)
```

Implementation:
- mid[i] = (left[i] + right[i]) / sqrt(2)
- side[i] = (left[i] - right[i]) / sqrt(2)

**Note:** This initial implementation ONLY supports mid-side stereo (the most common mode).
Intensity stereo and dual stereo will be added in a future enhancement phase.
  </action>
  <verify>`go build ./internal/celt/` compiles</verify>
  <done>Transient detection and stereo encoding implemented with proper bitstream format</done>
</task>

<task type="auto">
  <name>Task 2: Implement complete frame encoding pipeline</name>
  <files>internal/celt/encode_frame.go</files>
  <action>
Create encode_frame.go with the frame encoding pipeline:

```go
// EncodeFrame encodes a complete CELT frame from PCM samples.
// pcm: input samples (interleaved if stereo), length = frameSize * channels
// frameSize: 120, 240, 480, or 960 samples
// Returns: encoded bytes
func (e *Encoder) EncodeFrame(pcm []float64, frameSize int) ([]byte, error)
```

Pipeline (mirrors decoder's DecodeFrame):

1. Validate inputs (frameSize, pcm length)
2. Get mode config: GetModeConfig(frameSize)
3. Detect transient: shortBlocks = 1, or 2/4/8 if transient
4. Apply pre-emphasis: preemph = e.ApplyPreemphasis(pcm)

5. Compute MDCT:
   - If not transient: coeffs = MDCT(preemph)
   - If transient: coeffs = MDCTShort(preemph, shortBlocks)

6. Compute band energies: energies = e.ComputeBandEnergies(coeffs, nbBands, frameSize)
7. Normalize bands: shapes = e.NormalizeBands(coeffs, energies, nbBands, frameSize)

8. Initialize range encoder
9. Encode silence flag (0 = not silence)
10. Encode transient flag (if lm >= 1)
11. Encode intra flag (first frame or after reset)

12. **For stereo frames:** Encode stereo params via EncodeStereoParams(nbBands)
    - This writes intensity band and dual_stereo flag to bitstream
    - Must be done BEFORE energy encoding (decoder reads it first)

13. Encode coarse energy: e.EncodeCoarseEnergy(energies, nbBands, intra, lm)
14. Compute bit allocation: ComputeAllocation(...)
15. Encode fine energy: e.EncodeFineEnergy(energies, nbBands, fineBits)
16. Encode bands: e.EncodeBands(shapes, bandBits, nbBands, frameSize)
17. Encode energy remainder: e.EncodeEnergyRemainder(nbBands, remainderBits)

18. Finalize: bytes = e.rangeEncoder.Done()
19. Update state: e.SetPrevEnergy(energies)

Return encoded bytes.
  </action>
  <verify>`go build ./internal/celt/` compiles</verify>
  <done>EncodeFrame pipeline implemented with correct stereo param encoding order</done>
</task>

<task type="auto">
  <name>Task 3: Implement public API and round-trip tests</name>
  <files>internal/celt/celt_encode.go, internal/celt/roundtrip_test.go</files>
  <action>
1. Create celt_encode.go with public API:

```go
// Encode encodes mono PCM samples to a CELT packet.
// pcm: float64 samples at 48kHz
// frameSize: 120, 240, 480, or 960 samples
// Returns: encoded Opus CELT packet bytes
func Encode(pcm []float64, frameSize int) ([]byte, error)

// EncodeStereo encodes stereo PCM samples to a CELT packet.
// pcm: interleaved L/R float64 samples at 48kHz
// frameSize: 120, 240, 480, or 960 samples per channel
// Returns: encoded Opus CELT packet bytes
func EncodeStereo(pcm []float64, frameSize int) ([]byte, error)
```

Implementation:
- Create encoder if not exists (package-level or passed in)
- Call EncodeFrame
- Return bytes

2. Create roundtrip_test.go:

a) TestCELTRoundTripMono:
   - Generate sine wave (440Hz, 48kHz, 20ms = 960 samples)
   - Encode with Encode()
   - Decode with decoder.DecodeFrame()
   - Verify no error, output length matches
   - Verify output is not all zeros

b) TestCELTRoundTripStereo:
   - Generate stereo sine wave (different frequencies L/R)
   - Encode with EncodeStereo()
   - Decode with decoder (2 channels)
   - Verify stereo output
   - Verify decoder correctly reads stereo params (mid-side mode)

c) TestCELTRoundTripAllFrameSizes:
   - Test frameSize = 120, 240, 480, 960
   - Verify each encodes and decodes without error

d) TestCELTRoundTripTransient:
   - Generate signal with transient (silence then impulse)
   - Encode (should detect transient)
   - Decode
   - Verify output

e) TestCELTRoundTripSilence:
   - Encode zero samples
   - Decode
   - Verify silent output

f) TestCELTRoundTripMultipleFrames:
   - Encode 5 consecutive frames
   - Decode all
   - Verify inter-frame state is maintained (energy prediction)

g) TestStereoParamsRoundTrip:
   - Encode stereo frame
   - Verify decoder reads intensity=-1 (no intensity stereo)
   - Verify decoder reads dual_stereo=0 (mid-side mode)
  </action>
  <verify>`go test ./internal/celt/ -run "RoundTrip" -v` passes</verify>
  <done>Public API and round-trip tests complete, all tests pass including stereo mode verification</done>
</task>

</tasks>

<verification>
After all tasks:
1. `go build ./internal/celt/` - compiles without errors
2. `go test ./internal/celt/ -v` - all tests pass
3. Round-trip: Encode() -> DecodeFrame() produces valid audio
4. All frame sizes work (120, 240, 480, 960)
5. Mono and stereo both work
6. Stereo packets contain correct mode flags (dual_stereo=0, intensity at nbBands)
7. Transient detection triggers short blocks when appropriate
8. Multiple consecutive frames maintain state correctly
</verification>

<success_criteria>
- DetectTransient identifies energy jumps > 6dB
- EncodeStereoParams writes correct bitstream format (intensity + dual_stereo flags)
- EncodeFrame produces valid CELT packets with stereo params in correct position
- Encode/EncodeStereo public API works
- Round-trip encode->decode produces non-zero output
- Decoder correctly interprets stereo mode flags
- All frame sizes supported
- Multi-frame encoding maintains inter-frame state
- All existing decoder tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-celt-encoder/07-04-SUMMARY.md`
</output>
