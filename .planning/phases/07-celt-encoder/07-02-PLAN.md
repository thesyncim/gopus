---
phase: 07-celt-encoder
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/celt/energy_encode.go
  - internal/celt/energy_encode_test.go
autonomous: true

must_haves:
  truths:
    - "Band energy computation extracts energy per frequency band from MDCT coefficients"
    - "Coarse energy encoding produces quantized values decodable by decoder"
    - "Fine energy encoding adds precision bits decodable by decoder"
    - "Energy encode -> decode round-trip produces matching values"
  artifacts:
    - path: "internal/celt/energy_encode.go"
      provides: "Energy computation and encoding"
      exports: ["ComputeBandEnergies", "EncodeCoarseEnergy", "EncodeFineEnergy"]
  key_links:
    - from: "internal/celt/energy_encode.go"
      to: "internal/celt/energy.go"
      via: "Encoding mirrors decoding exactly"
      pattern: "DecodeCoarseEnergy|DecodeFineEnergy"
    - from: "internal/celt/energy_encode.go"
      to: "internal/celt/tables.go"
      via: "Uses AlphaCoef, BetaCoef, DB6"
      pattern: "AlphaCoef|BetaCoef|DB6"
---

<objective>
Implement CELT energy encoding: band energy computation, coarse quantization (6dB steps), and fine quantization.

Purpose: Energy encoding captures the loudness of each frequency band. Coarse energy uses Laplace-distributed symbols (6dB steps). Fine energy adds fractional precision. The encoder must produce values the decoder reconstructs identically.

Output: ComputeBandEnergies, EncodeCoarseEnergy, EncodeFineEnergy with encode->decode round-trip tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-celt-encoder/07-RESEARCH.md

# Decoder energy functions for reference
@internal/celt/energy.go
@internal/celt/tables.go
@internal/celt/alloc.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement band energy computation</name>
  <files>internal/celt/energy_encode.go</files>
  <action>
Create energy_encode.go with band energy computation:

```go
// ComputeBandEnergies computes energy for each frequency band from MDCT coefficients.
// Returns energies in log2 scale (same as decoder expects).
// energies[c*nbBands + band] = log2(RMS energy of band for channel c)
func (e *Encoder) ComputeBandEnergies(mdctCoeffs []float64, nbBands, frameSize int) []float64
```

Implementation:
1. For each channel and band:
   - Get band boundaries: ScaledBandStart(band, frameSize) to ScaledBandEnd(band, frameSize)
   - Compute sum of squares of coefficients in band
   - Convert to log2 scale: energy = 0.5 * log2(sumSq / bandWidth)
   - Handle zero energy: use -28.0 (same as decoder default, D03-01-01)

2. Return energies array: [nbBands * channels]

Energy is in log2 scale where:
- energy = log2(sqrt(sumSq)) = 0.5 * log2(sumSq)
- This matches how decoder denormalizes bands

Add helper: `computeBandRMS(coeffs []float64, start, end int) float64`
  </action>
  <verify>`go build ./internal/celt/` compiles</verify>
  <done>ComputeBandEnergies implemented, produces log2-scale energies per band</done>
</task>

<task type="auto">
  <name>Task 2: Implement coarse and fine energy encoding</name>
  <files>internal/celt/energy_encode.go</files>
  <action>
Add coarse and fine energy encoding to energy_encode.go:

1. `EncodeCoarseEnergy(energies []float64, nbBands int, intra bool, lm int)`:
   - Mirror decoder's DecodeCoarseEnergy exactly (in reverse)
   - Use same AlphaCoef[lm], BetaCoef[lm] for prediction
   - Quantize residual to integer: qi = round((energy - pred) / DB6)
   - Encode qi with Laplace model using encodeLaplace()
   - Update prevEnergy state after encoding

2. `encodeLaplace(val int, decay int)`:
   - Symmetric Laplace encoding (0, +1, -1, +2, -2, ...)
   - Use same fs0, decay parameters as decoder
   - For val=0: encode center symbol
   - For val!=0: encode magnitude and sign

3. `EncodeFineEnergy(energies []float64, quantizedCoarse []float64, nbBands int, fineBits []int)`:
   - Compute residual: fine = energy - quantizedCoarse
   - Quantize to fineBits[band] levels
   - Encode uniformly: q = round((fine / DB6 + 0.5) * (1 << fineBits))
   - Use EncodeUniform from range encoder

4. `EncodeEnergyRemainder(nbBands int, remainderBits []int)`:
   - Encode any leftover precision bits
   - Single bit decisions for finest precision

Key: Must use SAME constants as decoder (laplaceNMIN=16, laplaceFS=32768, etc.)
  </action>
  <verify>`go build ./internal/celt/` compiles</verify>
  <done>Coarse and fine energy encoding implemented with Laplace model</done>
</task>

<task type="auto">
  <name>Task 3: Add energy encode-decode round-trip tests</name>
  <files>internal/celt/energy_encode_test.go</files>
  <action>
Create energy_encode_test.go with round-trip tests:

1. TestComputeBandEnergies:
   - Create synthetic MDCT coefficients (sine at different bands)
   - Verify energies are in expected range
   - Verify zero-input produces -28.0 energy

2. TestCoarseEnergyRoundTrip:
   - Create encoder and decoder
   - Generate random energies in valid range (-28 to +8)
   - Encode with EncodeCoarseEnergy
   - Get bytes from encoder, init decoder
   - Decode with DecodeCoarseEnergy
   - Verify decoded values match quantized encoded values (6dB precision)

3. TestFineEnergyRoundTrip:
   - Same pattern as coarse
   - Verify fine bits add expected precision

4. TestEnergyEncodingAllBandwidths:
   - Test with lm=0,1,2,3 (all frame sizes)
   - Test intra=true and intra=false
   - Verify encode->decode produces matching energies

5. TestLaplaceSymmetry:
   - Verify encodeLaplace produces values decodable by decodeLaplace
   - Test range: -10 to +10

Important: Use identical parameters to decoder (decay values, fs0 computation).
  </action>
  <verify>`go test ./internal/celt/ -run "Energy.*Encode|Laplace" -v` passes</verify>
  <done>Energy encoding tests pass, round-trip produces matching values</done>
</task>

</tasks>

<verification>
After all tasks:
1. `go build ./internal/celt/` - compiles without errors
2. `go test ./internal/celt/ -v` - all tests pass
3. Coarse energy encode->decode round-trip matches (6dB quantization)
4. Fine energy adds expected precision
5. All frame sizes (lm 0-3) and modes (intra/inter) work
</verification>

<success_criteria>
- ComputeBandEnergies produces correct log2-scale energies
- EncodeCoarseEnergy uses same prediction as decoder (AlphaCoef, BetaCoef)
- Laplace encoding matches decoder's Laplace decoding
- EncodeFineEnergy adds correct fractional precision
- Encode -> decode round-trip produces identical quantized energies
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-celt-encoder/07-02-SUMMARY.md`
</output>
