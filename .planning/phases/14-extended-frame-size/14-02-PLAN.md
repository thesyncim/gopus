---
phase: 14-extended-frame-size
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - internal/celt/synthesis.go
  - internal/celt/decoder.go
  - internal/celt/synthesis_test.go
  - internal/celt/decoder_test.go
autonomous: true

must_haves:
  truths:
    - "CELT 2.5ms frames (120 samples) decode correctly"
    - "CELT 5ms frames (240 samples) decode correctly"
    - "CELT decoder produces exactly frameSize samples per frame"
    - "Short frame decoding uses correct EffBands (13 for 2.5ms, 17 for 5ms)"
  artifacts:
    - path: "internal/celt/synthesis.go"
      provides: "Correct overlap-add for all frame sizes"
      contains: "frameSize"
    - path: "internal/celt/decoder_test.go"
      provides: "Short frame decode tests"
      exports: ["TestDecodeFrame_ShortFrames"]
  key_links:
    - from: "internal/celt/decoder.go"
      to: "internal/celt/synthesis.go"
      via: "Synthesize call in DecodeFrame"
      pattern: "d.Synthesize"
---

<objective>
Enable CELT 2.5ms and 5ms frame decoding

Purpose: RFC 8251 test vectors include CELT short frames. The mode configurations exist in modes.go but the decoding path needs verification that short frames work correctly with fewer bands and smaller MDCT sizes.

Output: CELT decoder handles 2.5ms (120 samples) and 5ms (240 samples) frames correctly.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-extended-frame-size/14-RESEARCH.md
@.planning/phases/14-extended-frame-size/14-01-SUMMARY.md

@internal/celt/modes.go
@internal/celt/decoder.go
@internal/celt/synthesis.go
@internal/celt/tables.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify short frame mode configuration and band handling</name>
  <files>internal/celt/decoder.go</files>
  <action>
Verify DecodeFrame correctly handles short frames:

1. Confirm GetModeConfig returns correct parameters for 120 and 240:
   - 120 samples: LM=0, EffBands=13, ShortBlocks=1
   - 240 samples: LM=1, EffBands=17, ShortBlocks=2

2. Verify coarse energy decoding uses correct nbBands (13 or 17, not 21):
```go
mode := GetModeConfig(frameSize)
nbBands := mode.EffBands  // This is already correct
```

3. Verify bit allocation uses LM correctly:
```go
allocResult := ComputeAllocation(..., lm, ...)  // lm=0 for 2.5ms, lm=1 for 5ms
```

4. Add bounds checking in DecodeBands to handle reduced band count:
- For 2.5ms: only bands 0-12 have non-zero width
- For 5ms: only bands 0-16 have non-zero width

Verify ScaledBandWidth returns correct values:
```go
// For 2.5ms (120 samples), scale = 1
// Band 12: width = EBands[13] - EBands[12] = 16 - 14 = 2 bins
// Band 13+: would have width 0 at this scale (but EffBands=13, so not accessed)
```

No code changes likely needed if mode configs are correct, but verify the path works.
  </action>
  <verify>
Create a test that verifies mode config values:
```go
func TestModeConfigShortFrames(t *testing.T) {
    cfg120 := GetModeConfig(120)
    if cfg120.EffBands != 13 || cfg120.LM != 0 {
        t.Errorf("120 samples: got EffBands=%d LM=%d, want 13, 0", cfg120.EffBands, cfg120.LM)
    }

    cfg240 := GetModeConfig(240)
    if cfg240.EffBands != 17 || cfg240.LM != 1 {
        t.Errorf("240 samples: got EffBands=%d LM=%d, want 17, 1", cfg240.EffBands, cfg240.LM)
    }
}
```
  </verify>
  <done>Mode configuration verified for 2.5ms and 5ms frames, band handling is correct.</done>
</task>

<task type="auto">
  <name>Task 2: Fix overlap-add for correct sample output</name>
  <files>internal/celt/synthesis.go</files>
  <action>
The OverlapAdd function may have incorrect output size. Fix it to produce frameSize samples:

Current issue: OverlapAdd returns n - overlap samples where n = len(current) = 2*frameSize.
For 20ms: returns 1920 - 120 = 1800 samples instead of 960.

Correct behavior per MDCT/IMDCT theory:
- IMDCT of N coefficients produces 2N windowed samples
- After overlap-add with N/8 overlap on each side, output is N samples
- The overlap combines current frame start with previous frame end

Fix OverlapAdd:
```go
func OverlapAdd(current, prevOverlap []float64, overlap int) (output, newOverlap []float64) {
    n := len(current)  // 2*frameSize samples from IMDCT
    if n <= 2*overlap {
        // Edge case: frame too short for overlap
        // ...existing handling...
    }

    // Output is frameSize = n/2 samples
    frameSize := n / 2
    output = make([]float64, frameSize)

    // First 'overlap' samples: sum with previous frame's saved tail
    for i := 0; i < overlap && i < len(prevOverlap); i++ {
        output[i] = prevOverlap[i] + current[i]
    }

    // Middle samples: direct copy from current[overlap : frameSize]
    copy(output[overlap:], current[overlap:frameSize])

    // Save new overlap: current[frameSize : frameSize+overlap]
    newOverlap = make([]float64, overlap)
    copy(newOverlap, current[frameSize:frameSize+overlap])

    return output, newOverlap
}
```

Also fix OverlapAddInPlace with same logic.

Update Synthesize and SynthesizeStereo to expect frameSize output.
  </action>
  <verify>
Run test:
```go
func TestOverlapAdd_OutputSize(t *testing.T) {
    testCases := []int{120, 240, 480, 960}
    overlap := 120

    for _, frameSize := range testCases {
        imdctOut := make([]float64, 2*frameSize)
        prevOverlap := make([]float64, overlap)

        output, newOverlap := OverlapAdd(imdctOut, prevOverlap, overlap)

        if len(output) != frameSize {
            t.Errorf("frameSize %d: got output %d, want %d", frameSize, len(output), frameSize)
        }
        if len(newOverlap) != overlap {
            t.Errorf("frameSize %d: got newOverlap %d, want %d", frameSize, len(newOverlap), overlap)
        }
    }
}
```
  </verify>
  <done>OverlapAdd produces exactly frameSize output samples for all frame sizes.</done>
</task>

<task type="auto">
  <name>Task 3: Add short frame decode tests</name>
  <files>internal/celt/decoder_test.go</files>
  <action>
Add tests that verify CELT can decode short frame sizes:

```go
func TestDecodeFrame_ShortFrames(t *testing.T) {
    // Test 2.5ms and 5ms frames
    testCases := []struct {
        name      string
        frameSize int
        wantLen   int  // Expected output sample count
    }{
        {"2.5ms_mono", 120, 120},
        {"5ms_mono", 240, 240},
        {"10ms_mono", 480, 480},
        {"20ms_mono", 960, 960},
    }

    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            d := NewDecoder(1)

            // Create a minimal valid CELT frame
            // Silence frame is simplest: first bit = 1
            silenceFrame := []byte{0x80}  // Silence flag set

            samples, err := d.DecodeFrame(silenceFrame, tc.frameSize)
            if err != nil {
                t.Fatalf("DecodeFrame failed: %v", err)
            }

            // After first frame, we get frameSize samples
            // (overlap buffer was empty/zero, so full output)
            if len(samples) != tc.wantLen {
                t.Errorf("got %d samples, want %d", len(samples), tc.wantLen)
            }
        })
    }
}

func TestDecodeFrame_ShortFrameStereo(t *testing.T) {
    testCases := []struct {
        frameSize int
        wantLen   int  // samples per channel * 2 (interleaved)
    }{
        {120, 240},   // 2.5ms stereo: 120*2
        {240, 480},   // 5ms stereo: 240*2
    }

    for _, tc := range testCases {
        t.Run(fmt.Sprintf("%d_stereo", tc.frameSize), func(t *testing.T) {
            d := NewDecoder(2)
            silenceFrame := []byte{0x80}

            samples, err := d.DecodeFrame(silenceFrame, tc.frameSize)
            if err != nil {
                t.Fatalf("DecodeFrame failed: %v", err)
            }

            if len(samples) != tc.wantLen {
                t.Errorf("got %d samples, want %d", len(samples), tc.wantLen)
            }
        })
    }
}
```
  </action>
  <verify>
Run `go test ./internal/celt -run TestDecodeFrame_ShortFrames -v`
Run `go test ./internal/celt -run TestDecodeFrame_ShortFrameStereo -v`
All tests must pass with correct sample counts.
  </verify>
  <done>Short frame decoding tests pass for 2.5ms, 5ms, 10ms, and 20ms mono and stereo.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` succeeds
2. `go test ./internal/celt -v` passes all tests
3. DecodeFrame produces correct sample counts for 120, 240, 480, 960
4. Mode configs correctly limit EffBands for short frames
</verification>

<success_criteria>
- CELT 2.5ms (120 samples) frames decode to 120 samples
- CELT 5ms (240 samples) frames decode to 240 samples
- OverlapAdd produces frameSize output for all sizes
- Mode configuration uses correct EffBands per frame size
</success_criteria>

<output>
After completion, create `.planning/phases/14-extended-frame-size/14-02-SUMMARY.md`
</output>
