---
phase: 14-extended-frame-size
plan: 04
type: execute
wave: 3
depends_on: ["14-02", "14-03"]
files_modified:
  - internal/testvectors/compliance_test.go
  - internal/testvectors/quality.go
  - internal/testvectors/parser.go
autonomous: true

must_haves:
  truths:
    - "RFC 8251 test vectors can be downloaded and parsed"
    - "All 12 test vectors are processed without decoder panic"
    - "Quality metric Q is computed for each test vector"
    - "Test output shows frame sizes encountered (2.5/5/10/20/40/60ms)"
  artifacts:
    - path: "internal/testvectors/compliance_test.go"
      provides: "RFC 8251 compliance validation"
      exports: ["TestDecoderCompliance"]
    - path: "internal/testvectors/quality.go"
      provides: "Quality metric computation"
      exports: ["ComputeQuality", "QualityPasses"]
  key_links:
    - from: "internal/testvectors/compliance_test.go"
      to: "gopus.Decoder"
      via: "dec.DecodeInt16"
      pattern: "DecodeInt16"
---

<objective>
Run RFC 8251 test vectors and validate extended frame size support

Purpose: The ultimate validation of Phase 14 is passing the official RFC 8251 test vectors. This plan runs all 12 vectors through the decoder after the frame size fixes and reports quality metrics.

Output: Test report showing Q metrics for each vector, with pass/fail status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-extended-frame-size/14-RESEARCH.md
@.planning/phases/14-extended-frame-size/14-01-SUMMARY.md
@.planning/phases/14-extended-frame-size/14-02-SUMMARY.md
@.planning/phases/14-extended-frame-size/14-03-SUMMARY.md

@internal/testvectors/compliance_test.go
@internal/testvectors/parser.go
@internal/testvectors/quality.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance compliance test with frame size logging</name>
  <files>internal/testvectors/compliance_test.go</files>
  <action>
Add frame size tracking to runTestVector to understand which frame sizes each test vector uses:

```go
func runTestVector(t *testing.T, name string) {
    // ... existing code to parse .bit file ...

    // Track frame sizes encountered
    frameSizeCounts := make(map[int]int)

    t.Logf("Test vector %s: %d packets", name, len(packets))

    // 2. Determine decoder parameters from first packet TOC
    toc := packets[0].Data[0]
    config := toc >> 3
    stereo := (toc & 0x04) != 0
    channels := 1
    if stereo {
        channels = 2
    }
    frameSize := getFrameSizeFromConfig(config)
    frameSizeCounts[frameSize]++

    // Log all unique frame sizes in the stream
    for i, pkt := range packets {
        if len(pkt.Data) > 0 {
            tocByte := pkt.Data[0]
            cfg := tocByte >> 3
            fs := getFrameSizeFromConfig(cfg)
            frameSizeCounts[fs]++

            if i == 0 {
                t.Logf("  Config: %d, Stereo: %v, FrameSize: %d samples (%.1fms)",
                    cfg, stereo, fs, float64(fs)/48.0)
            }
        }
    }

    // Report frame size distribution
    t.Logf("  Frame sizes encountered:")
    for fs, count := range frameSizeCounts {
        t.Logf("    %d samples (%.1fms): %d packets", fs, float64(fs)/48.0, count)
    }

    // ... rest of existing decode and quality computation ...
}
```

This helps identify which test vectors exercise 2.5ms, 5ms, 40ms, and 60ms frames.
  </action>
  <verify>
Run `go test ./internal/testvectors -run TestDecoderCompliance -v -timeout 5m 2>&1 | head -100`
Should show frame size distribution for each test vector.
  </verify>
  <done>Compliance test logs frame sizes, helping identify extended frame size usage.</done>
</task>

<task type="auto">
  <name>Task 2: Run full compliance test suite</name>
  <files>internal/testvectors/compliance_test.go</files>
  <action>
Run the full compliance test and analyze results:

1. Download test vectors if not present (test does this automatically)
2. Run all 12 vectors
3. Record Q metric for each
4. Identify any remaining failures

If Q < 0 for any vector:
- Check if it's a frame size issue (look at logged frame sizes)
- Check for decode errors in the log
- Note the failure for debugging

The goal is to pass with Q >= 0 for all vectors. Even if we don't achieve this immediately, we want to document progress and remaining issues.

Add error handling improvements:
```go
// In runTestVector, improve error handling during decode
for i, pkt := range packets {
    pcm := make([]int16, frameSize*channels)
    n, err := dec.DecodeInt16(pkt.Data, pcm)
    if err != nil {
        // Log more detail about the failure
        tocByte := pkt.Data[0]
        cfg := tocByte >> 3
        fs := getFrameSizeFromConfig(cfg)
        t.Logf("  Packet %d decode error: %v (config=%d, frameSize=%d)",
            i, err, cfg, fs)
        // Continue with zeros
        allDecoded = append(allDecoded, pcm[:frameSize*channels]...)
        continue
    }
    // ...
}
```
  </action>
  <verify>
Run `go test ./internal/testvectors -run TestDecoderCompliance -v -timeout 10m`
Record pass/fail status for each of the 12 test vectors.
  </verify>
  <done>Compliance test suite runs, Q metrics computed for all vectors.</done>
</task>

<task type="auto">
  <name>Task 3: Document compliance status</name>
  <files>internal/testvectors/compliance_test.go</files>
  <action>
Add a summary test that reports overall compliance status:

```go
// TestComplianceSummary runs all vectors and prints a summary table.
func TestComplianceSummary(t *testing.T) {
    if err := ensureTestVectors(t); err != nil {
        t.Skipf("Skipping: %v", err)
        return
    }

    type result struct {
        name       string
        packets    int
        frameSizes []int  // unique frame sizes
        q1         float64
        q2         float64
        passed     bool
        err        error
    }

    var results []result

    for _, name := range testVectorNames {
        r := runVectorSilent(t, name)
        results = append(results, r)
    }

    // Print summary table
    t.Log("\n=== RFC 8251 Compliance Summary ===")
    t.Log("Vector         | Packets | Frame Sizes      | Q(.dec) | Q(m.dec) | Status")
    t.Log("---------------|---------|------------------|---------|----------|-------")

    passed := 0
    for _, r := range results {
        status := "FAIL"
        if r.passed {
            status = "PASS"
            passed++
        }
        fsStr := formatFrameSizes(r.frameSizes)
        t.Logf("%-14s | %7d | %-16s | %7.2f | %8.2f | %s",
            r.name, r.packets, fsStr, r.q1, r.q2, status)
    }

    t.Logf("\nOverall: %d/%d passed", passed, len(results))

    if passed < len(results) {
        t.Logf("\nNote: Q >= 0 required for compliance per RFC 8251")
    }
}

func formatFrameSizes(sizes []int) string {
    if len(sizes) == 0 {
        return "-"
    }
    // Convert to ms and format
    var ms []string
    for _, s := range sizes {
        ms = append(ms, fmt.Sprintf("%.1f", float64(s)/48.0))
    }
    return strings.Join(ms, ",") + "ms"
}

func runVectorSilent(t *testing.T, name string) result {
    // Similar to runTestVector but returns structured result
    // ... implementation ...
}
```

This provides a clear summary of compliance status after Phase 14 work.
  </action>
  <verify>
Run `go test ./internal/testvectors -run TestComplianceSummary -v -timeout 10m`
Should print a summary table showing pass/fail for all 12 vectors.
  </verify>
  <done>Compliance summary shows status of all 12 RFC 8251 test vectors.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Test vectors download successfully
2. All 12 vectors process without panic
3. Quality metrics computed for all vectors
4. Summary shows pass/fail status
5. Frame size distribution logged per vector
</verification>

<success_criteria>
- TestDecoderCompliance runs all 12 vectors
- No panics during decode
- Q metric computed and logged for each vector
- Frame sizes (including 2.5/5/40/60ms) identified in vectors
- Summary table shows compliance progress
</success_criteria>

<output>
After completion, create `.planning/phases/14-extended-frame-size/14-04-SUMMARY.md`
</output>
