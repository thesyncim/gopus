---
phase: 14-extended-frame-size
plan: 04
type: execute
wave: 3
depends_on: ["14-02", "14-03"]
files_modified:
  - internal/testvectors/compliance_test.go
  - internal/testvectors/quality.go
  - internal/testvectors/parser.go
autonomous: true

must_haves:
  truths:
    - "RFC 8251 test vectors can be downloaded and parsed"
    - "All 12 test vectors are processed without decoder panic"
    - "Quality metric Q is computed for each test vector"
    - "Test output shows frame sizes encountered (2.5/5/10/20/40/60ms)"
    - "Test output shows mode (SILK/CELT/Hybrid) for each frame size"
  artifacts:
    - path: "internal/testvectors/compliance_test.go"
      provides: "RFC 8251 compliance validation"
      exports: ["TestDecoderCompliance"]
    - path: "internal/testvectors/quality.go"
      provides: "Quality metric computation"
      exports: ["ComputeQuality", "QualityPasses"]
  key_links:
    - from: "internal/testvectors/compliance_test.go"
      to: "gopus.Decoder"
      via: "dec.DecodeInt16"
      pattern: "DecodeInt16"
---

<objective>
Run RFC 8251 test vectors and validate extended frame size support

Purpose: The ultimate validation of Phase 14 is passing the official RFC 8251 test vectors. This plan runs all 12 vectors through the decoder after the frame size fixes and reports quality metrics.

Output: Test report showing Q metrics for each vector, with pass/fail status.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-extended-frame-size/14-RESEARCH.md
@.planning/phases/14-extended-frame-size/14-01-SUMMARY.md
@.planning/phases/14-extended-frame-size/14-02-SUMMARY.md
@.planning/phases/14-extended-frame-size/14-03-SUMMARY.md

@internal/testvectors/compliance_test.go
@internal/testvectors/parser.go
@internal/testvectors/quality.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance compliance test with frame size and mode logging</name>
  <files>internal/testvectors/compliance_test.go</files>
  <action>
Add frame size and mode tracking to runTestVector. This verifies the research assumption that extended frame sizes (2.5/5/40/60ms) only appear in SILK-only or CELT-only modes, not Hybrid.

```go
func runTestVector(t *testing.T, name string) {
    // ... existing code to parse .bit file ...

    // Track frame sizes and modes encountered
    type frameSizeMode struct {
        frameSize int
        mode      string  // "SILK", "CELT", or "Hybrid"
    }
    frameSizeModes := make(map[frameSizeMode]int)

    t.Logf("Test vector %s: %d packets", name, len(packets))

    // Parse each packet's TOC to extract mode and frame size
    for i, pkt := range packets {
        if len(pkt.Data) > 0 {
            tocByte := pkt.Data[0]
            cfg := tocByte >> 3
            fs := getFrameSizeFromConfig(cfg)
            mode := getModeFromConfig(cfg)  // "SILK", "CELT", or "Hybrid"

            key := frameSizeMode{frameSize: fs, mode: mode}
            frameSizeModes[key]++

            if i == 0 {
                stereo := (tocByte & 0x04) != 0
                t.Logf("  First packet: Config=%d, Mode=%s, Stereo=%v, FrameSize=%d (%.1fms)",
                    cfg, mode, stereo, fs, float64(fs)/48.0)
            }
        }
    }

    // Report frame size and mode distribution
    t.Logf("  Frame sizes by mode:")
    for fsm, count := range frameSizeModes {
        t.Logf("    %s %d samples (%.1fms): %d packets",
            fsm.mode, fsm.frameSize, float64(fsm.frameSize)/48.0, count)

        // Flag if extended frame size appears in Hybrid mode (unexpected per RFC)
        isExtended := fsm.frameSize == 120 || fsm.frameSize == 240 || // 2.5/5ms
                      fsm.frameSize == 1920 || fsm.frameSize == 2880   // 40/60ms
        if isExtended && fsm.mode == "Hybrid" {
            t.Logf("    WARNING: Extended frame size %d in Hybrid mode (unexpected per RFC 6716)",
                fsm.frameSize)
        }
    }

    // ... rest of existing decode and quality computation ...
}

// getModeFromConfig returns the mode name from TOC config field
func getModeFromConfig(config uint8) string {
    // RFC 6716 Section 3.1:
    // config 0-3: SILK-only (NB)
    // config 4-7: SILK-only (MB)
    // config 8-11: SILK-only (WB)
    // config 12-13: Hybrid (SWB)
    // config 14-15: Hybrid (FB)
    // config 16-19: CELT-only (NB)
    // config 20-23: CELT-only (WB)
    // config 24-27: CELT-only (SWB)
    // config 28-31: CELT-only (FB)
    switch {
    case config <= 11:
        return "SILK"
    case config <= 15:
        return "Hybrid"
    default:
        return "CELT"
    }
}
```

This helps identify which test vectors exercise 2.5ms, 5ms, 40ms, and 60ms frames, and confirms that extended sizes don't appear in Hybrid mode.
  </action>
  <verify>
Run `go test ./internal/testvectors -run TestDecoderCompliance -v -timeout 5m 2>&1 | head -100`
Should show frame size and mode distribution for each test vector.
  </verify>
  <done>Compliance test logs frame sizes with mode, verifying extended sizes only appear in SILK/CELT modes.</done>
</task>

<task type="auto">
  <name>Task 2: Run full compliance test suite</name>
  <files>internal/testvectors/compliance_test.go</files>
  <action>
Run the full compliance test and analyze results:

1. Download test vectors if not present (test does this automatically)
2. Run all 12 vectors
3. Record Q metric for each
4. Identify any remaining failures

If Q < 0 for any vector:
- Check if it's a frame size issue (look at logged frame sizes)
- Check for decode errors in the log
- Note the failure for debugging

The goal is to pass with Q >= 0 for all vectors. Even if we don't achieve this immediately, we want to document progress and remaining issues.

Add error handling improvements:
```go
// In runTestVector, improve error handling during decode
for i, pkt := range packets {
    pcm := make([]int16, frameSize*channels)
    n, err := dec.DecodeInt16(pkt.Data, pcm)
    if err != nil {
        // Log more detail about the failure
        tocByte := pkt.Data[0]
        cfg := tocByte >> 3
        fs := getFrameSizeFromConfig(cfg)
        mode := getModeFromConfig(cfg)
        t.Logf("  Packet %d decode error: %v (config=%d, mode=%s, frameSize=%d)",
            i, err, cfg, mode, fs)
        // Continue with zeros
        allDecoded = append(allDecoded, pcm[:frameSize*channels]...)
        continue
    }
    // ...
}
```
  </action>
  <verify>
Run `go test ./internal/testvectors -run TestDecoderCompliance -v -timeout 10m`
Record pass/fail status for each of the 12 test vectors.
  </verify>
  <done>Compliance test suite runs, Q metrics computed for all vectors.</done>
</task>

<task type="auto">
  <name>Task 3: Document compliance status with mode verification</name>
  <files>internal/testvectors/compliance_test.go</files>
  <action>
Add a summary test that reports overall compliance status and verifies the hybrid mode assumption:

```go
// TestComplianceSummary runs all vectors and prints a summary table.
func TestComplianceSummary(t *testing.T) {
    if err := ensureTestVectors(t); err != nil {
        t.Skipf("Skipping: %v", err)
        return
    }

    type result struct {
        name           string
        packets        int
        frameSizes     []int    // unique frame sizes
        modes          []string // unique modes
        hasExtendedHybrid bool  // true if extended frame size in Hybrid mode
        q1             float64
        q2             float64
        passed         bool
        err            error
    }

    var results []result

    for _, name := range testVectorNames {
        r := runVectorSilent(t, name)
        results = append(results, r)
    }

    // Print summary table
    t.Log("\n=== RFC 8251 Compliance Summary ===")
    t.Log("Vector         | Packets | Modes       | Frame Sizes      | Q(.dec) | Q(m.dec) | Status")
    t.Log("---------------|---------|-------------|------------------|---------|----------|-------")

    passed := 0
    hybridExtendedCount := 0
    for _, r := range results {
        status := "FAIL"
        if r.passed {
            status = "PASS"
            passed++
        }
        fsStr := formatFrameSizes(r.frameSizes)
        modesStr := strings.Join(r.modes, ",")
        t.Logf("%-14s | %7d | %-11s | %-16s | %7.2f | %8.2f | %s",
            r.name, r.packets, modesStr, fsStr, r.q1, r.q2, status)
        if r.hasExtendedHybrid {
            hybridExtendedCount++
        }
    }

    t.Logf("\nOverall: %d/%d passed", passed, len(results))

    // Report on hybrid mode verification
    if hybridExtendedCount == 0 {
        t.Log("\nHybrid mode verification: CONFIRMED - no extended frame sizes in Hybrid mode")
    } else {
        t.Logf("\nHybrid mode verification: UNEXPECTED - %d vectors have extended frame sizes in Hybrid mode", hybridExtendedCount)
    }

    if passed < len(results) {
        t.Logf("\nNote: Q >= 0 required for compliance per RFC 8251")
    }
}

func formatFrameSizes(sizes []int) string {
    if len(sizes) == 0 {
        return "-"
    }
    // Convert to ms and format
    var ms []string
    for _, s := range sizes {
        ms = append(ms, fmt.Sprintf("%.1f", float64(s)/48.0))
    }
    return strings.Join(ms, ",") + "ms"
}

func runVectorSilent(t *testing.T, name string) result {
    // Similar to runTestVector but returns structured result
    // Track hasExtendedHybrid flag
    // ... implementation ...
}
```

This provides a clear summary of compliance status and confirms the hybrid mode assumption from the research document.
  </action>
  <verify>
Run `go test ./internal/testvectors -run TestComplianceSummary -v -timeout 10m`
Should print a summary table showing pass/fail for all 12 vectors plus hybrid mode verification.
  </verify>
  <done>Compliance summary shows status of all 12 RFC 8251 test vectors and confirms hybrid mode assumption.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Test vectors download successfully
2. All 12 vectors process without panic
3. Quality metrics computed for all vectors
4. Summary shows pass/fail status
5. Frame size distribution logged per vector with mode
6. Hybrid mode verification confirms extended sizes don't appear in Hybrid mode
</verification>

<success_criteria>
- TestDecoderCompliance runs all 12 vectors
- No panics during decode
- Q metric computed and logged for each vector
- Frame sizes (including 2.5/5/40/60ms) identified in vectors with their modes
- Summary table shows compliance progress
- Hybrid mode assumption verified (extended sizes only in SILK/CELT modes)
</success_criteria>

<output>
After completion, create `.planning/phases/14-extended-frame-size/14-04-SUMMARY.md`
</output>
