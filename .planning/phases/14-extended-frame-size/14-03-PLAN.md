---
phase: 14-extended-frame-size
plan: 03
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - internal/silk/decode.go
  - internal/silk/decode_test.go
autonomous: true

must_haves:
  truths:
    - "SILK 40ms frames decode as 2 consecutive 20ms sub-blocks"
    - "SILK 60ms frames decode as 3 consecutive 20ms sub-blocks"
    - "Sub-block state (LPC, gain, pitch) transfers correctly between sub-blocks"
    - "Output sample count matches frame duration at native SILK rate"
  artifacts:
    - path: "internal/silk/decode.go"
      provides: "40/60ms sub-block decoding"
      contains: "decode20msBlock"
    - path: "internal/silk/decode_test.go"
      provides: "Extended frame duration tests"
      exports: ["TestDecodeFrame_40ms", "TestDecodeFrame_60ms"]
  key_links:
    - from: "internal/silk/decode.go"
      to: "internal/silk/frame.go"
      via: "is40or60ms and getSubBlockCount"
      pattern: "getSubBlockCount"
---

<objective>
Verify SILK 40ms and 60ms frame decoding

Purpose: RFC 8251 test vectors include SILK long frames. The code path exists (is40or60ms, getSubBlockCount, decode20msBlock) but needs verification that it works correctly for multi-sub-block decoding.

Output: SILK decoder handles 40ms (8 subframes) and 60ms (12 subframes) frames with correct sample counts and state transfer.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-extended-frame-size/14-RESEARCH.md

@internal/silk/frame.go
@internal/silk/decode.go
@internal/silk/decoder.go
@internal/silk/bandwidth.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify SILK 40ms/60ms decode path</name>
  <files>internal/silk/decode.go</files>
  <action>
Trace through the existing 40ms/60ms decode path and verify correctness:

1. In DecodeFrame, verify the is40or60ms branch:
```go
if is40or60ms(duration) {
    subBlocks := getSubBlockCount(duration)  // 2 for 40ms, 3 for 60ms
    subBlockSamples := 4 * samplesPerSubframe  // 20ms = 4 subframes

    for block := 0; block < subBlocks; block++ {
        blockOutput := output[block*subBlockSamples : (block+1)*subBlockSamples]
        err := d.decode20msBlock(bandwidth, vadFlag, blockOutput)
        // ...
    }
}
```

2. Verify getSubframeCount returns correct values:
   - Frame40ms (40): 8 subframes
   - Frame60ms (60): 12 subframes

3. Verify getSubBlockCount:
   - Frame40ms: 2 sub-blocks
   - Frame60ms: 3 sub-blocks

4. Verify output slice sizing:
   - 40ms WB (16kHz): 40ms * 16000 / 1000 = 640 samples
   - 60ms WB (16kHz): 60ms * 16000 / 1000 = 960 samples

5. Confirm decoder state (lpcQ12, gains, pitchLags) persists across sub-blocks.
   The key is that decode20msBlock uses d.* fields that accumulate state.

If any issues found, fix them. Otherwise document that the path is correct.
  </action>
  <verify>
Add diagnostic test:
```go
func TestDecodeFrame_LongFrameSubBlocks(t *testing.T) {
    // Verify sub-block count calculations
    if getSubBlockCount(Frame40ms) != 2 {
        t.Errorf("40ms: got %d sub-blocks, want 2", getSubBlockCount(Frame40ms))
    }
    if getSubBlockCount(Frame60ms) != 3 {
        t.Errorf("60ms: got %d sub-blocks, want 3", getSubBlockCount(Frame60ms))
    }

    // Verify subframe counts
    if getSubframeCount(Frame40ms) != 8 {
        t.Errorf("40ms: got %d subframes, want 8", getSubframeCount(Frame40ms))
    }
    if getSubframeCount(Frame60ms) != 12 {
        t.Errorf("60ms: got %d subframes, want 12", getSubframeCount(Frame60ms))
    }
}
```
  </verify>
  <done>SILK 40ms/60ms decode path verified, sub-block count and subframe count correct.</done>
</task>

<task type="auto">
  <name>Task 2: Add SILK long frame decode tests</name>
  <files>internal/silk/decode_test.go</files>
  <action>
Add tests for 40ms and 60ms frame decoding:

```go
func TestDecodeFrame_40ms(t *testing.T) {
    testCases := []struct {
        bandwidth   Bandwidth
        wantSamples int  // at native SILK rate
    }{
        {BandwidthNarrowband, 320},  // 40ms * 8000 / 1000
        {BandwidthMediumband, 480},  // 40ms * 12000 / 1000
        {BandwidthWideband, 640},    // 40ms * 16000 / 1000
    }

    for _, tc := range testCases {
        t.Run(tc.bandwidth.String(), func(t *testing.T) {
            d := NewDecoder()

            // Create a mock range decoder with minimal valid data
            // For silence/simple frame
            rd := createMockRangeDecoder()

            samples, err := d.DecodeFrame(rd, tc.bandwidth, Frame40ms, true)
            if err != nil {
                // May fail due to range decoder exhaustion, which is expected
                // for mock data. Just verify the function accepts 40ms.
                t.Logf("Expected decode error with mock data: %v", err)
                return
            }

            if len(samples) != tc.wantSamples {
                t.Errorf("got %d samples, want %d", len(samples), tc.wantSamples)
            }
        })
    }
}

func TestDecodeFrame_60ms(t *testing.T) {
    testCases := []struct {
        bandwidth   Bandwidth
        wantSamples int
    }{
        {BandwidthNarrowband, 480},  // 60ms * 8000 / 1000
        {BandwidthMediumband, 720},  // 60ms * 12000 / 1000
        {BandwidthWideband, 960},    // 60ms * 16000 / 1000
    }

    for _, tc := range testCases {
        t.Run(tc.bandwidth.String(), func(t *testing.T) {
            d := NewDecoder()
            rd := createMockRangeDecoder()

            samples, err := d.DecodeFrame(rd, tc.bandwidth, Frame60ms, true)
            if err != nil {
                t.Logf("Expected decode error with mock data: %v", err)
                return
            }

            if len(samples) != tc.wantSamples {
                t.Errorf("got %d samples, want %d", len(samples), tc.wantSamples)
            }
        })
    }
}

// Helper to create a range decoder with minimal data
func createMockRangeDecoder() *rangecoding.Decoder {
    // Create decoder with some valid-ish entropy coded data
    // This may not produce valid SILK but exercises the code path
    data := make([]byte, 100)
    // Initialize with some pattern
    for i := range data {
        data[i] = byte(i * 7)
    }
    rd := &rangecoding.Decoder{}
    rd.Init(data)
    return rd
}
```

If the tests fail due to range decoder issues (not enough valid data), that's acceptable for now. The important thing is verifying:
1. The function accepts 40ms/60ms duration
2. Output slice is allocated with correct size
3. Sub-block loop iterates correct number of times
  </action>
  <verify>
Run `go test ./internal/silk -run TestDecodeFrame_40ms -v`
Run `go test ./internal/silk -run TestDecodeFrame_60ms -v`
Tests should run (may have expected errors from mock data, but should not panic).
  </verify>
  <done>SILK 40ms and 60ms decode tests added, verifying code path accepts long frames.</done>
</task>

<task type="auto">
  <name>Task 3: Verify stereo 40ms/60ms decoding</name>
  <files>internal/silk/decode.go, internal/silk/decode_test.go</files>
  <action>
Verify DecodeStereoFrame handles 40ms/60ms:

1. Check decodeChannel uses same is40or60ms logic:
```go
func (d *Decoder) decodeChannel(..., duration FrameDuration, ...) error {
    if is40or60ms(duration) {
        subBlocks := getSubBlockCount(duration)
        // ...
    }
}
```

2. Add stereo long frame test:
```go
func TestDecodeStereoFrame_LongFrames(t *testing.T) {
    testCases := []struct {
        duration    FrameDuration
        wantSamples int  // per channel at WB
    }{
        {Frame40ms, 640},
        {Frame60ms, 960},
    }

    for _, tc := range testCases {
        t.Run(fmt.Sprintf("%dms", tc.duration), func(t *testing.T) {
            d := NewDecoder()
            rd := createMockRangeDecoder()

            left, right, err := d.DecodeStereoFrame(rd, BandwidthWideband, tc.duration, true)
            if err != nil {
                t.Logf("Expected decode error with mock data: %v", err)
                return
            }

            if len(left) != tc.wantSamples {
                t.Errorf("left: got %d samples, want %d", len(left), tc.wantSamples)
            }
            if len(right) != tc.wantSamples {
                t.Errorf("right: got %d samples, want %d", len(right), tc.wantSamples)
            }
        })
    }
}
```
  </action>
  <verify>
Run `go test ./internal/silk -run TestDecodeStereoFrame_LongFrames -v`
Test should run without panic.
  </verify>
  <done>SILK stereo 40ms/60ms decode path verified.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` succeeds
2. `go test ./internal/silk -v` passes
3. 40ms frames allocate 8 subframes worth of output
4. 60ms frames allocate 12 subframes worth of output
5. Stereo long frames work for both channels
</verification>

<success_criteria>
- getSubBlockCount returns 2 for 40ms, 3 for 60ms
- getSubframeCount returns 8 for 40ms, 12 for 60ms
- DecodeFrame accepts 40ms and 60ms durations without panic
- Output slice sizing is correct for all bandwidths
</success_criteria>

<output>
After completion, create `.planning/phases/14-extended-frame-size/14-03-SUMMARY.md`
</output>
