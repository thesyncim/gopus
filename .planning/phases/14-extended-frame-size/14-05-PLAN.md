---
phase: 14-extended-frame-size
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - decoder.go
  - decoder_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "SILK-only packets route to SILK decoder, not hybrid decoder"
    - "CELT-only packets route to CELT decoder, not hybrid decoder"
    - "Hybrid packets route to hybrid decoder"
    - "CELT 2.5ms (120 samples) and 5ms (240 samples) frames decode successfully"
    - "SILK 40ms (1920 samples) and 60ms (2880 samples) frames decode successfully"
    - "RFC 8251 test vectors achieve Q >= 0 threshold"
  artifacts:
    - path: "decoder.go"
      provides: "Mode routing logic using TOC.Mode field"
      contains: "switch toc.Mode"
    - path: "decoder_test.go"
      provides: "Mode routing verification tests"
      contains: "TestDecode_ModeRouting"
  key_links:
    - from: "decoder.go"
      to: "internal/silk/silk.go"
      via: "d.silkDecoder.Decode()"
      pattern: "d\\.silkDecoder\\.Decode"
    - from: "decoder.go"
      to: "internal/celt/decoder.go"
      via: "d.celtDecoder.DecodeFrame()"
      pattern: "d\\.celtDecoder\\.DecodeFrame"
    - from: "decoder.go"
      to: "internal/hybrid/hybrid.go"
      via: "d.hybridDecoder.DecodeToFloat32()"
      pattern: "d\\.hybridDecoder\\.DecodeToFloat32"
---

<objective>
Implement mode routing in gopus.Decoder to route SILK-only, CELT-only, and Hybrid packets to their respective decoders.

Purpose: Fix the architectural blocker preventing RFC 8251 test vector compliance. Currently all packets are routed to hybrid.Decoder which rejects extended frame sizes (CELT 2.5/5ms, SILK 40/60ms) with "hybrid: invalid frame size" error.

Output: Decoder correctly routes packets based on TOC mode, enabling full RFC 8251 compliance.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-extended-frame-size/14-VERIFICATION.md

# Key files for understanding current architecture
@decoder.go
@packet.go
@internal/hybrid/hybrid.go
@internal/silk/silk.go
@internal/celt/decoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SILK and CELT decoders to Decoder struct and implement mode routing</name>
  <files>decoder.go</files>
  <action>
Modify the Decoder struct and Decode methods to route packets based on TOC mode.

1. **Update Decoder struct** to include all three decoders:

```go
type Decoder struct {
    silkDecoder   *silk.Decoder    // SILK-only mode decoder
    celtDecoder   *celt.Decoder    // CELT-only mode decoder
    hybridDecoder *hybrid.Decoder  // Hybrid mode decoder (existing field renamed)
    sampleRate    int
    channels      int
    lastFrameSize int
    lastMode      Mode             // Track last mode for PLC
}
```

Note: The existing `dec *hybrid.Decoder` field should be renamed to `hybridDecoder` for clarity.

2. **Update NewDecoder** to initialize all three decoders:

```go
func NewDecoder(sampleRate, channels int) (*Decoder, error) {
    // ... validation ...
    return &Decoder{
        silkDecoder:   silk.NewDecoder(),
        celtDecoder:   celt.NewDecoder(channels),
        hybridDecoder: hybrid.NewDecoder(channels),
        sampleRate:    sampleRate,
        channels:      channels,
        lastFrameSize: 960,
        lastMode:      ModeHybrid, // Default for PLC
    }, nil
}
```

3. **Update Decode method** with mode routing:

Replace the current single-path decoding with mode-based routing:

```go
func (d *Decoder) Decode(data []byte, pcm []float32) (int, error) {
    var toc TOC
    var frameSize int
    var mode Mode

    if data != nil && len(data) > 0 {
        toc = ParseTOC(data[0])
        frameSize = toc.FrameSize
        mode = toc.Mode
    } else {
        // PLC: use last frame parameters
        frameSize = d.lastFrameSize
        mode = d.lastMode
    }

    // Validate output buffer
    needed := frameSize * d.channels
    if len(pcm) < needed {
        return 0, ErrBufferTooSmall
    }

    var samples []float32
    var err error

    // Extract frame data (skip TOC byte) for normal decode
    var frameData []byte
    if data != nil && len(data) > 0 {
        frameData = data[1:]
    }

    // Route based on mode
    switch mode {
    case ModeSILK:
        samples, err = d.decodeSILK(frameData, toc, frameSize)
    case ModeCELT:
        samples, err = d.decodeCELT(frameData, frameSize)
    case ModeHybrid:
        samples, err = d.decodeHybrid(frameData, frameSize)
    default:
        return 0, ErrInvalidMode
    }

    if err != nil {
        return 0, err
    }

    copy(pcm, samples)
    d.lastFrameSize = frameSize
    d.lastMode = mode

    return frameSize, nil
}
```

4. **Add helper methods for each mode** (private):

```go
// decodeSILK routes to SILK decoder
func (d *Decoder) decodeSILK(data []byte, toc TOC, frameSize int) ([]float32, error) {
    // Map TOC bandwidth to SILK bandwidth
    silkBW, ok := silk.BandwidthFromOpus(int(toc.Bandwidth))
    if !ok {
        return nil, ErrInvalidBandwidth
    }

    if d.channels == 2 {
        return d.silkDecoder.DecodeStereo(data, silkBW, frameSize, true)
    }
    return d.silkDecoder.Decode(data, silkBW, frameSize, true)
}

// decodeCELT routes to CELT decoder
func (d *Decoder) decodeCELT(data []byte, frameSize int) ([]float32, error) {
    samples, err := d.celtDecoder.DecodeFrame(data, frameSize)
    if err != nil {
        return nil, err
    }
    // Convert float64 to float32
    result := make([]float32, len(samples))
    for i, s := range samples {
        result[i] = float32(s)
    }
    return result, nil
}

// decodeHybrid routes to Hybrid decoder (existing behavior)
func (d *Decoder) decodeHybrid(data []byte, frameSize int) ([]float32, error) {
    if d.channels == 2 {
        return d.hybridDecoder.DecodeStereoToFloat32(data, frameSize)
    }
    return d.hybridDecoder.DecodeToFloat32(data, frameSize)
}
```

5. **Add ErrInvalidMode and ErrInvalidBandwidth** to errors.go:

```go
var ErrInvalidMode = errors.New("opus: invalid mode in packet")
var ErrInvalidBandwidth = errors.New("opus: invalid bandwidth for mode")
```

6. **Update Reset method** to reset all decoders:

```go
func (d *Decoder) Reset() {
    d.silkDecoder.Reset()
    d.celtDecoder.Reset()
    d.hybridDecoder.Reset()
    d.lastFrameSize = 960
    d.lastMode = ModeHybrid
}
```

7. **Update DecodeInt16, DecodeFloat32, DecodeInt16Slice** to use the same routing (they call Decode internally, so should work automatically).

8. **Add import for silk package**:
```go
import (
    "gopus/internal/celt"
    "gopus/internal/hybrid"
    "gopus/internal/silk"
)
```

Important: The SILK decoder expects Bandwidth type from silk package, and ParseTOC returns Bandwidth from gopus package. Use silk.BandwidthFromOpus() to convert.
  </action>
  <verify>
    - `go build ./...` succeeds without errors
    - `go test ./... -run TestDecode -v` passes existing decode tests
  </verify>
  <done>
    - Decoder struct has silkDecoder, celtDecoder, hybridDecoder fields
    - Decode() method routes based on toc.Mode (switch statement visible)
    - All three decoder types initialized in NewDecoder
    - ErrInvalidMode and ErrInvalidBandwidth defined
  </done>
</task>

<task type="auto">
  <name>Task 2: Add mode routing tests and verify extended frame sizes</name>
  <files>decoder_test.go</files>
  <action>
Add tests that verify mode routing works correctly for all modes and frame sizes.

1. **Add TestDecode_ModeRouting** to verify routing logic:

```go
func TestDecode_ModeRouting(t *testing.T) {
    tests := []struct {
        name      string
        config    uint8   // TOC config (0-31)
        frameSize int     // Expected frame size at 48kHz
        mode      Mode    // Expected mode
    }{
        // SILK-only (configs 0-11)
        {"SILK NB 10ms", 0, 480, ModeSILK},
        {"SILK NB 20ms", 1, 960, ModeSILK},
        {"SILK NB 40ms", 2, 1920, ModeSILK},
        {"SILK NB 60ms", 3, 2880, ModeSILK},
        {"SILK MB 20ms", 5, 960, ModeSILK},
        {"SILK WB 20ms", 9, 960, ModeSILK},
        {"SILK WB 40ms", 10, 1920, ModeSILK},
        {"SILK WB 60ms", 11, 2880, ModeSILK},

        // Hybrid (configs 12-15)
        {"Hybrid SWB 10ms", 12, 480, ModeHybrid},
        {"Hybrid SWB 20ms", 13, 960, ModeHybrid},
        {"Hybrid FB 10ms", 14, 480, ModeHybrid},
        {"Hybrid FB 20ms", 15, 960, ModeHybrid},

        // CELT-only (configs 16-31)
        {"CELT NB 2.5ms", 16, 120, ModeCELT},
        {"CELT NB 5ms", 17, 240, ModeCELT},
        {"CELT NB 10ms", 18, 480, ModeCELT},
        {"CELT NB 20ms", 19, 960, ModeCELT},
        {"CELT FB 2.5ms", 28, 120, ModeCELT},
        {"CELT FB 5ms", 29, 240, ModeCELT},
        {"CELT FB 10ms", 30, 480, ModeCELT},
        {"CELT FB 20ms", 31, 960, ModeCELT},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Verify TOC parsing
            toc := ParseTOC(GenerateTOC(tt.config, false, 0))

            if toc.Mode != tt.mode {
                t.Errorf("Mode mismatch: got %v, want %v", toc.Mode, tt.mode)
            }
            if toc.FrameSize != tt.frameSize {
                t.Errorf("FrameSize mismatch: got %d, want %d", toc.FrameSize, tt.frameSize)
            }

            // Test decoder accepts the packet (may fail on decode but should not fail on routing)
            dec, err := NewDecoder(48000, 1)
            if err != nil {
                t.Fatalf("NewDecoder failed: %v", err)
            }

            // Create minimal valid packet (TOC + some data)
            packet := make([]byte, 100)
            packet[0] = GenerateTOC(tt.config, false, 0)
            // Fill with minimal valid data for range decoder
            for i := 1; i < len(packet); i++ {
                packet[i] = byte(i)
            }

            // Decode should not panic and should not return "hybrid: invalid frame size"
            pcm := make([]float32, tt.frameSize*2) // Extra buffer
            _, err = dec.Decode(packet, pcm)

            // For extended frame sizes, we expect decode to succeed (no routing error)
            // The decode may still fail for other reasons (invalid bitstream) but
            // should NOT fail with "hybrid: invalid frame size"
            if err != nil {
                errStr := err.Error()
                if strings.Contains(errStr, "hybrid: invalid frame size") {
                    t.Errorf("Mode routing failed: SILK/CELT packet incorrectly routed to hybrid decoder: %v", err)
                }
                // Log other errors but don't fail - bitstream content may be invalid
                t.Logf("Decode error (non-routing): %v", err)
            }
        })
    }
}
```

2. **Add TestDecode_ExtendedFrameSizes** for extended size verification:

```go
func TestDecode_ExtendedFrameSizes(t *testing.T) {
    // Test that extended frame sizes don't trigger hybrid validation error
    extendedConfigs := []struct {
        name      string
        config    uint8
        frameSize int
    }{
        {"CELT 2.5ms", 28, 120},  // CELT FB 2.5ms
        {"CELT 5ms", 29, 240},    // CELT FB 5ms
        {"SILK 40ms", 10, 1920},  // SILK WB 40ms
        {"SILK 60ms", 11, 2880},  // SILK WB 60ms
    }

    for _, tt := range extendedConfigs {
        t.Run(tt.name, func(t *testing.T) {
            dec, _ := NewDecoder(48000, 1)

            packet := make([]byte, 100)
            packet[0] = GenerateTOC(tt.config, false, 0)
            for i := 1; i < len(packet); i++ {
                packet[i] = byte(i * 7) // Different pattern
            }

            pcm := make([]float32, tt.frameSize*2)
            _, err := dec.Decode(packet, pcm)

            // Critical: should NOT fail with hybrid frame size error
            if err != nil && strings.Contains(err.Error(), "hybrid: invalid frame size") {
                t.Errorf("Extended frame size incorrectly rejected as hybrid: %v", err)
            }
        })
    }
}
```

3. **Add TestDecode_PLC_ModeTracking** for PLC mode continuity:

```go
func TestDecode_PLC_ModeTracking(t *testing.T) {
    dec, _ := NewDecoder(48000, 1)

    // First: decode a SILK packet to set mode
    silkPacket := make([]byte, 50)
    silkPacket[0] = GenerateTOC(9, false, 0) // SILK WB 20ms
    for i := 1; i < len(silkPacket); i++ {
        silkPacket[i] = byte(i)
    }

    pcm := make([]float32, 960*2)
    _, _ = dec.Decode(silkPacket, pcm)

    // PLC should use last mode (SILK)
    _, err := dec.Decode(nil, pcm)
    if err != nil && strings.Contains(err.Error(), "hybrid") {
        t.Errorf("PLC should use SILK mode, not hybrid: %v", err)
    }
}
```

4. **Add import for strings package** at the top of decoder_test.go:
```go
import "strings"
```
  </action>
  <verify>
    - `go test -v -run TestDecode_ModeRouting` passes
    - `go test -v -run TestDecode_ExtendedFrameSizes` passes (no hybrid frame size errors)
    - `go test -v -run TestDecode_PLC_ModeTracking` passes
    - `go test ./...` all tests pass
  </verify>
  <done>
    - TestDecode_ModeRouting verifies all 32 configs route to correct decoder
    - TestDecode_ExtendedFrameSizes verifies CELT 2.5/5ms and SILK 40/60ms accepted
    - TestDecode_PLC_ModeTracking verifies PLC uses last mode
    - No "hybrid: invalid frame size" errors for extended sizes
  </done>
</task>

<task type="auto">
  <name>Task 3: Run RFC 8251 compliance test and verify improvement</name>
  <files>internal/testvectors/compliance_test.go</files>
  <action>
Run the existing RFC 8251 compliance test to verify the mode routing fix improves test vector compliance.

1. **Run compliance test** and capture results:

```bash
cd /Users/thesyncim/GolandProjects/gopus
go test -v -run TestCompliance ./internal/testvectors/ 2>&1 | head -200
```

2. **Run summary test** for overview:

```bash
go test -v -run TestComplianceSummary ./internal/testvectors/ 2>&1
```

3. **Analyze results:**
   - Before fix: All 12 vectors fail with Q=-100.00 (hybrid: invalid frame size)
   - After fix: Vectors should decode without routing errors
   - Q metrics should be >= 0 for passing vectors

4. **If any vectors still fail**, check error messages:
   - "hybrid: invalid frame size" -> routing still broken
   - Other errors -> may be separate decoder issues

5. **Document results** in verification output for SUMMARY.md
  </action>
  <verify>
    - Compliance tests run without panic
    - No "hybrid: invalid frame size" errors in output
    - Q metrics computed for all test vectors (even if not all pass)
  </verify>
  <done>
    - RFC 8251 compliance test runs to completion
    - Extended frame size packets decode without routing errors
    - Results documented (Q values for each vector)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Mode Routing Check:**
```bash
go test -v -run "TestDecode_ModeRouting|TestDecode_ExtendedFrameSizes" ./...
```
Expected: All routing tests pass, no hybrid errors for SILK/CELT packets.

2. **Full Test Suite:**
```bash
go test ./...
```
Expected: All tests pass.

3. **RFC 8251 Compliance:**
```bash
go test -v -run TestComplianceSummary ./internal/testvectors/
```
Expected: Q metrics computed without routing errors.
</verification>

<success_criteria>
- Decoder struct has silkDecoder, celtDecoder, hybridDecoder fields
- Decode() routes based on TOC mode (ModeSILK -> silk, ModeCELT -> celt, ModeHybrid -> hybrid)
- CELT 2.5ms (120) and 5ms (240) frames decode without "hybrid: invalid frame size"
- SILK 40ms (1920) and 60ms (2880) frames decode without "hybrid: invalid frame size"
- All existing decoder tests pass
- Mode routing tests verify correct routing for all 32 TOC configs
- RFC 8251 compliance tests run without routing errors
</success_criteria>

<output>
After completion, create `.planning/phases/14-extended-frame-size/14-05-SUMMARY.md`
</output>
