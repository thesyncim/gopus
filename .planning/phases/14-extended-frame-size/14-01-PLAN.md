---
phase: 14-extended-frame-size
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/celt/bands.go
  - internal/celt/synthesis.go
  - internal/celt/bands_test.go
  - internal/celt/synthesis_test.go
autonomous: true

must_haves:
  truths:
    - "CELT MDCT operates on frameSize coefficients, not band coefficient sum"
    - "DecodeBands returns frameSize coefficients with upper bins zero-padded"
    - "IMDCT output count matches expected: 2*frameSize samples"
    - "Overlap-add produces exactly frameSize output samples"
  artifacts:
    - path: "internal/celt/bands.go"
      provides: "Zero-padded coefficient output to match frameSize"
      contains: "make([]float64, frameSize)"
    - path: "internal/celt/synthesis.go"
      provides: "IMDCT with correct frameSize input"
      contains: "frameSize"
    - path: "internal/celt/bands_test.go"
      provides: "Band coefficient count verification"
      exports: ["TestDecodeBands_OutputSize"]
    - path: "internal/celt/synthesis_test.go"
      provides: "Synthesis sample count verification"
      exports: ["TestSynthesize_SampleCount"]
  key_links:
    - from: "internal/celt/bands.go"
      to: "internal/celt/synthesis.go"
      via: "coefficient slice passed to Synthesize"
      pattern: "Synthesize.*coeffs"
---

<objective>
Fix CELT MDCT bin count mismatch causing incorrect sample output

Purpose: The known gap "MDCT bin count (800) doesn't match frame size (960)" causes the decoder to produce 1480 samples instead of 960 for 20ms frames. This is the root cause of RFC 8251 test vector failures.

Root cause: DecodeBands returns totalBins (sum of scaled band widths = 800 for 20ms fullband) but IMDCT expects frameSize (960) coefficients. IMDCT(800) produces 1600 samples, overlap-add subtracts 120, yielding 1480 instead of 960.

Fix: Pad band coefficients to frameSize before IMDCT. The upper bins (800-959) represent the highest frequencies which are typically zero in band-limited content.

Output: CELT decoder produces correct sample counts for all frame sizes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-extended-frame-size/14-RESEARCH.md

@internal/celt/bands.go
@internal/celt/synthesis.go
@internal/celt/mdct.go
@internal/celt/tables.go
@internal/celt/decoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix DecodeBands to return frameSize coefficients</name>
  <files>internal/celt/bands.go</files>
  <action>
Modify DecodeBands function to:

1. Accept frameSize as parameter (already does)
2. Create output slice of size `frameSize` instead of `totalBins`
3. Fill bands with decoded/folded coefficients as before
4. Leave upper bins (totalBins to frameSize-1) as zero

Key changes:
```go
func (d *Decoder) DecodeBands(..., frameSize int) []float64 {
    // Calculate total bins from bands (for band processing)
    totalBins := 0
    for band := 0; band < nbBands; band++ {
        totalBins += ScaledBandWidth(band, frameSize)
    }

    // But allocate frameSize for MDCT
    // Upper bins (totalBins to frameSize-1) stay zero
    coeffs := make([]float64, frameSize)
    // ... rest of band decoding fills coeffs[0:totalBins]
}
```

Apply same fix to DecodeBandsStereo - both left and right should be frameSize length.

This ensures IMDCT receives exactly frameSize coefficients, producing 2*frameSize samples, which after overlap-add yields frameSize output.
  </action>
  <verify>
Run `go build ./internal/celt` - must compile without errors.
Verify DecodeBands signature accepts frameSize and returns slice of that length.
  </verify>
  <done>DecodeBands returns coefficients slice of length frameSize with upper bins zero-padded.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for coefficient and sample counts</name>
  <files>internal/celt/bands_test.go, internal/celt/synthesis_test.go</files>
  <action>
Add tests verifying correct coefficient and sample counts for all frame sizes:

In bands_test.go, add TestDecodeBands_OutputSize:
```go
func TestDecodeBands_OutputSize(t *testing.T) {
    testCases := []struct {
        frameSize  int
        nbBands    int
        totalBins  int  // sum of scaled band widths
    }{
        {120, 13, 100},   // 2.5ms: EffBands=13, bands sum to ~100
        {240, 17, 200},   // 5ms
        {480, 19, 400},   // 10ms
        {960, 21, 800},   // 20ms: EffBands=21, bands sum to 800
    }

    for _, tc := range testCases {
        t.Run(fmt.Sprintf("%dms", tc.frameSize*1000/48000), func(t *testing.T) {
            d := NewDecoder(1)
            // Create mock energies and bandBits
            energies := make([]float64, tc.nbBands)
            bandBits := make([]int, tc.nbBands)

            coeffs := d.DecodeBands(energies, bandBits, tc.nbBands, false, tc.frameSize)

            if len(coeffs) != tc.frameSize {
                t.Errorf("DecodeBands returned %d coeffs, want %d", len(coeffs), tc.frameSize)
            }
        })
    }
}
```

In synthesis_test.go, add TestSynthesize_SampleCount:
```go
func TestSynthesize_SampleCount(t *testing.T) {
    testCases := []int{120, 240, 480, 960}

    for _, frameSize := range testCases {
        t.Run(fmt.Sprintf("%d", frameSize), func(t *testing.T) {
            d := NewDecoder(1)
            coeffs := make([]float64, frameSize)

            // First frame produces frameSize - Overlap samples
            samples := d.Synthesize(coeffs, false, 1)

            // For first frame, expect frameSize - Overlap (overlap comes from empty buffer)
            expectedFirst := frameSize - Overlap
            if len(samples) != expectedFirst {
                t.Errorf("First frame: got %d samples, want %d", len(samples), expectedFirst)
            }

            // Second frame should produce frameSize samples (steady state)
            // Note: After overlap-add stabilizes
        })
    }
}
```
  </action>
  <verify>
Run `go test ./internal/celt -run TestDecodeBands_OutputSize -v`
Run `go test ./internal/celt -run TestSynthesize_SampleCount -v`
All tests must pass.
  </verify>
  <done>Unit tests verify DecodeBands returns frameSize coefficients and Synthesize produces correct sample counts.</done>
</task>

<task type="auto">
  <name>Task 3: Verify DecodeFrame produces correct sample counts</name>
  <files>internal/celt/decoder_test.go</files>
  <action>
Add an integration test that verifies DecodeFrame produces the expected sample count after Tasks 1-2 changes:

```go
func TestDecodeFrame_SampleCount(t *testing.T) {
    testCases := []struct {
        frameSize       int
        expectedSamples int
    }{
        {120, 120},   // 2.5ms
        {240, 240},   // 5ms
        {480, 480},   // 10ms
        {960, 960},   // 20ms
    }

    for _, tc := range testCases {
        t.Run(fmt.Sprintf("%d", tc.frameSize), func(t *testing.T) {
            d := NewDecoder(1)
            // Create minimal valid packet data (silence/zeros)
            // The decoder should produce tc.expectedSamples output
            samples, err := d.DecodeFrame(nil, tc.frameSize)
            if err != nil {
                t.Fatalf("DecodeFrame error: %v", err)
            }
            if len(samples) != tc.expectedSamples {
                t.Errorf("DecodeFrame produced %d samples, want %d", len(samples), tc.expectedSamples)
            }
        })
    }
}
```

This confirms the full pipeline (DecodeBands -> Synthesize -> output) produces correct sample counts.
  </action>
  <verify>
Run `go test ./internal/celt -run TestDecodeFrame_SampleCount -v`
All frame sizes must produce correct sample counts.
  </verify>
  <done>Integration test confirms DecodeFrame produces correct sample counts for all frame sizes.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` succeeds
2. `go test ./internal/celt -v` passes all tests including new ones
3. DecodeBands returns exactly frameSize coefficients
4. Sample counts are verified for all frame sizes (120, 240, 480, 960)
</verification>

<success_criteria>
- DecodeBands returns slice of length frameSize (not totalBins)
- Unit tests verify coefficient counts for 120, 240, 480, 960 frame sizes
- All existing CELT tests continue to pass
- DecodeFrame produces correct sample counts for all frame sizes
</success_criteria>

<output>
After completion, create `.planning/phases/14-extended-frame-size/14-01-SUMMARY.md`
</output>
