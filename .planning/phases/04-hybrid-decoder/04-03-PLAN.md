---
phase: 04-hybrid-decoder
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/hybrid/hybrid_test.go
  - internal/hybrid/testdata_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Hybrid decoder processes a real hybrid-mode packet (config 12-15) without error"
    - "Decoded output has correct sample count (480 for 10ms, 960 for 20ms)"
    - "Range decoder state transitions correctly from SILK to CELT within same packet"
  artifacts:
    - path: "internal/hybrid/testdata_test.go"
      provides: "Hybrid packet construction helper using range encoder"
      min_lines: 50
    - path: "internal/hybrid/hybrid_test.go"
      provides: "Integration test with real hybrid packet decode"
      contains: "TestHybridRealPacket"
  key_links:
    - from: "internal/hybrid/testdata_test.go"
      to: "internal/rangecoding/encoder.go"
      via: "range encoder for packet construction"
      pattern: "rangecoding\\.NewEncoder"
    - from: "internal/hybrid/hybrid_test.go"
      to: "internal/hybrid/decoder.go"
      via: "decodeFrame with real packet"
      pattern: "decodeFrame.*rangecoding\\.NewDecoder"
---

<objective>
Close the verification gap: validate hybrid decoder with real hybrid-mode Opus packet

Purpose: The hybrid decoder infrastructure (SILK+CELT coordination, delay compensation, upsampling) is complete and unit-tested, but no test demonstrates end-to-end decoding of an actual hybrid packet. This gap closure creates a minimal valid hybrid packet using the project's own range encoder and verifies the decoder can process it.

Output: Integration test proving hybrid decoder works with real bitstream data, not just synthetic byte arrays.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-hybrid-decoder/04-01-SUMMARY.md
@.planning/phases/04-hybrid-decoder/04-02-SUMMARY.md
@.planning/phases/04-hybrid-decoder/04-VERIFICATION.md

# Key source files
@internal/hybrid/decoder.go
@internal/hybrid/hybrid_test.go
@internal/rangecoding/encoder.go
@internal/silk/tables.go
@internal/celt/tables.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hybrid packet construction helper</name>
  <files>internal/hybrid/testdata_test.go</files>
  <action>
Create a test helper file that constructs minimal valid hybrid packets using the project's range encoder.

The helper should:

1. **createMinimalHybridPacket(frameSize int) []byte** - Returns a valid hybrid packet
   - Use rangecoding.NewEncoder() to create bitstream
   - Encode minimal SILK data first (per RFC 6716 Section 4.2):
     * Frame flags (VAD=1, LBRR=0 for simplicity)
     * Signal type and quantization offset index
     * Minimal gains, LSF indices (can use simple/repeated values)
     * Zero excitation (silence frame is valid)
   - Encode minimal CELT data second (per RFC 6716 Section 4.3):
     * Silence flag = 1 (simplest valid CELT frame)
     * Post-filter disabled
     * No transient
     * Zero energy bands (silence)
   - The key insight: a silence/near-silence frame is the simplest valid hybrid packet

2. **Key constraints to follow:**
   - SILK portion must be decodable by internal/silk decoder
   - CELT portion must be decodable by internal/celt DecodeFrameHybrid
   - Total packet size should be small (10-50 bytes typical for silence)
   - Frame size must be 480 (10ms) or 960 (20ms)

3. **Alternative approach if range encoding is complex:**
   - Create a hardcoded known-good hybrid packet as []byte literal
   - Document what the bytes represent
   - This is acceptable because the goal is to test the DECODER, not the encoder

Add package-level documentation explaining this is test infrastructure.
  </action>
  <verify>
`go build ./internal/hybrid/...` succeeds
`go test -run=XXX ./internal/hybrid/...` compiles test helper
  </verify>
  <done>
testdata_test.go exists with createMinimalHybridPacket helper or hardcoded valid packet.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add real hybrid packet integration test</name>
  <files>internal/hybrid/hybrid_test.go</files>
  <action>
Add integration test that uses real hybrid packet data.

1. **TestHybridRealPacketDecode** - Primary integration test:
   ```go
   func TestHybridRealPacketDecode(t *testing.T) {
       d := NewDecoder(1) // mono

       // Get minimal valid hybrid packet
       packet := createMinimalHybridPacket(960) // 20ms

       // Create range decoder from packet
       rd := rangecoding.NewDecoder(packet)

       // Decode frame
       output, err := d.decodeFrame(rd, 960, false)
       if err != nil {
           t.Fatalf("decodeFrame failed: %v", err)
       }

       // Verify output length
       if len(output) != 960 {
           t.Errorf("output length = %d, want 960", len(output))
       }

       // Verify output is within reasonable range (not NaN/Inf)
       for i, s := range output {
           if math.IsNaN(s) || math.IsInf(s, 0) {
               t.Errorf("output[%d] is %f", i, s)
               break
           }
       }
   }
   ```

2. **TestHybridRealPacketStereo** - Stereo variant:
   - Same approach with 2-channel decoder
   - Verify output length is frameSize * 2

3. **TestHybridRealPacket10ms** - Test 10ms frame size (480 samples):
   - Verify the decoder handles both valid hybrid frame sizes

4. **Update or remove the skipped TestHybridOutputRange**:
   - Either replace the skip with actual test using createMinimalHybridPacket
   - Or leave skip but add comment referencing TestHybridRealPacketDecode

5. **Optional: TestHybridFrequencySplit** - Verify SILK and CELT contribute to different frequency ranges:
   - This is nice-to-have, not required for gap closure
   - Could use simple energy analysis (sum of squares) on output
   - For silence input, output should be near-zero everywhere
   </action>
  <verify>
`go test -v -run=TestHybridRealPacket ./internal/hybrid/...` passes
All existing hybrid tests still pass: `go test ./internal/hybrid/...`
  </verify>
  <done>
TestHybridRealPacketDecode passes, demonstrating the hybrid decoder can process actual hybrid bitstream data.
  </done>
</task>

</tasks>

<verification>
After completing both tasks:

1. Run all hybrid tests: `go test -v ./internal/hybrid/...`
2. Verify new integration tests pass
3. Verify no regressions in existing tests
4. Run full test suite: `go test ./...`

The gap is closed when:
- TestHybridRealPacketDecode passes (real packet decode works)
- Output has correct sample count (480 or 960)
- No NaN/Inf in output samples
</verification>

<success_criteria>
1. [ ] testdata_test.go created with hybrid packet helper
2. [ ] TestHybridRealPacketDecode passes with real hybrid packet
3. [ ] TestHybridRealPacket10ms passes (10ms frame size)
4. [ ] All existing hybrid tests continue to pass (15 tests)
5. [ ] Full project test suite passes: `go test ./...`
</success_criteria>

<output>
After completion, create `.planning/phases/04-hybrid-decoder/04-03-SUMMARY.md`
</output>
