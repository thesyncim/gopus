---
phase: 04-hybrid-decoder
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/hybrid/decoder.go
  - internal/hybrid/hybrid.go
  - internal/celt/decoder.go
  - internal/hybrid/hybrid_test.go
autonomous: true

must_haves:
  truths:
    - "Hybrid mode packets (configs 12-15) decode to 48kHz PCM"
    - "SILK layer decodes 0-8kHz at WB (16kHz), upsampled to 48kHz"
    - "CELT layer decodes 8-20kHz (bands 17-21) at 48kHz"
    - "SILK output delayed 60 samples relative to CELT before summing"
    - "Hybrid 10ms (480 samples) and 20ms (960 samples) frames decode correctly"
  artifacts:
    - path: "internal/hybrid/decoder.go"
      provides: "Hybrid decoder struct with SILK+CELT coordination"
      exports: ["Decoder", "NewDecoder", "Reset"]
    - path: "internal/hybrid/hybrid.go"
      provides: "Public Decode API for hybrid frames"
      exports: ["Decode", "DecodeStereo", "DecodeToInt16"]
    - path: "internal/celt/decoder.go"
      provides: "DecodeFrameHybrid method for band-limited CELT"
      exports: ["DecodeFrameHybrid"]
  key_links:
    - from: "internal/hybrid/decoder.go"
      to: "internal/silk/decoder.go"
      via: "silk.Decoder.DecodeFrame"
      pattern: "silkDecoder\\.DecodeFrame"
    - from: "internal/hybrid/decoder.go"
      to: "internal/celt/decoder.go"
      via: "celt.Decoder.DecodeFrameHybrid"
      pattern: "celtDecoder\\.DecodeFrameHybrid"
    - from: "internal/hybrid/decoder.go"
      to: "internal/rangecoding/decoder.go"
      via: "shared range decoder"
      pattern: "rangecoding\\.Decoder"
---

<objective>
Implement the Hybrid decoder that coordinates SILK and CELT layers for super-wideband and fullband speech decoding.

Purpose: Hybrid mode combines SILK for low frequencies (0-8kHz) with CELT for high frequencies (8-20kHz), providing high-quality wideband speech at medium bitrates. This completes the three Opus decoding modes.

Output: Working hybrid decoder that accepts config 12-15 packets and produces correct 48kHz PCM output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing decoders to coordinate
@internal/silk/silk.go
@internal/silk/decoder.go
@internal/silk/decode.go
@internal/silk/resample.go
@internal/celt/decoder.go
@internal/celt/tables.go

# Packet parsing for mode detection
@packet.go

# Research findings
# - SILK uses WB (16kHz) mode in hybrid, outputs 16kHz samples
# - SILK needs 3x upsampling (16kHz -> 48kHz)
# - SILK must be delayed SilkCELTDelay (60) samples at 48kHz
# - CELT decodes only bands 17-21 (above ~8kHz) in hybrid
# - Shared range decoder: SILK reads first, CELT reads remainder
# - Hybrid only supports 10ms and 20ms frames
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Hybrid decoder struct and coordination logic</name>
  <files>internal/hybrid/decoder.go</files>
  <action>
Create the Hybrid decoder package that coordinates SILK and CELT decoders.

Create `internal/hybrid/decoder.go`:

```go
package hybrid

// Decoder decodes Hybrid-mode Opus frames (SILK + CELT combined).
// Hybrid mode uses SILK for 0-8kHz and CELT for 8-20kHz.
type Decoder struct {
    silkDecoder *silk.Decoder
    celtDecoder *celt.Decoder

    // Delay buffer for SILK (60 samples at 48kHz per channel)
    silkDelayBuffer []float64

    // Channel count
    channels int
}
```

Key implementation details:
1. `NewDecoder(channels int) *Decoder` - Creates new hybrid decoder, initializing both SILK (always WB for hybrid) and CELT decoders
2. `Reset()` - Resets both decoders and clears delay buffer
3. `decodeFrame(rd *rangecoding.Decoder, frameSize int, stereo bool) ([]float64, error)`:
   - SILK decodes first using shared range decoder (WB mode, 16kHz)
   - CELT decodes remainder using same range decoder (bands 17-21 only)
   - Upsample SILK 3x from 16kHz to 48kHz
   - Apply 60-sample delay to SILK output
   - Sum SILK + CELT outputs

Constants to define:
- `HybridCELTStartBand = 17` (CELT only decodes bands 17-21)
- `SilkCELTDelay = 60` (already in celt/tables.go, reuse)

For delay compensation:
- Maintain `silkDelayBuffer` of 60 samples per channel
- On each frame: output = delayed_silk + celt
- Shift: current SILK tail becomes next frame's delay

SILK sample count for hybrid frames:
- 10ms: 160 samples at 16kHz -> 480 at 48kHz
- 20ms: 320 samples at 16kHz -> 960 at 48kHz
  </action>
  <verify>
- File compiles: `go build ./internal/hybrid/...`
- Decoder struct has both SILK and CELT decoder fields
- NewDecoder initializes both sub-decoders
  </verify>
  <done>Hybrid decoder struct created with SILK/CELT coordination, delay buffer, and frame decoding logic</done>
</task>

<task type="auto">
  <name>Task 2: Add DecodeFrameHybrid to CELT decoder for band-limited decoding</name>
  <files>internal/celt/decoder.go</files>
  <action>
Add a new method to the CELT decoder that decodes only the high-frequency bands (17-21) used in hybrid mode.

Add to `internal/celt/decoder.go`:

```go
// HybridCELTStartBand is the first CELT band decoded in hybrid mode.
// Bands 0-16 are covered by SILK; CELT only decodes bands 17-21.
const HybridCELTStartBand = 17

// DecodeFrameHybrid decodes a CELT frame for hybrid mode.
// In hybrid mode, CELT only decodes bands 17-21 (frequencies above ~8kHz).
// The range decoder should already have been partially consumed by SILK.
//
// Parameters:
//   - rd: Range decoder (SILK has already consumed its portion)
//   - frameSize: Expected output samples (480 or 960 for hybrid 10ms/20ms)
//
// Returns: PCM samples as float64 slice at 48kHz
func (d *Decoder) DecodeFrameHybrid(rd *rangecoding.Decoder, frameSize int) ([]float64, error)
```

Implementation notes:
1. Similar to DecodeFrame but:
   - Start band decoding at HybridCELTStartBand (17) instead of 0
   - Energy decoding starts at band 17
   - Band allocation only for bands 17-21
   - Lower bands (0-16) filled with zeros

2. The range decoder is shared with SILK, so SILK has already read its portion. CELT reads from current position.

3. Synthesis pipeline remains the same (IMDCT, windowing, overlap-add, de-emphasis)

4. Modify DecodeBands/DecodeBandsStereo to accept startBand parameter, or create helper that zeros lower bands after decoding.

Alternative simpler approach:
- Decode all bands as usual but zero out bands 0-16 before synthesis
- This wastes bits but is simpler initially
- Optimization: true band-limited decoding can come later

Choose the simpler approach for now: decode normally but zero bands 0-16 before IMDCT.
  </action>
  <verify>
- File compiles: `go build ./internal/celt/...`
- DecodeFrameHybrid method exists on Decoder
- Existing CELT tests still pass: `go test ./internal/celt/...`
  </verify>
  <done>DecodeFrameHybrid added to CELT decoder, decodes high-frequency bands only for hybrid mode</done>
</task>

<task type="auto">
  <name>Task 3: Create public API and integration tests</name>
  <files>internal/hybrid/hybrid.go, internal/hybrid/hybrid_test.go</files>
  <action>
Create the public API for hybrid decoding and comprehensive tests.

Create `internal/hybrid/hybrid.go`:

```go
package hybrid

// Decode decodes a Hybrid mono frame and returns 48kHz PCM samples.
//
// Parameters:
//   - data: raw Opus frame data (without TOC byte)
//   - frameSize: frame size in samples at 48kHz (480 for 10ms, 960 for 20ms)
//   - bandwidth: SWB or FB (determines CELT band count)
//
// Returns float64 samples at 48kHz.
func (d *Decoder) Decode(data []byte, frameSize int) ([]float64, error)

// DecodeStereo decodes a Hybrid stereo frame and returns 48kHz PCM samples.
// Returns interleaved stereo samples [L0, R0, L1, R1, ...] at 48kHz.
func (d *Decoder) DecodeStereo(data []byte, frameSize int) ([]float64, error)

// DecodeToInt16 decodes and converts to int16 PCM.
func (d *Decoder) DecodeToInt16(data []byte, frameSize int) ([]int16, error)

// DecodeToFloat32 decodes and converts to float32 PCM.
func (d *Decoder) DecodeToFloat32(data []byte, frameSize int) ([]float32, error)
```

Create `internal/hybrid/hybrid_test.go`:

Test cases:
1. `TestNewDecoder` - Verifies decoder initialization
2. `TestHybridFrameSizes` - Tests 10ms (480) and 20ms (960) frames
3. `TestHybridDelayCompensation` - Verifies SILK is delayed 60 samples
4. `TestHybridStereo` - Stereo hybrid decoding
5. `TestHybridOutputRange` - Output samples in expected range
6. `TestHybridReset` - Reset clears state properly

For testing without real Opus packets, create synthetic test data:
- Construct minimal valid SILK + CELT bitstream
- Or use mock decoders that return known patterns
- Test delay compensation: inject known SILK/CELT patterns, verify output timing

Key behaviors to verify:
- frameSize must be 480 or 960 (hybrid only supports 10ms/20ms)
- SILK delay buffer properly shifts samples between frames
- Output is sum of delayed SILK and CELT
- Stereo interleaving is correct [L0, R0, L1, R1...]
  </action>
  <verify>
- All tests pass: `go test ./internal/hybrid/... -v`
- Package compiles: `go build ./internal/hybrid/...`
- Test coverage reasonable: `go test ./internal/hybrid/... -cover`
  </verify>
  <done>Public API created with Decode, DecodeStereo, and comprehensive tests validating hybrid decoding</done>
</task>

</tasks>

<verification>
1. All code compiles: `go build ./...`
2. All tests pass: `go test ./... -v`
3. Hybrid decoder coordinates SILK and CELT correctly
4. SILK delay compensation implemented (60 sample delay at 48kHz)
5. CELT decodes only high-frequency bands in hybrid mode
6. Both 10ms and 20ms hybrid frames supported
</verification>

<success_criteria>
- Hybrid decoder struct exists with SILK and CELT sub-decoders
- DecodeFrameHybrid method added to CELT for band-limited decoding
- Public Decode/DecodeStereo API functional
- Unit tests pass validating frame sizes, delay compensation, stereo
- No regressions in SILK or CELT tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-hybrid-decoder/04-01-SUMMARY.md`
</output>
