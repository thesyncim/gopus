---
phase: 04-hybrid-decoder
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/plc/plc.go
  - internal/plc/silk_plc.go
  - internal/plc/celt_plc.go
  - internal/plc/plc_test.go
  - internal/silk/decoder.go
  - internal/celt/decoder.go
  - internal/hybrid/decoder.go
autonomous: true

must_haves:
  truths:
    - "NULL packet triggers PLC instead of decode error"
    - "SILK PLC produces fading speech-like output"
    - "CELT PLC produces fading noise output"
    - "Hybrid PLC coordinates both SILK and CELT concealment"
    - "PLC output level decays over consecutive lost packets"
  artifacts:
    - path: "internal/plc/plc.go"
      provides: "PLC types and coordination logic"
      exports: ["State", "Mode", "Conceal"]
    - path: "internal/plc/silk_plc.go"
      provides: "SILK-specific packet loss concealment"
      exports: ["ConcealSILK"]
    - path: "internal/plc/celt_plc.go"
      provides: "CELT-specific packet loss concealment"
      exports: ["ConcealCELT"]
  key_links:
    - from: "internal/hybrid/decoder.go"
      to: "internal/plc/plc.go"
      via: "ConcealHybrid for NULL packets"
      pattern: "plc\\.Conceal"
    - from: "internal/plc/silk_plc.go"
      to: "internal/silk/decoder.go"
      via: "access to previous frame parameters"
      pattern: "silk\\.Decoder"
    - from: "internal/plc/celt_plc.go"
      to: "internal/celt/decoder.go"
      via: "access to previous energy state"
      pattern: "celt\\.Decoder"
---

<objective>
Implement Packet Loss Concealment (PLC) for SILK, CELT, and Hybrid modes.

Purpose: PLC generates plausible audio when packets are lost, preventing jarring silence or glitches. This is essential for real-time audio applications over unreliable networks. RFC 6716 mandates basic PLC support.

Output: PLC module that produces smooth concealed audio for lost packets, with appropriate decay to prevent prolonged artifacts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan output needed for hybrid integration
@.planning/phases/04-hybrid-decoder/04-01-SUMMARY.md

# Decoder state for PLC
@internal/silk/decoder.go
@internal/celt/decoder.go

# Research findings for PLC:
# - SILK PLC: extrapolate LPC coefficients, fade pitch, generate comfort noise
# - CELT PLC: fade energy, noise fill uncoded bands
# - Hybrid PLC: run SILK PLC + CELT PLC, sum as normal
# - Fade factor: reduce gain by ~6dB per lost frame
# - Maximum concealment: ~100ms before full fade to silence
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PLC package with state tracking and coordination</name>
  <files>internal/plc/plc.go</files>
  <action>
Create the PLC package with state tracking and mode-aware concealment.

Create `internal/plc/plc.go`:

```go
package plc

// Mode indicates which Opus mode to use for concealment.
type Mode int

const (
    ModeSILK   Mode = iota // SILK-only concealment
    ModeCELT               // CELT-only concealment
    ModeHybrid             // Hybrid SILK+CELT concealment
)

// MaxConcealedFrames is the maximum consecutive frames to conceal
// before fading to silence. ~100ms at 20ms frames = 5 frames.
const MaxConcealedFrames = 5

// FadePerFrame is the gain reduction per lost frame (linear).
// Approximately -6dB per frame: 10^(-6/20) ~ 0.5
const FadePerFrame = 0.5

// State tracks PLC state across frames.
type State struct {
    // Consecutive lost packets
    lostCount int

    // Mode for concealment (set from last good packet)
    mode Mode

    // Fade factor (1.0 = full volume, decays toward 0)
    fadeFactor float64

    // Last frame parameters (for extrapolation)
    lastFrameSize int
    lastChannels  int
}

// NewState creates a new PLC state.
func NewState() *State

// Reset clears PLC state after receiving a good packet.
func (s *State) Reset()

// RecordLoss records a lost packet and returns current fade factor.
func (s *State) RecordLoss() float64

// LostCount returns consecutive lost packet count.
func (s *State) LostCount() int

// FadeFactor returns current fade level (0.0 to 1.0).
func (s *State) FadeFactor() float64

// SetLastFrameParams stores parameters from the last good frame.
func (s *State) SetLastFrameParams(mode Mode, frameSize, channels int)
```

Implementation:
1. `RecordLoss()` increments lostCount, updates fadeFactor:
   - `fadeFactor = fadeFactor * FadePerFrame`
   - Clamp to 0.0 minimum
   - After MaxConcealedFrames, fadeFactor should be near zero

2. `Reset()` called when good packet received:
   - lostCount = 0
   - fadeFactor = 1.0

3. Mode determines which concealment algorithm to use
  </action>
  <verify>
- File compiles: `go build ./internal/plc/...`
- State struct has lostCount, mode, fadeFactor fields
- FadePerFrame constant defined
  </verify>
  <done>PLC state tracking and coordination created with fade factor calculation</done>
</task>

<task type="auto">
  <name>Task 2: Implement SILK and CELT concealment algorithms</name>
  <files>internal/plc/silk_plc.go, internal/plc/celt_plc.go</files>
  <action>
Implement per-layer concealment algorithms.

Create `internal/plc/silk_plc.go`:

```go
package plc

import "gopus/internal/silk"

// ConcealSILK generates concealment audio for a lost SILK frame.
//
// SILK PLC strategy:
// 1. Reuse LPC coefficients from last frame
// 2. For voiced: continue pitch prediction with decaying gain
// 3. For unvoiced: generate comfort noise
// 4. Apply fade factor to output
//
// Parameters:
//   - dec: SILK decoder with state from last good frame
//   - frameSize: samples to generate at native rate
//   - fadeFactor: gain multiplier (0.0 to 1.0)
//
// Returns: concealed samples at native SILK rate (8/12/16kHz)
func ConcealSILK(dec *silk.Decoder, frameSize int, fadeFactor float64) []float32
```

Implementation approach:
1. Get last frame state from decoder (LPC coeffs, voiced flag, pitch lag)
2. If last frame was voiced:
   - Use LTP filter with previous output history
   - Apply decaying gain to excitation
3. If last frame was unvoiced:
   - Generate white noise scaled by comfort noise level
4. Apply LPC synthesis filter
5. Scale output by fadeFactor

Create `internal/plc/celt_plc.go`:

```go
package plc

import "gopus/internal/celt"

// ConcealCELT generates concealment audio for a lost CELT frame.
//
// CELT PLC strategy:
// 1. Copy energy from previous frame with decay
// 2. Fill bands with noise at decayed energy levels
// 3. Apply normal IMDCT synthesis
// 4. Apply fade factor to output
//
// Parameters:
//   - dec: CELT decoder with state from last good frame
//   - frameSize: samples to generate at 48kHz
//   - fadeFactor: gain multiplier (0.0 to 1.0)
//
// Returns: concealed samples at 48kHz
func ConcealCELT(dec *celt.Decoder, frameSize int, fadeFactor float64) []float64
```

Implementation approach:
1. Copy prevEnergy from decoder, apply decay factor (~0.85 per band)
2. For each band:
   - Generate random noise vector
   - Normalize to unit length
   - Scale by decayed energy
3. Run IMDCT synthesis with overlap-add
4. Apply de-emphasis filter
5. Scale output by fadeFactor

Helper function needed:
```go
// generateNoiseBand creates a random unit-norm vector for a band.
func generateNoiseBand(rng *uint32, bandWidth int) []float64
```

Use LCG from CELT decoder for deterministic noise.
  </action>
  <verify>
- Files compile: `go build ./internal/plc/...`
- ConcealSILK returns samples at expected length
- ConcealCELT returns samples at expected length
  </verify>
  <done>SILK PLC (LPC extrapolation + pitch/noise) and CELT PLC (energy fade + noise fill) implemented</done>
</task>

<task type="auto">
  <name>Task 3: Integrate PLC into decoders and add tests</name>
  <files>internal/plc/plc_test.go, internal/silk/decoder.go, internal/celt/decoder.go, internal/hybrid/decoder.go</files>
  <action>
Integrate PLC into decoder APIs and add comprehensive tests.

Update decoder signatures to handle NULL/lost packets:

In `internal/silk/decoder.go`, update Decode:
```go
// Decode decodes a SILK frame. If data is nil, performs PLC.
func (d *Decoder) Decode(data []byte, ...) ([]float32, error)
```

In `internal/celt/decoder.go`, update DecodeFrame:
```go
// DecodeFrame decodes a CELT frame. If data is nil, performs PLC.
func (d *Decoder) DecodeFrame(data []byte, frameSize int) ([]float64, error)
```

In `internal/hybrid/decoder.go`, update Decode:
```go
// Decode decodes a Hybrid frame. If data is nil, performs PLC.
func (d *Decoder) Decode(data []byte, frameSize int) ([]float64, error)
```

Each decoder should:
1. Check if data == nil (lost packet signal)
2. If lost: call appropriate PLC function, update PLC state
3. If good: decode normally, reset PLC state

Create `internal/plc/plc_test.go`:

Test cases:
1. `TestPLCState` - State tracking (lostCount, fadeFactor decay)
2. `TestPLCReset` - Reset after good packet
3. `TestSILKPLCOutput` - SILK concealment produces valid samples
4. `TestCELTPLCOutput` - CELT concealment produces valid samples
5. `TestPLCFadeProfile` - Verify fade decays correctly over frames
6. `TestPLCMaxConcealment` - After MaxConcealedFrames, output near silence
7. `TestHybridPLC` - Hybrid mode concealment coordinates both layers

Key behaviors to test:
- First lost frame: fadeFactor = 0.5 (one FadePerFrame applied)
- Second lost frame: fadeFactor = 0.25
- Fifth lost frame: fadeFactor ~ 0.03 (nearly silent)
- Good packet resets fadeFactor to 1.0
- Output samples have reasonable amplitude (not clipping, not silent when not faded)
  </action>
  <verify>
- All tests pass: `go test ./internal/plc/... -v`
- All tests pass: `go test ./... -v` (no regressions)
- PLC integration works: nil data triggers concealment
  </verify>
  <done>PLC integrated into SILK, CELT, and Hybrid decoders with comprehensive tests</done>
</task>

</tasks>

<verification>
1. All code compiles: `go build ./...`
2. All tests pass: `go test ./... -v`
3. NULL packet data triggers PLC instead of error
4. SILK PLC uses LPC extrapolation
5. CELT PLC uses energy decay with noise fill
6. Fade factor decays correctly over consecutive losses
7. Good packets reset PLC state
</verification>

<success_criteria>
- PLC state tracking implemented with fade factor
- SILK PLC generates fading speech-like output
- CELT PLC generates fading noise output
- Hybrid PLC coordinates both layers
- All decoders handle nil data for PLC
- Tests verify fade profile and maximum concealment
- No regressions in existing decoder tests
</success_criteria>

<output>
After completion, create `.planning/phases/04-hybrid-decoder/04-02-SUMMARY.md`
</output>
