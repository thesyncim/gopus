---
phase: 11-container
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - container/ogg/writer.go
  - container/ogg/reader.go
  - container/ogg/writer_test.go
  - container/ogg/reader_test.go
  - container/ogg/integration_test.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Ogg Opus files created by FFmpeg/libopus can be read and decoded"
    - "Encoded audio can be written to Ogg Opus files playable by standard players"
    - "Writer produces files accepted by opusdec command-line tool"
    - "Reader can parse files created by FFmpeg or other encoders"
    - "Granule position correctly tracks sample count including pre-skip"
  artifacts:
    - path: "container/ogg/writer.go"
      provides: "OggWriter for creating Ogg Opus files"
      exports: ["Writer", "NewWriter", "NewWriterWithConfig"]
    - path: "container/ogg/reader.go"
      provides: "OggReader for reading Ogg Opus files"
      exports: ["Reader", "NewReader"]
    - path: "container/ogg/integration_test.go"
      provides: "End-to-end tests with opusdec"
      contains: "TestIntegration"
  key_links:
    - from: "container/ogg/writer.go"
      to: "container/ogg/page.go"
      via: "Page creation and encoding"
      pattern: "Page\\{|Encode\\(\\)"
    - from: "container/ogg/writer.go"
      to: "container/ogg/header.go"
      via: "OpusHead and OpusTags generation"
      pattern: "OpusHead|OpusTags"
    - from: "container/ogg/reader.go"
      to: "container/ogg/page.go"
      via: "Page parsing"
      pattern: "ParsePage"
---

<objective>
Implement OggWriter and OggReader for complete Ogg Opus file read/write functionality.

Purpose: This plan creates the high-level API for reading and writing Ogg Opus files. The Writer produces files playable by standard players (VLC, FFmpeg, browsers). The Reader can parse files from any Opus encoder.

Output: Production-ready OggWriter and OggReader with integration tests validating interoperability with libopus tools.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-container/11-RESEARCH.md
@.planning/phases/11-container/11-01-SUMMARY.md

# Reference for pattern
@internal/multistream/libopus_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement OggWriter for creating Ogg Opus files</name>
  <files>
    container/ogg/writer.go
    container/ogg/writer_test.go
  </files>
  <action>
Create the OggWriter that wraps io.Writer and produces valid Ogg Opus files:

1. **writer.go**: OggWriter implementation.

   **WriterConfig**:
   ```go
   type WriterConfig struct {
       SampleRate     uint32  // Input sample rate (48000 for Opus)
       Channels       uint8   // Channel count (1-255)
       PreSkip        uint16  // Encoder lookahead (default 312)
       OutputGain     int16   // Q7.8 dB gain (default 0)
       // For multistream (channels > 2 or explicit config):
       MappingFamily  uint8   // 0=mono/stereo, 1=surround
       StreamCount    uint8   // Number of streams (for family 1)
       CoupledCount   uint8   // Number of coupled streams (for family 1)
       ChannelMapping []byte  // Channel mapping table (for family 1)
   }
   ```

   **Writer struct**:
   ```go
   type Writer struct {
       w            io.Writer
       config       WriterConfig
       serial       uint32      // Random bitstream serial number
       pageSeq      uint32      // Page sequence counter
       granulePos   uint64      // Sample position (at 48kHz)
       headersDone  bool        // Headers written?
       closed       bool
   }
   ```

   **Functions**:
   - `func NewWriter(w io.Writer, sampleRate uint32, channels uint8) (*Writer, error)`:
     Create writer with default config (family 0 for 1-2 channels).
     Automatically calls writeHeaders().
   - `func NewWriterWithConfig(w io.Writer, config WriterConfig) (*Writer, error)`:
     Create writer with explicit config. Validates config.
     Automatically calls writeHeaders().
   - `func (ow *Writer) WritePacket(packet []byte, samples int) error`:
     Write an Opus packet. Updates granulePos += samples.
     Creates one Ogg page per packet (simple approach per RFC 7845 recommendation).
   - `func (ow *Writer) Close() error`:
     Write EOS page and mark as closed.
   - Internal: `func (ow *Writer) writeHeaders() error`:
     Write BOS page with OpusHead, then page with OpusTags.
   - Internal: `func (ow *Writer) writePage(payload []byte, headerType byte) error`:
     Build page with current granulePos, increment pageSeq.

   **Important details**:
   - Generate random serial number in NewWriter using math/rand.
   - Header pages (OpusHead, OpusTags) MUST have granulePos = 0.
   - Audio pages have granulePos = total samples encoded so far.
   - BOS flag (0x02) on first page only.
   - EOS flag (0x04) on Close().

2. **writer_test.go**: Writer tests.
   - TestNewWriter_Mono: Create mono writer, verify headers written.
   - TestNewWriter_Stereo: Create stereo writer.
   - TestNewWriter_InvalidChannels: 0 or > 255 channels returns error.
   - TestWritePacket_Single: Write one packet, verify page structure.
   - TestWritePacket_Multiple: Write 10 packets, verify granule positions.
   - TestWritePacket_LargePacket: Packet > 255 bytes handled correctly.
   - TestClose: Verify EOS page written.
   - TestWriterWithConfig_Multistream: Create 5.1 writer with family 1 config.
  </action>
  <verify>
    go build ./container/ogg/...
    go test -v -run TestNewWriter ./container/ogg/...
    go test -v -run TestWritePacket ./container/ogg/...
  </verify>
  <done>
    - Writer compiles and creates valid Ogg Opus containers
    - Headers (OpusHead, OpusTags) written with granulePos = 0
    - Packets written with correct granule position tracking
    - Close() writes EOS page
    - All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement OggReader for reading Ogg Opus files</name>
  <files>
    container/ogg/reader.go
    container/ogg/reader_test.go
  </files>
  <action>
Create the OggReader that parses Ogg Opus files from io.Reader:

1. **reader.go**: OggReader implementation.

   **Reader struct**:
   ```go
   type Reader struct {
       r             io.Reader
       Header        *OpusHead    // Parsed ID header (set after NewReader)
       Tags          *OpusTags    // Parsed comment header (set after NewReader)
       granulePos    uint64       // Last granule position seen
       eos           bool         // End of stream reached
       partialPacket []byte       // For packets spanning pages
   }
   ```

   **Functions**:
   - `func NewReader(r io.Reader) (*Reader, error)`:
     Create reader and parse headers.
     Read BOS page, verify OpusHead magic, parse OpusHead.
     Read comment page(s), parse OpusTags.
     Return reader ready for ReadPacket().
   - `func (or *Reader) ReadPacket() (packet []byte, granulePos uint64, err error)`:
     Read next Opus packet from stream.
     Handle packet continuation across pages.
     Return io.EOF when EOS page encountered.
   - `func (or *Reader) PreSkip() uint16`:
     Return header pre-skip value.
   - `func (or *Reader) Channels() uint8`:
     Return header channel count.
   - `func (or *Reader) SampleRate() uint32`:
     Return header sample rate.
   - Internal: `func (or *Reader) readPage() (*Page, error)`:
     Read next page from stream. Handle variable page sizes.

   **Important details**:
   - First page MUST have BOS flag and contain OpusHead.
   - Second page contains OpusTags (may span multiple pages if large comments).
   - Handle packets split across pages (continuation flag).
   - Return io.EOF on EOS flag, not error.
   - Validate CRC on every page read.

2. **reader_test.go**: Reader tests.
   - TestNewReader_Valid: Parse writer output.
   - TestNewReader_NotOgg: Non-Ogg data returns error.
   - TestNewReader_BadMagic: Invalid OpusHead magic returns error.
   - TestReadPacket_Single: Read single packet written by Writer.
   - TestReadPacket_Multiple: Read 10 packets.
   - TestReadPacket_EOF: Verify io.EOF after EOS page.
   - TestReader_HeaderFields: Verify Header fields match writer config.
   - TestReader_MultistreamHeader: Parse family 1 headers.
  </action>
  <verify>
    go build ./container/ogg/...
    go test -v -run TestNewReader ./container/ogg/...
    go test -v -run TestReadPacket ./container/ogg/...
  </verify>
  <done>
    - Reader compiles and parses valid Ogg Opus files
    - NewReader parses OpusHead and OpusTags
    - ReadPacket returns packets with correct granule positions
    - io.EOF returned after EOS page
    - CRC verified on every page
    - All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration tests with opusdec and round-trip validation</name>
  <files>
    container/ogg/integration_test.go
  </files>
  <action>
Create integration tests that validate interoperability with libopus tools:

1. **integration_test.go**: End-to-end tests.

   **Helper functions** (copy pattern from internal/multistream/libopus_test.go):
   - `func checkOpusdec() bool` - check if opusdec available.
   - `func getOpusdecPath() string` - get path to opusdec.
   - `func decodeWithOpusdec(oggData []byte) ([]float32, error)` - decode Ogg Opus using opusdec.
   - `func parseWAVSamples(data []byte) []float32` - parse WAV output from opusdec.

   **Tests**:
   - TestIntegration_WriterOpusdec_Mono:
     1. Create Writer with mono config.
     2. Generate test packets using gopus encoder (import from main package).
     3. Write packets to buffer.
     4. Decode with opusdec.
     5. Verify output has audio (energy > 0).

   - TestIntegration_WriterOpusdec_Stereo:
     Same as mono but with 2 channels.

   - TestIntegration_WriterOpusdec_Multistream:
     1. Create Writer with 5.1 config (family 1).
     2. Generate test packets using multistream encoder.
     3. Write packets to buffer.
     4. Decode with opusdec.
     5. Verify 6-channel output.

   - TestIntegration_RoundTrip:
     1. Create Writer, write packets.
     2. Create Reader, read packets back.
     3. Verify packet count and lengths match.

   - TestIntegration_ReaderWriterRoundTrip:
     1. Write N packets with Writer.
     2. Read N packets with Reader.
     3. Verify each packet matches byte-for-byte.

   - TestIntegration_GranulePosition:
     1. Write packets with known sample counts.
     2. Read packets, verify granule positions.
     3. Verify final granule = sum of all samples.

   **Skip handling**:
   - Skip tests if opusdec not available (use t.Skip).
   - Handle macOS provenance issues gracefully.

2. **Import gopus encoder** for generating test packets:
   ```go
   import (
       "github.com/thesyncim/gopus"  // or just "." if in same module
   )
   ```
   Generate 20ms frames of test audio, encode with gopus.Encoder.
  </action>
  <verify>
    go test -v -run TestIntegration ./container/ogg/...
    # Tests pass (or skip gracefully if opusdec unavailable)
  </verify>
  <done>
    - Integration tests compile and run
    - Writer output accepted by opusdec (files playable)
    - Reader successfully parses Writer output
    - Round-trip tests pass (packets match)
    - Granule positions correct
    - Tests skip gracefully when opusdec unavailable
  </done>
</task>

</tasks>

<verification>
# Build verification
go build ./container/ogg/...

# Run all tests
go test -v ./container/ogg/...

# Run integration tests specifically
go test -v -run TestIntegration ./container/ogg/...

# If opusdec available, verify manual playback
# (create test file and play with opusdec or VLC)
</verification>

<success_criteria>
1. Writer produces valid Ogg Opus files per RFC 7845
2. Writer output plays in VLC/opusdec without errors
3. Reader parses OpusHead and OpusTags correctly
4. Reader extracts packets matching what Writer wrote
5. Granule position tracking is accurate (samples at 48kHz)
6. Pre-skip value correctly communicated in header
7. Multistream (5.1, 7.1) configurations work with mapping family 1
8. CRC verification catches corrupted pages
9. All tests pass (integration tests skip gracefully if tools unavailable)
</success_criteria>

<output>
After completion, create `.planning/phases/11-container/11-02-SUMMARY.md`
</output>
