---
phase: 11-container
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - container/ogg/doc.go
  - container/ogg/crc.go
  - container/ogg/page.go
  - container/ogg/header.go
  - container/ogg/errors.go
  - container/ogg/ogg_test.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Ogg CRC-32 calculation produces correct checksums (polynomial 0x04C11DB7)"
    - "Ogg pages can be constructed with correct segment tables"
    - "OpusHead can be parsed from bytes and encoded to bytes"
    - "OpusTags can be parsed from bytes and encoded to bytes"
    - "Segment tables correctly handle packets > 255 bytes"
  artifacts:
    - path: "container/ogg/crc.go"
      provides: "Ogg-specific CRC-32 calculation"
      contains: "oggCRCTable"
    - path: "container/ogg/page.go"
      provides: "OggPage struct and segment table handling"
      exports: ["Page", "BuildSegmentTable", "ParseSegmentTable"]
    - path: "container/ogg/header.go"
      provides: "OpusHead and OpusTags parsing/encoding"
      exports: ["OpusHead", "OpusTags", "ParseOpusHead", "ParseOpusTags"]
    - path: "container/ogg/errors.go"
      provides: "Public error types"
      exports: ["ErrInvalidPage", "ErrInvalidHeader", "ErrBadCRC"]
  key_links:
    - from: "container/ogg/page.go"
      to: "container/ogg/crc.go"
      via: "CRC computation in page encoding"
      pattern: "oggCRC"
    - from: "container/ogg/header.go"
      to: "encoding/binary"
      via: "Little-endian encoding"
      pattern: "binary.LittleEndian"
---

<objective>
Implement the Ogg page layer foundation: CRC-32 calculation, page structure, segment table handling, and Opus-specific headers (OpusHead, OpusTags).

Purpose: This plan creates the low-level building blocks for Ogg container read/write. The Ogg format uses pages as atomic units with CRC verification, and Opus requires specific header structures per RFC 7845.

Output: A `container/ogg` package with complete page and header handling, validated by round-trip tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-container/11-RESEARCH.md

# Existing Ogg code to refactor (test helpers proven to work with opusdec)
@internal/celt/crossval_test.go
@internal/multistream/libopus_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Ogg package foundation with CRC and page structure</name>
  <files>
    container/ogg/doc.go
    container/ogg/crc.go
    container/ogg/page.go
    container/ogg/errors.go
  </files>
  <action>
Create the container/ogg package with:

1. **doc.go**: Package documentation explaining Ogg Opus container format (RFC 7845, RFC 3533).

2. **crc.go**: Ogg-specific CRC-32 implementation.
   - Pre-computed lookup table using polynomial 0x04C11DB7 (NOT IEEE).
   - `func oggCRC(data []byte) uint32` - compute CRC from scratch.
   - `func oggCRCUpdate(crc uint32, data []byte) uint32` - update running CRC.
   - Initialize lookup table in init() function.
   - COPY the working implementation from internal/celt/crossval_test.go (lines 64-94).

3. **page.go**: Ogg page structure and segment table handling.
   - Page header constants:
     ```go
     const (
         PageFlagContinuation = 0x01  // Packet continues from previous page
         PageFlagBOS          = 0x02  // Beginning of stream
         PageFlagEOS          = 0x04  // End of stream
     )
     ```
   - `type Page struct` with fields:
     - Version byte (always 0)
     - HeaderType byte (flags)
     - GranulePos uint64
     - SerialNumber uint32
     - PageSequence uint32
     - Segments []byte (segment table)
     - Payload []byte
   - `func BuildSegmentTable(packetLen int) []byte` - create segment table for a packet.
     Packets > 255 bytes span multiple segments (each 255 except final).
   - `func ParseSegmentTable(segments []byte) []int` - extract packet lengths from segment table.
   - `func (p *Page) Encode() []byte` - serialize page with CRC (27 bytes header + segment table + payload).
   - `func ParsePage(data []byte) (*Page, int, error)` - parse page from bytes, return page and bytes consumed.

4. **errors.go**: Public error types.
   - `var ErrInvalidPage = errors.New("ogg: invalid page structure")`
   - `var ErrInvalidHeader = errors.New("ogg: invalid Opus header")`
   - `var ErrBadCRC = errors.New("ogg: CRC mismatch")`
   - `var ErrUnexpectedEOS = errors.New("ogg: unexpected end of stream")`

IMPORTANT: Use the proven CRC implementation from test files. Do NOT use hash/crc32 package (wrong polynomial).
  </action>
  <verify>
    go build ./container/ogg/...
    go test -v -run TestOggCRC ./container/ogg/...
  </verify>
  <done>
    - Package compiles with zero errors
    - CRC lookup table initialized correctly
    - Page.Encode() produces bytes starting with "OggS"
    - BuildSegmentTable handles packets > 255 bytes correctly
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement OpusHead and OpusTags headers</name>
  <files>
    container/ogg/header.go
    container/ogg/ogg_test.go
  </files>
  <action>
Implement Opus-specific headers per RFC 7845:

1. **header.go**: OpusHead and OpusTags structures.

   **OpusHead** (ID Header):
   ```go
   type OpusHead struct {
       Version        uint8   // Must be 1
       Channels       uint8   // Output channel count (1-255)
       PreSkip        uint16  // Samples to discard at start
       SampleRate     uint32  // Original input sample rate (informational)
       OutputGain     int16   // Q7.8 dB gain to apply
       MappingFamily  uint8   // 0=mono/stereo, 1=surround, 255=discrete
       // Extended fields for mapping family 1 and 255:
       StreamCount    uint8   // Number of Opus streams
       CoupledCount   uint8   // Number of coupled (stereo) streams
       ChannelMapping []byte  // Channel mapping table
   }
   ```
   - `func (h *OpusHead) Encode() []byte` - serialize to bytes.
     - 19 bytes for family 0 (mono/stereo).
     - 21 + channels bytes for family 1/255.
     - Magic: "OpusHead" (8 bytes).
   - `func ParseOpusHead(data []byte) (*OpusHead, error)` - parse from bytes.
     - Validate magic "OpusHead".
     - Validate version == 1.
     - Parse extended fields if MappingFamily != 0.

   **OpusTags** (Comment Header):
   ```go
   type OpusTags struct {
       Vendor   string            // Encoder name (e.g., "gopus")
       Comments map[string]string // User comments (NAME=value)
   }
   ```
   - `func (t *OpusTags) Encode() []byte` - serialize to bytes.
     - Magic: "OpusTags" (8 bytes).
     - Vendor string length (4 bytes, little-endian) + vendor string.
     - Comment count (4 bytes) + each comment (length + "NAME=value").
   - `func ParseOpusTags(data []byte) (*OpusTags, error)` - parse from bytes.

   **Default values**:
   ```go
   const DefaultPreSkip = 312  // Standard Opus encoder lookahead at 48kHz
   ```

2. **ogg_test.go**: Comprehensive tests.
   - TestOggCRC: Verify CRC matches known values.
   - TestBuildSegmentTable: Test packets of various sizes (1, 100, 255, 256, 510, 1000 bytes).
   - TestParseSegmentTable: Round-trip segment table parsing.
   - TestPageEncode: Verify page encoding produces valid Ogg page.
   - TestParsePage: Parse encoded page and verify fields match.
   - TestOpusHeadFamily0: Encode/parse mono and stereo headers.
   - TestOpusHeadFamily1: Encode/parse 5.1 and 7.1 surround headers.
   - TestOpusTags: Encode/parse with vendor and comments.
   - TestOpusHeadRoundTrip: Encode then parse, verify fields match.

Reference the working multistream header code from internal/multistream/libopus_test.go (lines 99-130).
  </action>
  <verify>
    go test -v ./container/ogg/...
    # All tests pass
  </verify>
  <done>
    - OpusHead encodes to correct byte format per RFC 7845
    - OpusHead parses correctly for all mapping families (0, 1, 255)
    - OpusTags encodes with vendor string and comments
    - All round-trip tests pass (encode then parse produces same values)
    - Tests cover edge cases (large packets, maximum channels)
  </done>
</task>

<task type="auto">
  <name>Task 3: Add page CRC verification and segment continuation</name>
  <files>
    container/ogg/page.go
    container/ogg/ogg_test.go
  </files>
  <action>
Add CRC verification for parsing and handle packet continuation across pages:

1. **page.go enhancements**:
   - `func ParsePage(data []byte) (*Page, int, error)` - MUST verify CRC.
     - Read 27-byte header.
     - Verify "OggS" magic.
     - Read segment table.
     - Read payload.
     - Compute CRC over entire page (with CRC field zeroed).
     - Return ErrBadCRC if mismatch.
   - `func (p *Page) PacketLengths() []int` - extract packet lengths from segment table.
     - Segments with value 255 continue to next segment.
     - Segment with value < 255 ends the packet.
     - Handle continuation flag (HeaderType & PageFlagContinuation).
   - `func (p *Page) Packets() [][]byte` - extract individual packets from payload.
     - Use PacketLengths() to split payload.
   - Add helper: `func (p *Page) IsBOS() bool`, `func (p *Page) IsEOS() bool`.

2. **ogg_test.go additional tests**:
   - TestParsePage_BadCRC: Corrupt CRC byte, verify ErrBadCRC returned.
   - TestParsePage_Truncated: Short data, verify error.
   - TestPagePackets_MultiplePackets: Page with 2-3 packets.
   - TestPagePackets_LargePacket: Packet > 255 bytes spanning multiple segments.
   - TestPagePackets_Continuation: Packet split across two pages (continuation flag).

3. **Validate with known-good data**:
   - Create a test that builds an Ogg page the same way as internal/celt/crossval_test.go
   - Verify the output matches byte-for-byte.
  </action>
  <verify>
    go test -v ./container/ogg/...
    go test -v -run TestParsePage ./container/ogg/...
  </verify>
  <done>
    - ParsePage verifies CRC and returns ErrBadCRC on mismatch
    - Page.Packets() correctly extracts packets from payload
    - Packet continuation across segments works correctly
    - All tests pass including edge cases
  </done>
</task>

</tasks>

<verification>
# Build verification
go build ./container/ogg/...

# Run all tests
go test -v ./container/ogg/...

# Verify CRC matches existing test code
# Compare CRC output with internal/celt/crossval_test.go computeOggCRC
</verification>

<success_criteria>
1. container/ogg package compiles with zero errors
2. Ogg CRC-32 produces correct checksums (verified against existing test code)
3. Page encoding produces valid Ogg pages starting with "OggS"
4. Page parsing verifies CRC and extracts packets correctly
5. OpusHead handles all mapping families (0, 1, 255)
6. OpusTags encodes/parses vendor and comments
7. All round-trip tests pass
8. Segment table handles packets of any size (including > 255 bytes)
</success_criteria>

<output>
After completion, create `.planning/phases/11-container/11-01-SUMMARY.md`
</output>
