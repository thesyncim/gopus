---
phase: 08-hybrid-encoder-controls
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - packet.go
  - internal/encoder/packet.go
  - internal/encoder/encoder.go
autonomous: true

must_haves:
  truths:
    - "Encoder produces complete Opus packets with TOC byte"
    - "TOC byte correctly encodes mode, bandwidth, stereo flag, and frame code"
    - "Hybrid mode packets use configs 12-15 per RFC 6716"
    - "Multi-frame packets (code 3) can be assembled"
  artifacts:
    - path: "packet.go"
      provides: "GenerateTOC function"
      exports: ["GenerateTOC"]
    - path: "internal/encoder/packet.go"
      provides: "Packet assembly with TOC and frame data"
      exports: ["BuildPacket", "BuildMultiFramePacket"]
  key_links:
    - from: "internal/encoder/packet.go"
      to: "packet.go"
      via: "TOC generation"
      pattern: "GenerateTOC|configTable"
    - from: "internal/encoder/encoder.go"
      to: "internal/encoder/packet.go"
      via: "packet assembly"
      pattern: "BuildPacket"
---

<objective>
Implement TOC byte generation and packet assembly for encoded frames.

Purpose: Every Opus packet starts with a TOC (Table of Contents) byte that tells the decoder what mode, bandwidth, stereo flag, and frame code to use. This plan completes packet formatting so encoded data is valid Opus packets.

Output: Complete packet assembly with TOC byte generation supporting all modes (SILK, Hybrid, CELT).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-hybrid-encoder-controls/08-RESEARCH.md

# Existing TOC parsing (to match)
@packet.go

# Encoder to integrate with
@internal/encoder/encoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: TOC Byte Generation</name>
  <files>packet.go</files>
  <action>
Add TOC byte generation to packet.go alongside the existing ParseTOC function.

The TOC byte format per RFC 6716 Section 3.1:
- Bits 7-3: Config (0-31)
- Bit 2: Stereo flag (0=mono, 1=stereo)
- Bits 1-0: Frame code (0-3)

Add function:
```go
// GenerateTOC creates a TOC byte from encoding parameters.
// config: Configuration index 0-31 (from configTable)
// stereo: True for stereo, false for mono
// frameCode: Frame count code 0-3
//   0: 1 frame
//   1: 2 equal-sized frames
//   2: 2 different-sized frames
//   3: arbitrary number of frames
func GenerateTOC(config uint8, stereo bool, frameCode uint8) byte {
    toc := (config & 0x1F) << 3
    if stereo {
        toc |= 0x04
    }
    toc |= frameCode & 0x03
    return toc
}

// ConfigFromParams returns the config index for given mode, bandwidth, and frame size.
// Returns -1 if the combination is invalid.
func ConfigFromParams(mode Mode, bandwidth Bandwidth, frameSize int) int {
    // Search configTable for matching entry
    for i, entry := range configTable {
        if entry.Mode == mode && entry.Bandwidth == bandwidth && entry.FrameSize == frameSize {
            return i
        }
    }
    return -1
}
```

The configTable already exists in packet.go, so ConfigFromParams just needs to search it.

Also add validation function:
```go
// ValidConfig returns true if the configuration index is valid.
func ValidConfig(config uint8) bool {
    return config < 32
}
```
  </action>
  <verify>
`go build ./...` compiles.
`go test -run TestGenerateTOC ./...` passes (create in packet_test.go).
GenerateTOC + ParseTOC round-trip produces identical values.
  </verify>
  <done>TOC generation function exists and round-trips correctly with ParseTOC</done>
</task>

<task type="auto">
  <name>Task 2: Packet Assembly</name>
  <files>internal/encoder/packet.go</files>
  <action>
Create packet assembly functions that combine TOC byte with encoded frame data.

Implement:
```go
package encoder

import "gopus"

// BuildPacket creates a complete Opus packet from encoded frame data.
// Uses frame code 0 (single frame).
func BuildPacket(frameData []byte, mode gopus.Mode, bandwidth gopus.Bandwidth, frameSize int, stereo bool) ([]byte, error) {
    config := gopus.ConfigFromParams(mode, bandwidth, frameSize)
    if config < 0 {
        return nil, ErrInvalidConfig
    }

    toc := gopus.GenerateTOC(uint8(config), stereo, 0)

    // Packet = TOC + frame data
    packet := make([]byte, 1+len(frameData))
    packet[0] = toc
    copy(packet[1:], frameData)

    return packet, nil
}

// BuildMultiFramePacket creates a packet with multiple frames (code 3).
// frames: slice of encoded frame data
// vbr: true for variable bitrate (different frame sizes), false for CBR
func BuildMultiFramePacket(frames [][]byte, mode gopus.Mode, bandwidth gopus.Bandwidth, frameSize int, stereo bool, vbr bool) ([]byte, error) {
    if len(frames) == 0 || len(frames) > 48 {
        return nil, ErrInvalidFrameCount
    }

    config := gopus.ConfigFromParams(mode, bandwidth, frameSize)
    if config < 0 {
        return nil, ErrInvalidConfig
    }

    toc := gopus.GenerateTOC(uint8(config), stereo, 3) // Code 3

    // Frame count byte: VBR flag | padding flag | count
    var countByte byte
    if vbr {
        countByte |= 0x80 // VBR bit
    }
    countByte |= byte(len(frames) & 0x3F)

    // Calculate total size
    headerSize := 2 // TOC + count
    if vbr {
        // Add frame length bytes for all but last frame
        for i := 0; i < len(frames)-1; i++ {
            headerSize += frameLengthBytes(len(frames[i]))
        }
    }

    totalFrameSize := 0
    for _, f := range frames {
        totalFrameSize += len(f)
    }

    packet := make([]byte, headerSize+totalFrameSize)
    packet[0] = toc
    packet[1] = countByte

    offset := 2
    if vbr {
        // Write frame lengths for all but last
        for i := 0; i < len(frames)-1; i++ {
            n := writeFrameLength(packet[offset:], len(frames[i]))
            offset += n
        }
    }

    // Write frame data
    for _, f := range frames {
        copy(packet[offset:], f)
        offset += len(f)
    }

    return packet, nil
}

// frameLengthBytes returns number of bytes needed to encode frame length.
func frameLengthBytes(length int) int {
    if length < 252 {
        return 1
    }
    return 2
}

// writeFrameLength writes frame length at offset, returns bytes written.
func writeFrameLength(dst []byte, length int) int {
    if length < 252 {
        dst[0] = byte(length)
        return 1
    }
    // Two-byte encoding: length = 4*secondByte + firstByte
    // where firstByte >= 252
    dst[0] = byte(252 + (length % 4))
    dst[1] = byte((length - 252) / 4)
    return 2
}
```

Error types:
```go
var (
    ErrInvalidConfig     = errors.New("encoder: invalid config for mode/bandwidth/frameSize")
    ErrInvalidFrameCount = errors.New("encoder: frame count must be 1-48")
)
```
  </action>
  <verify>
`go build ./internal/encoder/` compiles.
`go test -run TestBuildPacket ./internal/encoder/` passes.
  </verify>
  <done>Packet assembly functions exist for single and multi-frame packets</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Packet Assembly into Encoder</name>
  <files>internal/encoder/encoder.go, internal/encoder/encoder_test.go</files>
  <action>
Update Encoder.Encode() to return complete Opus packets with TOC byte.

Modify Encode() to use BuildPacket:
```go
func (e *Encoder) Encode(pcm []float64, frameSize int) ([]byte, error) {
    var frameData []byte
    var err error

    switch e.mode {
    case ModeSILK:
        frameData, err = e.encodeSILKFrame(pcm, frameSize)
    case ModeHybrid:
        frameData, err = e.encodeHybridFrame(pcm, frameSize)
    case ModeCELT:
        frameData, err = e.encodeCELTFrame(pcm, frameSize)
    case ModeAuto:
        frameData, err = e.encodeAutoFrame(pcm, frameSize)
    }
    if err != nil {
        return nil, err
    }

    // Build complete packet with TOC
    stereo := e.channels == 2
    return BuildPacket(frameData, e.mode, e.bandwidth, frameSize, stereo)
}
```

Add tests:
```go
func TestEncoderPacketFormat(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeHybrid)
    enc.SetBandwidth(gopus.BandwidthSuperwideband)

    pcm := make([]float64, 960)
    packet, err := enc.Encode(pcm, 960)
    require.NoError(t, err)
    require.NotEmpty(t, packet)

    // Parse TOC to verify format
    toc := gopus.ParseTOC(packet[0])
    assert.Equal(t, gopus.ModeHybrid, toc.Mode)
    assert.Equal(t, gopus.BandwidthSuperwideband, toc.Bandwidth)
    assert.Equal(t, 960, toc.FrameSize)
    assert.False(t, toc.Stereo)
    assert.Equal(t, uint8(0), toc.FrameCode) // Single frame
}

func TestEncoderPacketConfigs(t *testing.T) {
    tests := []struct {
        mode      Mode
        bandwidth gopus.Bandwidth
        frameSize int
        config    uint8
    }{
        {ModeHybrid, gopus.BandwidthSuperwideband, 480, 12},
        {ModeHybrid, gopus.BandwidthSuperwideband, 960, 13},
        {ModeHybrid, gopus.BandwidthFullband, 480, 14},
        {ModeHybrid, gopus.BandwidthFullband, 960, 15},
        {ModeSILK, gopus.BandwidthNarrowband, 960, 1},
        {ModeCELT, gopus.BandwidthFullband, 960, 31},
    }

    for _, tt := range tests {
        t.Run(fmt.Sprintf("%v-%v-%d", tt.mode, tt.bandwidth, tt.frameSize), func(t *testing.T) {
            enc := NewEncoder(48000, 1)
            enc.SetMode(tt.mode)
            enc.SetBandwidth(tt.bandwidth)

            pcm := make([]float64, tt.frameSize)
            packet, err := enc.Encode(pcm, tt.frameSize)
            require.NoError(t, err)

            toc := gopus.ParseTOC(packet[0])
            assert.Equal(t, tt.config, toc.Config)
        })
    }
}
```
  </action>
  <verify>
`go test -v ./internal/encoder/` passes all tests.
Encoded packets have valid TOC bytes that ParseTOC can decode.
  </verify>
  <done>Encoder.Encode() returns complete Opus packets with TOC byte</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./...` compiles
2. `go test -v ./...` passes
3. GenerateTOC + ParseTOC round-trip works
4. Encoder output packets are parseable by ParsePacket
5. Config indices match RFC 6716 table (12-15 for hybrid)
</verification>

<success_criteria>
- GenerateTOC and ConfigFromParams functions exist in packet.go
- BuildPacket and BuildMultiFramePacket work for all modes
- Encoder.Encode() returns complete Opus packets
- TOC byte correctly identifies mode, bandwidth, stereo, frame code
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-hybrid-encoder-controls/08-02-SUMMARY.md`
</output>
