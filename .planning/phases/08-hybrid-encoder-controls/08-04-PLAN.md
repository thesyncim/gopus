---
phase: 08-hybrid-encoder-controls
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - internal/encoder/fec.go
  - internal/encoder/encoder.go
  - internal/encoder/encoder_test.go
autonomous: true

must_haves:
  truths:
    - "In-band FEC encodes redundant LBRR data when enabled"
    - "FEC uses existing SILK LBRR tables (ICDFLBRRFlag)"
    - "Previous frame is encoded at reduced quality for loss recovery"
    - "FEC can be toggled on/off dynamically"
  artifacts:
    - path: "internal/encoder/fec.go"
      provides: "In-band FEC (LBRR) encoding"
      exports: ["encodeLBRR", "writeLBRRFrame"]
  key_links:
    - from: "internal/encoder/fec.go"
      to: "internal/silk/tables.go"
      via: "LBRR ICDF tables"
      pattern: "ICDFLBRRFlag|ICDFLBRRFlags"
    - from: "internal/encoder/encoder.go"
      to: "internal/encoder/fec.go"
      via: "FEC encoding call"
      pattern: "encodeFEC|fecEnabled"
---

<objective>
Implement in-band Forward Error Correction (FEC) using SILK's LBRR mechanism.

Purpose: FEC enables loss recovery by encoding a low-bitrate redundant copy of the previous frame within the current packet. When packets are lost, the decoder can recover using the LBRR data from the next packet. This is critical for real-time voice over lossy networks.

Output: Encoder with FEC capability that uses existing SILK LBRR tables.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-hybrid-encoder-controls/08-RESEARCH.md

# Existing LBRR tables
@internal/silk/tables.go

# SILK encoder
@internal/silk/encoder.go

# Range encoder
@internal/rangecoding/encoder.go

# Encoder to extend
@internal/encoder/encoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: FEC Types and Constants</name>
  <files>internal/encoder/fec.go</files>
  <action>
Create FEC-related types and helper functions.

```go
package encoder

import (
    "gopus/internal/silk"
)

// FEC Constants
const (
    // LBRRBitrateFactor is the bitrate reduction for LBRR encoding.
    // LBRR uses ~60% of normal SILK bitrate.
    LBRRBitrateFactor = 0.6

    // MinPacketLossForFEC is the minimum expected loss to enable FEC.
    // Below this, FEC overhead isn't worth it.
    MinPacketLossForFEC = 1

    // MaxPacketLossForFEC is where FEC becomes less effective.
    // Above this, increasing primary bitrate is better.
    MaxPacketLossForFEC = 50
)

// fecState holds state for FEC encoding.
type fecState struct {
    // Previous frame data for LBRR encoding
    prevFrame []float32

    // VAD flag from previous frame
    prevVADFlag bool

    // Frame count for multi-frame LBRR selection
    frameCount int
}

// newFECState creates initial FEC state.
func newFECState() *fecState {
    return &fecState{
        prevFrame:   nil,
        prevVADFlag: false,
        frameCount:  0,
    }
}

// shouldUseFEC determines if FEC should be used for this frame.
func (e *Encoder) shouldUseFEC() bool {
    if !e.fecEnabled {
        return false
    }

    // Need previous frame for LBRR
    if e.fec.prevFrame == nil {
        return false
    }

    // Check packet loss threshold
    if e.packetLoss < MinPacketLossForFEC {
        return false
    }

    return true
}

// computeLBRRBitrate calculates bitrate for LBRR encoding.
func computeLBRRBitrate(normalBitrate int) int {
    lbrrBitrate := int(float64(normalBitrate) * LBRRBitrateFactor)
    if lbrrBitrate < silk.MinSILKBitrate {
        return silk.MinSILKBitrate
    }
    return lbrrBitrate
}
```

Note: You may need to add `MinSILKBitrate` constant to silk package if it doesn't exist. Use 6000 (6 kbps) as the value.
  </action>
  <verify>
`go build ./internal/encoder/` compiles.
FEC types and constants defined.
  </verify>
  <done>FEC types, constants, and helper functions exist</done>
</task>

<task type="auto">
  <name>Task 2: LBRR Encoding Implementation</name>
  <files>internal/encoder/fec.go</files>
  <action>
Implement LBRR (Low BitRate Redundancy) encoding.

```go
// encodeLBRR encodes the previous frame at reduced bitrate for FEC.
// This produces the LBRR data that appears in the current packet.
func (e *Encoder) encodeLBRR(re *rangecoding.Encoder) error {
    if e.fec.prevFrame == nil {
        return nil
    }

    // Encode LBRR flag (1 = LBRR present)
    // Uses ICDFLBRRFlag table: [256, 205, 0]
    // Symbol 1 (~80% probability of LBRR present when FEC enabled)
    re.EncodeICDF16(1, silk.ICDFLBRRFlag, 8)

    // Encode LBRR frame at reduced quality
    // LBRR uses simpler encoding:
    // - Same frame type as original
    // - Reduced precision for gains
    // - Simpler pitch encoding
    // - Shell-coded excitation at lower rate

    // For v1, encode a minimal LBRR frame
    e.writeLBRRFrame(re)

    return nil
}

// writeLBRRFrame writes LBRR frame data to the range encoder.
// LBRR frames are encoded similarly to regular SILK frames but at lower quality.
func (e *Encoder) writeLBRRFrame(re *rangecoding.Encoder) {
    // Get bandwidth config for frame duration
    bw := silk.BandwidthWideband // SILK in hybrid uses WB

    // Encode LBRR frame type (voiced/unvoiced)
    // Simplified: always use voiced type (symbol 1)
    re.EncodeICDF16(1, silk.ICDFFrameType, 8)

    // Encode gain at reduced precision
    // LBRR uses coarser gain quantization
    // For v1: write a fixed mid-range gain index
    gainIndex := 32 // Mid-range gain
    re.EncodeICDF16(uint32(gainIndex), silk.ICDFGainHighBits, 8)
    re.EncodeICDF16(0, silk.ICDFGainLowBits, 8)

    // Encode LSF indices (simplified for LBRR)
    // Use stage1 only, skip stage2 for reduced bitrate
    stage1Index := 0 // Safe default
    for i := 0; i < 2; i++ { // 2 LSF splits
        re.EncodeICDF16(uint32(stage1Index), silk.GetICDFLSFStage1(bw, i == 0), 8)
    }

    // Skip LTP for LBRR (unvoiced mode simplification)
    // Write pitch lag low bits only
    re.EncodeICDF16(0, silk.ICDFPitchLag, 8)

    // Minimal excitation: encode as mostly zeros
    // Shell coding with all-zero pulses
    // Write pulse count = 0 for each shell region
    for i := 0; i < 4; i++ { // 4 shell regions typical
        re.EncodeICDF16(0, silk.ICDFShellBlock, 8)
    }
}

// skipLBRR writes the LBRR flag indicating no FEC data.
func (e *Encoder) skipLBRR(re *rangecoding.Encoder) {
    // Symbol 0 = no LBRR present
    re.EncodeICDF16(0, silk.ICDFLBRRFlag, 8)
}

// updateFECState saves current frame for next LBRR encoding.
func (e *Encoder) updateFECState(pcm []float32, vadFlag bool) {
    if e.fec.prevFrame == nil || len(e.fec.prevFrame) != len(pcm) {
        e.fec.prevFrame = make([]float32, len(pcm))
    }
    copy(e.fec.prevFrame, pcm)
    e.fec.prevVADFlag = vadFlag
    e.fec.frameCount++
}
```

Note: You may need to export or add some SILK ICDF tables (ICDFFrameType, ICDFGainHighBits, ICDFGainLowBits, ICDFLSFStage1, ICDFPitchLag, ICDFShellBlock). Check silk/tables.go for existing tables with similar names and use appropriate ones.
  </action>
  <verify>
`go build ./internal/encoder/` compiles.
encodeLBRR and writeLBRRFrame functions exist.
  </verify>
  <done>LBRR encoding functions implemented</done>
</task>

<task type="auto">
  <name>Task 3: Integrate FEC into Encoder</name>
  <files>internal/encoder/encoder.go, internal/encoder/encoder_test.go</files>
  <action>
Add FEC fields and control methods to the Encoder.

Add to Encoder struct:
```go
type Encoder struct {
    // ... existing fields ...

    // FEC controls
    fecEnabled bool
    packetLoss int // Expected packet loss percentage (0-100)
    fec        *fecState
}
```

Add methods:
```go
// SetFEC enables or disables in-band Forward Error Correction.
// When enabled, the encoder includes LBRR data for loss recovery.
func (e *Encoder) SetFEC(enabled bool) {
    e.fecEnabled = enabled
    if enabled && e.fec == nil {
        e.fec = newFECState()
    }
}

// FECEnabled returns whether FEC is enabled.
func (e *Encoder) FECEnabled() bool {
    return e.fecEnabled
}

// SetPacketLoss sets the expected packet loss percentage (0-100).
// This affects FEC behavior and bitrate allocation.
func (e *Encoder) SetPacketLoss(lossPercent int) {
    if lossPercent < 0 {
        lossPercent = 0
    }
    if lossPercent > 100 {
        lossPercent = 100
    }
    e.packetLoss = lossPercent
}

// PacketLoss returns the expected packet loss percentage.
func (e *Encoder) PacketLoss() int {
    return e.packetLoss
}
```

Update NewEncoder:
```go
func NewEncoder(sampleRate, channels int) *Encoder {
    return &Encoder{
        // ... existing fields ...
        fecEnabled: false,
        packetLoss: 0,
        fec:        newFECState(),
    }
}
```

Modify encoding to include FEC when enabled (in SILK and Hybrid modes):
```go
func (e *Encoder) encodeSILKFrame(pcm []float64, frameSize int) ([]byte, error) {
    // ... existing SILK encoding ...

    // Write LBRR flag and data if FEC enabled
    if e.shouldUseFEC() {
        e.encodeLBRR(re)
    } else {
        e.skipLBRR(re)
    }

    // Continue with regular SILK frame...

    // Save current frame for next LBRR
    e.updateFECState(silkInput, vadFlag)

    // ...
}
```

Add tests:
```go
func TestFECEnabled(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeHybrid)
    enc.SetBandwidth(gopus.BandwidthSuperwideband)

    // Verify default
    assert.False(t, enc.FECEnabled())

    // Enable FEC
    enc.SetFEC(true)
    assert.True(t, enc.FECEnabled())

    // Disable FEC
    enc.SetFEC(false)
    assert.False(t, enc.FECEnabled())
}

func TestFECPacketLoss(t *testing.T) {
    enc := NewEncoder(48000, 1)

    // Test clamping
    enc.SetPacketLoss(-10)
    assert.Equal(t, 0, enc.PacketLoss())

    enc.SetPacketLoss(150)
    assert.Equal(t, 100, enc.PacketLoss())

    enc.SetPacketLoss(20)
    assert.Equal(t, 20, enc.PacketLoss())
}

func TestFECEncodingProducesLargerPackets(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeSILK)
    enc.SetBandwidth(gopus.BandwidthWideband)

    pcm1 := generateTestSignal(960)
    pcm2 := generateTestSignal(960)

    // Encode without FEC
    enc.SetFEC(false)
    enc.Encode(pcm1, 960) // Prime state
    packetNoFEC, err := enc.Encode(pcm2, 960)
    require.NoError(t, err)

    // Reset and encode with FEC
    enc.Reset()
    enc.SetFEC(true)
    enc.SetPacketLoss(10)
    enc.Encode(pcm1, 960) // Prime state
    packetWithFEC, err := enc.Encode(pcm2, 960)
    require.NoError(t, err)

    // FEC packets should be larger due to LBRR data
    t.Logf("No FEC: %d bytes, With FEC: %d bytes",
        len(packetNoFEC), len(packetWithFEC))
    // Note: First frame won't have FEC (no previous frame)
    // Second frame onwards should be larger with FEC
}

func TestFECOnlyWithPreviousFrame(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeSILK)
    enc.SetFEC(true)
    enc.SetPacketLoss(10)

    // First frame - no FEC possible (no previous frame)
    assert.False(t, enc.shouldUseFEC())

    // Encode first frame to populate state
    pcm := generateTestSignal(960)
    enc.Encode(pcm, 960)

    // Second frame - FEC should be possible
    assert.True(t, enc.shouldUseFEC())
}
```
  </action>
  <verify>
`go test -v ./internal/encoder/ -run TestFEC` passes all tests.
FEC control methods work correctly.
  </verify>
  <done>FEC integrated into encoder with enable/disable and packet loss settings</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./internal/encoder/` compiles
2. `go test -v ./internal/encoder/` passes all tests
3. SetFEC and SetPacketLoss methods work
4. FEC is only applied when enabled AND packet loss > 0 AND previous frame exists
5. LBRR encoding uses SILK ICDF tables
</verification>

<success_criteria>
- SetFEC and SetPacketLoss methods exist
- FEC only activates with enabled + packet loss + previous frame
- LBRR encoding writes data using SILK tables
- FEC can be toggled dynamically
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-hybrid-encoder-controls/08-04-SUMMARY.md`
</output>
