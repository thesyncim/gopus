---
phase: 08-hybrid-encoder-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/encoder/encoder.go
  - internal/encoder/hybrid.go
  - internal/encoder/encoder_test.go
autonomous: true

must_haves:
  truths:
    - "Encoder can produce hybrid mode packets with SILK+CELT data"
    - "SILK encodes first, CELT encodes second (RFC 6716 order)"
    - "Encoder handles both 10ms and 20ms hybrid frame sizes"
    - "Mono and stereo hybrid encoding both produce valid packets"
  artifacts:
    - path: "internal/encoder/encoder.go"
      provides: "Unified Encoder struct with mode selection"
      exports: ["Encoder", "NewEncoder", "Mode", "ModeAuto", "ModeSILK", "ModeHybrid", "ModeCELT"]
    - path: "internal/encoder/hybrid.go"
      provides: "Hybrid mode encoding with SILK+CELT coordination"
      exports: ["encodeHybridFrame", "downsample48to16"]
    - path: "internal/encoder/encoder_test.go"
      provides: "Unit tests for hybrid encoding"
      min_lines: 150
  key_links:
    - from: "internal/encoder/encoder.go"
      to: "internal/silk/encoder.go"
      via: "silkEncoder field"
      pattern: "silk\\.NewEncoder"
    - from: "internal/encoder/encoder.go"
      to: "internal/celt/encoder.go"
      via: "celtEncoder field"
      pattern: "celt\\.NewEncoder"
    - from: "internal/encoder/hybrid.go"
      to: "internal/rangecoding/encoder.go"
      via: "shared range encoder"
      pattern: "rangecoding\\.Encoder"
---

<objective>
Create the unified Opus encoder with hybrid mode encoding capability.

Purpose: The unified encoder orchestrates SILK and CELT sub-encoders for hybrid mode, which combines SILK (0-8kHz) with CELT (8-20kHz) for super-wideband and fullband speech encoding. This is the foundation for all Phase 8 encoder controls.

Output: New `internal/encoder/` package with Encoder struct capable of hybrid mode encoding.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-hybrid-encoder-controls/08-RESEARCH.md

# Phase dependencies - SILK and CELT encoders
@internal/silk/encoder.go
@internal/silk/silk_encode.go
@internal/celt/encoder.go
@internal/celt/celt_encode.go

# Reference - hybrid decoder coordination logic
@internal/hybrid/decoder.go

# Range coder for shared encoding
@internal/rangecoding/encoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unified Encoder Struct</name>
  <files>internal/encoder/encoder.go</files>
  <action>
Create the unified Encoder struct that orchestrates SILK and CELT sub-encoders.

The encoder must support three modes:
- ModeSILK: SILK-only encoding (configs 0-11)
- ModeHybrid: Combined SILK+CELT (configs 12-15)
- ModeCELT: CELT-only encoding (configs 16-31)
- ModeAuto: Automatic mode selection based on bandwidth/bitrate

Key struct fields:
```go
type Encoder struct {
    // Sub-encoders (created lazily)
    silkEncoder *silk.Encoder
    celtEncoder *celt.Encoder

    // Configuration
    mode         Mode
    bandwidth    gopus.Bandwidth  // NB, MB, WB, SWB, FB
    sampleRate   int              // 8000-48000
    channels     int              // 1 or 2
    frameSize    int              // In samples at 48kHz

    // Encoder state
    prevSamples  []float64        // For CELT delay compensation
}
```

Implement:
1. `NewEncoder(sampleRate, channels int) *Encoder` - Initialize with defaults
2. `SetMode(mode Mode)` - Force specific mode
3. `SetBandwidth(bandwidth Bandwidth)` - Set target bandwidth
4. `SetFrameSize(frameSize int)` - Set frame size (480 or 960 for hybrid)
5. `Encode(pcm []float64, frameSize int) ([]byte, error)` - Main encode method
6. `Reset()` - Reset encoder state
7. `Channels() int` - Return channel count

Mode selection logic for ModeAuto:
- FB/SWB with speech-like content: ModeHybrid
- WB/MB/NB: ModeSILK
- FB with music-like content: ModeCELT

Reference packet.go for bandwidth constants (gopus.BandwidthNarrowband, etc.).

Do NOT implement TOC byte generation yet - that's Plan 2. Just return the raw encoded frame data.
  </action>
  <verify>
`go build ./internal/encoder/` compiles without errors.
`go test -run TestNewEncoder ./internal/encoder/` passes (create basic constructor test).
  </verify>
  <done>Encoder struct with mode selection and basic Encode() method exists</done>
</task>

<task type="auto">
  <name>Task 2: Hybrid Mode Encoding</name>
  <files>internal/encoder/hybrid.go</files>
  <action>
Implement hybrid mode encoding that coordinates SILK and CELT with a shared range encoder.

Key implementation requirements per RFC 6716 Section 3.2.1:
1. SILK encodes FIRST, CELT encodes SECOND (order matters!)
2. Both use the same range encoder (sequential data output)
3. SILK operates at WB (16kHz) - downsample input from 48kHz
4. CELT encodes bands 17-21 only (8-20kHz) - use hybrid mode
5. Apply 2.7ms delay (130 samples at 48kHz) to CELT input for alignment

Implement:
```go
func (e *Encoder) encodeHybridFrame(pcm []float64, frameSize int) ([]byte, error) {
    // Validate: only 480 (10ms) or 960 (20ms) for hybrid
    if frameSize != 480 && frameSize != 960 {
        return nil, ErrInvalidHybridFrameSize
    }

    // Initialize shared range encoder
    maxBytes := e.computeMaxPacketSize()
    buf := make([]byte, maxBytes)
    re := rangecoding.NewEncoder(buf)

    // Step 1: Downsample 48kHz -> 16kHz for SILK
    silkInput := downsample48to16(pcm)

    // Step 2: SILK encodes first (uses shared range encoder)
    // SILK in hybrid mode always uses WB (16kHz)
    vadFlag := true  // Default to voice active for now
    silkDuration := silk.Frame10ms
    if frameSize == 960 {
        silkDuration = silk.Frame20ms
    }
    e.silkEncoder.EncodeFrameToEncoder(silkInput, vadFlag, silkDuration, re)

    // Step 3: Apply CELT delay compensation (130 samples)
    celtInput := e.applyInputDelay(pcm)

    // Step 4: CELT encodes high frequencies (bands 17-21)
    // Pass remaining bit budget after SILK
    e.celtEncoder.EncodeFrameHybridToEncoder(celtInput, frameSize, re)

    // Finalize
    return re.Done(), nil
}
```

Also implement:
- `downsample48to16(samples []float64) []float32` - 3:1 decimation with anti-aliasing
- `(e *Encoder) applyInputDelay(pcm []float64) []float64` - Shift buffer for CELT delay

Note: You'll need to add methods to SILK and CELT encoders that accept an external range encoder rather than creating their own. Add stub methods if the existing encoders don't support this yet:
- `silk.Encoder.EncodeFrameToEncoder(pcm []float32, vadFlag bool, duration FrameDuration, re *rangecoding.Encoder)`
- `celt.Encoder.EncodeFrameHybridToEncoder(pcm []float64, frameSize int, re *rangecoding.Encoder)`

For v1, these can be minimal implementations that write basic data to the shared encoder.
  </action>
  <verify>
`go build ./internal/encoder/` compiles without errors.
Hybrid frame output has non-zero length.
  </verify>
  <done>Hybrid encoding produces bytes with SILK data followed by CELT data</done>
</task>

<task type="auto">
  <name>Task 3: Hybrid Encoder Tests</name>
  <files>internal/encoder/encoder_test.go</files>
  <action>
Create comprehensive tests for the hybrid encoder.

Test cases:
1. `TestNewEncoder` - Constructor creates valid encoder
2. `TestEncoderSetMode` - Mode selection works
3. `TestHybridEncode10ms` - 480-sample hybrid frame encodes
4. `TestHybridEncode20ms` - 960-sample hybrid frame encodes
5. `TestHybridEncodeMono` - Mono hybrid encoding
6. `TestHybridEncodeStereo` - Stereo hybrid encoding
7. `TestHybridRoundTrip` - Encode with unified encoder, decode with hybrid.Decoder
8. `TestInvalidHybridFrameSize` - 120, 240 samples return error for hybrid

For round-trip test:
```go
func TestHybridRoundTrip(t *testing.T) {
    enc := encoder.NewEncoder(48000, 1)
    enc.SetMode(encoder.ModeHybrid)
    enc.SetBandwidth(gopus.BandwidthSuperwideband)

    // Generate test signal (sine wave + noise)
    pcm := generateTestSignal(960)

    // Encode
    encoded, err := enc.Encode(pcm, 960)
    require.NoError(t, err)
    require.NotEmpty(t, encoded)

    // Decode using Phase 4 hybrid decoder
    dec := hybrid.NewDecoder(1)
    rd := rangecoding.NewDecoder(encoded)
    decoded, err := dec.DecodeFrame(rd, 960)
    require.NoError(t, err)
    require.Len(t, decoded, 960)

    // Verify output has energy (not silence)
    energy := computeEnergy(decoded)
    assert.Greater(t, energy, 0.01, "decoded signal should have energy")
}
```

Verify signal has energy after decode - matching the pattern from Phase 7 round-trip tests.
  </action>
  <verify>
`go test -v ./internal/encoder/` passes all tests.
At least 8 test functions pass.
  </verify>
  <done>All hybrid encoder tests pass, round-trip verified with hybrid decoder</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./internal/encoder/` compiles
2. `go test -v ./internal/encoder/` shows all tests passing
3. `go test -v ./internal/hybrid/` still passes (no regressions)
4. `go test -v ./internal/silk/` still passes (no regressions)
5. `go test -v ./internal/celt/` still passes (no regressions)
</verification>

<success_criteria>
- internal/encoder/ package exists with Encoder struct
- Encoder supports SILK, Hybrid, and CELT modes
- Hybrid mode encodes SILK first, CELT second (RFC 6716 order)
- Both 10ms (480 samples) and 20ms (960 samples) hybrid frames work
- Round-trip test with hybrid.Decoder produces non-zero signal
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-hybrid-encoder-controls/08-01-SUMMARY.md`
</output>
