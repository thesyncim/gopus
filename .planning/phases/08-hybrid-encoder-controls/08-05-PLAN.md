---
phase: 08-hybrid-encoder-controls
plan: 05
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - internal/encoder/dtx.go
  - internal/encoder/encoder.go
  - internal/encoder/encoder_test.go
autonomous: true

must_haves:
  truths:
    - "DTX mode suppresses packets during silence"
    - "Comfort noise frames sent periodically during DTX"
    - "Complexity setting affects encoder quality/speed tradeoff"
    - "Complexity 0-10 range with sensible defaults"
  artifacts:
    - path: "internal/encoder/dtx.go"
      provides: "DTX implementation and complexity controls"
      exports: ["shouldUseDTX", "encodeComfortNoise"]
  key_links:
    - from: "internal/encoder/dtx.go"
      to: "internal/silk/vad.go"
      via: "VAD for silence detection"
      pattern: "classifyFrame|signalType"
    - from: "internal/encoder/encoder.go"
      to: "internal/encoder/dtx.go"
      via: "DTX control"
      pattern: "dtxEnabled|shouldUseDTX"
---

<objective>
Implement DTX (Discontinuous Transmission) and complexity settings for the encoder.

Purpose: DTX saves bandwidth during silence by not transmitting packets (or transmitting comfort noise frames periodically). Complexity settings allow trading encoder speed for quality. Both are essential controls for production use in VoIP and streaming applications.

Output: Encoder with DTX capability and complexity control (0-10 scale).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-hybrid-encoder-controls/08-RESEARCH.md

# Existing VAD for silence detection
@internal/silk/vad.go

# Encoder to extend
@internal/encoder/encoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: DTX Types and Constants</name>
  <files>internal/encoder/dtx.go</files>
  <action>
Create DTX-related types and helper functions.

```go
package encoder

// DTX Constants
const (
    // DTXComfortNoiseIntervalMs is how often to send comfort noise during DTX.
    // Per Opus convention, send a comfort noise frame every 400ms of silence.
    DTXComfortNoiseIntervalMs = 400

    // DTXFrameThreshold is the number of consecutive silent frames before DTX activates.
    // At 20ms frames: 20 frames = 400ms of silence before DTX mode.
    DTXFrameThreshold = 20

    // DTXFadeInMs is the fade-in duration when exiting DTX mode.
    DTXFadeInMs = 10

    // DTXFadeOutMs is the fade-out duration when entering DTX mode.
    DTXFadeOutMs = 10
)

// dtxState holds state for discontinuous transmission.
type dtxState struct {
    // Consecutive silent frames count
    silentFrameCount int

    // Whether currently in DTX mode
    inDTXMode bool

    // Frames since last comfort noise packet
    framesSinceComfortNoise int

    // Saved filter state for comfort noise
    savedFilterState []float64
}

// newDTXState creates initial DTX state.
func newDTXState() *dtxState {
    return &dtxState{
        silentFrameCount:        0,
        inDTXMode:               false,
        framesSinceComfortNoise: 0,
        savedFilterState:        nil,
    }
}

// resetDTXState resets DTX state when speech resumes.
func (d *dtxState) reset() {
    d.silentFrameCount = 0
    d.inDTXMode = false
    d.framesSinceComfortNoise = 0
}
```
  </action>
  <verify>
`go build ./internal/encoder/` compiles.
DTX types and constants defined.
  </verify>
  <done>DTX types, constants, and state struct exist</done>
</task>

<task type="auto">
  <name>Task 2: DTX Detection and Comfort Noise</name>
  <files>internal/encoder/dtx.go</files>
  <action>
Implement DTX silence detection and comfort noise encoding.

```go
import (
    "gopus/internal/silk"
)

// shouldUseDTX determines if frame should be suppressed (DTX mode).
// Returns: (suppressFrame bool, sendComfortNoise bool)
func (e *Encoder) shouldUseDTX(pcm []float64) (bool, bool) {
    if !e.dtxEnabled {
        return false, false
    }

    // Use SILK VAD to detect silence
    // Signal type 0 = inactive (silence/noise)
    pcm32 := toFloat32(pcm)
    signalType, _ := classifySignal(pcm32)

    if signalType == 0 {
        // Silence detected
        e.dtx.silentFrameCount++

        if e.dtx.silentFrameCount >= DTXFrameThreshold {
            // Enter or stay in DTX mode
            e.dtx.inDTXMode = true
            e.dtx.framesSinceComfortNoise++

            // Send comfort noise periodically
            framesPerInterval := DTXComfortNoiseIntervalMs / 20 // 20ms frames
            if e.dtx.framesSinceComfortNoise >= framesPerInterval {
                e.dtx.framesSinceComfortNoise = 0
                return true, true // Suppress but send comfort noise
            }

            return true, false // Suppress entirely
        }
    } else {
        // Speech detected - exit DTX mode
        e.dtx.reset()
    }

    return false, false
}

// classifySignal determines signal type using energy-based detection.
// Returns: 0 = inactive (silence), 1 = unvoiced, 2 = voiced
func classifySignal(pcm []float32) (int, float32) {
    if len(pcm) == 0 {
        return 0, 0
    }

    // Compute signal energy
    var energy float64
    for _, s := range pcm {
        energy += float64(s) * float64(s)
    }
    energy /= float64(len(pcm))

    // Energy threshold for silence detection
    // -40 dBFS is typical silence threshold
    const silenceThreshold = 0.0001 // ~-40 dBFS

    if energy < silenceThreshold {
        return 0, float32(energy) // Inactive
    }

    // For now, classify as voiced (2) if above threshold
    // Full voicing detection requires pitch analysis
    return 2, float32(energy)
}

// encodeComfortNoise encodes a comfort noise frame.
// Comfort noise provides natural-sounding silence during DTX.
func (e *Encoder) encodeComfortNoise(frameSize int) ([]byte, error) {
    // Generate low-level noise to maintain presence
    noise := make([]float64, frameSize)
    for i := range noise {
        // Very low amplitude noise (-60 dBFS)
        noise[i] = (e.nextRandom() - 0.5) * 0.002
    }

    // Encode at minimum bitrate
    savedBitrate := e.bitrate
    e.bitrate = MinBitrate

    // Encode the comfort noise frame
    packet, err := e.encodeFrame(noise, frameSize)

    // Restore bitrate
    e.bitrate = savedBitrate

    return packet, err
}

// nextRandom returns a random float64 in [0, 1).
// Uses LCG matching libopus for determinism.
func (e *Encoder) nextRandom() float64 {
    e.rng = e.rng*1664525 + 1013904223
    return float64(e.rng) / float64(1<<32)
}

// toFloat32 converts float64 slice to float32.
func toFloat32(pcm []float64) []float32 {
    result := make([]float32, len(pcm))
    for i, v := range pcm {
        result[i] = float32(v)
    }
    return result
}
```
  </action>
  <verify>
`go build ./internal/encoder/` compiles.
shouldUseDTX and encodeComfortNoise functions exist.
  </verify>
  <done>DTX silence detection and comfort noise encoding implemented</done>
</task>

<task type="auto">
  <name>Task 3: Integrate DTX and Complexity into Encoder</name>
  <files>internal/encoder/encoder.go, internal/encoder/encoder_test.go</files>
  <action>
Add DTX and complexity fields and control methods to the Encoder.

Add to Encoder struct:
```go
type Encoder struct {
    // ... existing fields ...

    // DTX controls
    dtxEnabled bool
    dtx        *dtxState
    rng        uint32  // RNG for comfort noise

    // Complexity control
    complexity int  // 0-10, higher = better quality but slower
}
```

Add methods:
```go
// SetDTX enables or disables Discontinuous Transmission.
// When enabled, packets are suppressed during silence.
func (e *Encoder) SetDTX(enabled bool) {
    e.dtxEnabled = enabled
    if enabled && e.dtx == nil {
        e.dtx = newDTXState()
    }
}

// DTXEnabled returns whether DTX is enabled.
func (e *Encoder) DTXEnabled() bool {
    return e.dtxEnabled
}

// SetComplexity sets encoder complexity (0-10).
// Higher values use more CPU for better quality.
// Default is 10 (maximum quality).
//
// Guidelines:
//   0-1: Minimal processing, fastest encoding
//   2-4: Basic analysis, good for real-time with limited CPU
//   5-7: Moderate analysis, balanced quality/speed
//   8-10: Thorough analysis, highest quality
func (e *Encoder) SetComplexity(complexity int) {
    if complexity < 0 {
        complexity = 0
    }
    if complexity > 10 {
        complexity = 10
    }
    e.complexity = complexity

    // Apply complexity to sub-encoders
    // For v1, this affects decision thresholds only
    // Future: affect MDCT precision, pitch search resolution, etc.
}

// Complexity returns the current complexity setting.
func (e *Encoder) Complexity() int {
    return e.complexity
}
```

Update NewEncoder:
```go
func NewEncoder(sampleRate, channels int) *Encoder {
    return &Encoder{
        // ... existing fields ...
        dtxEnabled: false,
        dtx:        newDTXState(),
        rng:        22222,  // Match libopus seed
        complexity: 10,     // Default: highest quality
    }
}
```

Modify Encode() to check DTX:
```go
func (e *Encoder) Encode(pcm []float64, frameSize int) ([]byte, error) {
    // Check DTX mode
    suppressFrame, sendComfortNoise := e.shouldUseDTX(pcm)

    if suppressFrame {
        if sendComfortNoise {
            return e.encodeComfortNoise(frameSize)
        }
        // Return nil to indicate frame suppression
        return nil, nil
    }

    // Normal encoding...
    // ... existing encode logic ...
}
```

Add tests:
```go
func TestDTXEnabled(t *testing.T) {
    enc := NewEncoder(48000, 1)

    // Verify default
    assert.False(t, enc.DTXEnabled())

    // Enable DTX
    enc.SetDTX(true)
    assert.True(t, enc.DTXEnabled())

    // Disable DTX
    enc.SetDTX(false)
    assert.False(t, enc.DTXEnabled())
}

func TestDTXSuppressesSilence(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeSILK)
    enc.SetBandwidth(gopus.BandwidthWideband)
    enc.SetDTX(true)

    // Generate silence
    silence := make([]float64, 960)

    // First few frames should still encode (building up silence count)
    for i := 0; i < DTXFrameThreshold-1; i++ {
        packet, err := enc.Encode(silence, 960)
        require.NoError(t, err)
        assert.NotNil(t, packet, "frame %d should encode before threshold", i)
    }

    // After threshold, frames should be suppressed
    packet, err := enc.Encode(silence, 960)
    require.NoError(t, err)
    assert.Nil(t, packet, "frame after threshold should be suppressed")
}

func TestDTXComfortNoise(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeSILK)
    enc.SetBandwidth(gopus.BandwidthWideband)
    enc.SetDTX(true)

    silence := make([]float64, 960)
    framesPerInterval := DTXComfortNoiseIntervalMs / 20

    // Encode enough frames to enter DTX and reach comfort noise interval
    var comfortNoiseCount int
    for i := 0; i < DTXFrameThreshold+framesPerInterval+5; i++ {
        packet, _ := enc.Encode(silence, 960)
        if i >= DTXFrameThreshold && packet != nil {
            comfortNoiseCount++
        }
    }

    assert.GreaterOrEqual(t, comfortNoiseCount, 1,
        "should send at least one comfort noise packet")
}

func TestDTXExitOnSpeech(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeSILK)
    enc.SetDTX(true)

    silence := make([]float64, 960)
    speech := generateTestSignal(960)

    // Enter DTX mode
    for i := 0; i < DTXFrameThreshold+5; i++ {
        enc.Encode(silence, 960)
    }

    // Verify in DTX mode
    packet, _ := enc.Encode(silence, 960)
    assert.Nil(t, packet)

    // Send speech - should exit DTX
    packet, err := enc.Encode(speech, 960)
    require.NoError(t, err)
    assert.NotNil(t, packet, "speech should exit DTX mode")
}

func TestComplexitySetting(t *testing.T) {
    enc := NewEncoder(48000, 1)

    // Verify default
    assert.Equal(t, 10, enc.Complexity())

    // Test valid range
    enc.SetComplexity(5)
    assert.Equal(t, 5, enc.Complexity())

    // Test clamping
    enc.SetComplexity(-1)
    assert.Equal(t, 0, enc.Complexity())

    enc.SetComplexity(15)
    assert.Equal(t, 10, enc.Complexity())
}

func TestComplexityAffectsQuality(t *testing.T) {
    // This test verifies complexity setting is stored correctly
    // Actual quality differences require more sophisticated testing
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeHybrid)

    for complexity := 0; complexity <= 10; complexity++ {
        enc.SetComplexity(complexity)

        pcm := generateTestSignal(960)
        packet, err := enc.Encode(pcm, 960)
        require.NoError(t, err)
        assert.NotEmpty(t, packet, "complexity %d should produce output", complexity)
    }
}
```
  </action>
  <verify>
`go test -v ./internal/encoder/ -run TestDTX` passes all tests.
`go test -v ./internal/encoder/ -run TestComplexity` passes all tests.
DTX and complexity control methods work correctly.
  </verify>
  <done>DTX and complexity integrated into encoder with tests</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./internal/encoder/` compiles
2. `go test -v ./internal/encoder/` passes all tests
3. SetDTX enables/disables discontinuous transmission
4. DTX suppresses packets after silence threshold
5. Comfort noise sent periodically during DTX
6. SetComplexity sets 0-10 value with clamping
</verification>

<success_criteria>
- SetDTX and SetComplexity methods exist
- DTX detects silence using energy threshold
- Frames suppressed after DTXFrameThreshold consecutive silent frames
- Comfort noise frames sent every DTXComfortNoiseIntervalMs
- Speech exits DTX mode immediately
- Complexity accepts 0-10 range, clamped outside
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-hybrid-encoder-controls/08-05-SUMMARY.md`
</output>
