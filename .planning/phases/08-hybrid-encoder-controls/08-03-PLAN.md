---
phase: 08-hybrid-encoder-controls
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - internal/encoder/controls.go
  - internal/encoder/encoder.go
  - internal/encoder/encoder_test.go
autonomous: true

must_haves:
  truths:
    - "VBR mode produces variable-size packets based on content"
    - "CBR mode produces consistent packet sizes within tolerance"
    - "Bitrate control respects target (6-510 kbps range)"
    - "Constrained VBR allows controlled variation around target"
  artifacts:
    - path: "internal/encoder/controls.go"
      provides: "VBR/CBR mode and bitrate control"
      exports: ["BitrateMode", "ModeVBR", "ModeCVBR", "ModeCBR", "SetBitrateMode", "SetBitrate"]
  key_links:
    - from: "internal/encoder/encoder.go"
      to: "internal/encoder/controls.go"
      via: "bitrate mode methods"
      pattern: "SetBitrateMode|bitrateMode"
    - from: "internal/encoder/controls.go"
      to: "internal/silk/encoder.go"
      via: "SILK bit allocation"
      pattern: "silkEncoder"
    - from: "internal/encoder/controls.go"
      to: "internal/celt/encoder.go"
      via: "CELT bit budget"
      pattern: "celtEncoder"
---

<objective>
Implement VBR/CBR mode switching and bitrate control for the encoder.

Purpose: VBR (Variable Bitrate) allows optimal quality by adapting packet size to content complexity. CBR (Constant Bitrate) ensures predictable bandwidth for streaming. CVBR (Constrained VBR) provides a middle ground. These controls are essential for production use cases.

Output: Encoder with configurable bitrate mode and target bitrate.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-hybrid-encoder-controls/08-RESEARCH.md

# Encoder to extend
@internal/encoder/encoder.go

# SILK bitrate control
@internal/silk/encoder.go

# CELT bitrate control
@internal/celt/encoder.go
@internal/celt/alloc.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bitrate Mode Types and Constants</name>
  <files>internal/encoder/controls.go</files>
  <action>
Create the bitrate control types and helper functions.

```go
package encoder

// BitrateMode specifies how the encoder manages packet sizes.
type BitrateMode int

const (
    // ModeVBR is variable bitrate mode (default).
    // Packet size varies based on content complexity.
    // Provides best quality for a given average bitrate.
    ModeVBR BitrateMode = iota

    // ModeCVBR is constrained variable bitrate mode.
    // Packet size varies but stays within +/-15% of target.
    // Good balance of quality and bandwidth predictability.
    ModeCVBR

    // ModeCBR is constant bitrate mode.
    // Every packet is exactly the same size (or within 1 byte).
    // Required for some streaming protocols.
    ModeCBR
)

// Bitrate limits per RFC 6716
const (
    MinBitrate = 6000   // 6 kbps minimum
    MaxBitrate = 510000 // 510 kbps maximum

    // Mode-specific typical ranges
    SILKMinBitrate   = 6000   // 6 kbps
    SILKMaxBitrate   = 40000  // 40 kbps (WB)
    CELTMinBitrate   = 32000  // 32 kbps
    CELTMaxBitrate   = 510000 // 510 kbps
    HybridMinBitrate = 12000  // 12 kbps
    HybridMaxBitrate = 128000 // 128 kbps typical
)

// CVBR tolerance (percentage)
const CVBRTolerance = 0.15 // +/- 15%

// ValidBitrate returns true if the bitrate is within Opus limits.
func ValidBitrate(bitrate int) bool {
    return bitrate >= MinBitrate && bitrate <= MaxBitrate
}

// ClampBitrate ensures bitrate is within valid range.
func ClampBitrate(bitrate int) int {
    if bitrate < MinBitrate {
        return MinBitrate
    }
    if bitrate > MaxBitrate {
        return MaxBitrate
    }
    return bitrate
}

// frameDurationMs returns frame duration in milliseconds.
func frameDurationMs(frameSize int) int {
    // At 48kHz: 480 samples = 10ms, 960 = 20ms, etc.
    return frameSize * 1000 / 48000
}

// targetBytesForBitrate computes target packet size in bytes.
func targetBytesForBitrate(bitrate, frameSize int) int {
    durationMs := frameDurationMs(frameSize)
    // bitrate is bits/second, convert to bytes/frame
    return (bitrate * durationMs) / 8000
}
```
  </action>
  <verify>
`go build ./internal/encoder/` compiles.
`go test -run TestBitrateLimits ./internal/encoder/` passes.
  </verify>
  <done>BitrateMode type and bitrate helper functions exist</done>
</task>

<task type="auto">
  <name>Task 2: Encoder Bitrate Control Methods</name>
  <files>internal/encoder/encoder.go, internal/encoder/controls.go</files>
  <action>
Add bitrate control methods to the Encoder.

Add fields to Encoder struct:
```go
type Encoder struct {
    // ... existing fields ...

    // Bitrate controls
    bitrateMode BitrateMode
    bitrate     int  // Target bits per second
}
```

Add methods:
```go
// SetBitrateMode sets the bitrate mode (VBR, CVBR, or CBR).
func (e *Encoder) SetBitrateMode(mode BitrateMode) {
    e.bitrateMode = mode
}

// BitrateMode returns the current bitrate mode.
func (e *Encoder) BitrateMode() BitrateMode {
    return e.bitrateMode
}

// SetBitrate sets the target bitrate in bits per second.
// Valid range is 6000-510000 (6 kbps to 510 kbps).
// Values outside this range are clamped.
func (e *Encoder) SetBitrate(bitrate int) {
    e.bitrate = ClampBitrate(bitrate)
}

// Bitrate returns the current target bitrate.
func (e *Encoder) Bitrate() int {
    return e.bitrate
}

// computePacketSize determines target packet size based on mode.
func (e *Encoder) computePacketSize(frameSize int) int {
    target := targetBytesForBitrate(e.bitrate, frameSize)

    switch e.bitrateMode {
    case ModeVBR:
        // No size constraint
        return 0 // 0 means unlimited

    case ModeCVBR:
        // Return target as hint; actual size can vary by CVBRTolerance
        return target

    case ModeCBR:
        // Return exact target
        return target
    }
    return 0
}
```

Add to controls.go:
```go
// padToSize pads or truncates packet to exact size.
// Used for CBR mode.
func padToSize(packet []byte, targetSize int) []byte {
    if len(packet) >= targetSize {
        return packet[:targetSize]
    }
    // Pad with zeros (treated as padding per RFC 6716)
    padded := make([]byte, targetSize)
    copy(padded, packet)
    return padded
}

// constrainSize adjusts packet size to stay within CVBR tolerance.
func constrainSize(packet []byte, target int, tolerance float64) []byte {
    minSize := int(float64(target) * (1 - tolerance))
    maxSize := int(float64(target) * (1 + tolerance))

    if len(packet) < minSize {
        return padToSize(packet, minSize)
    }
    if len(packet) > maxSize {
        return packet[:maxSize]
    }
    return packet
}
```

Update NewEncoder to set defaults:
```go
func NewEncoder(sampleRate, channels int) *Encoder {
    return &Encoder{
        // ... existing defaults ...
        bitrateMode: ModeVBR,  // VBR is default
        bitrate:     64000,    // 64 kbps default
    }
}
```

Modify Encode() to apply bitrate control:
```go
func (e *Encoder) Encode(pcm []float64, frameSize int) ([]byte, error) {
    // ... encode frame as before ...

    // Apply bitrate mode constraints
    switch e.bitrateMode {
    case ModeCVBR:
        target := targetBytesForBitrate(e.bitrate, frameSize)
        packet = constrainSize(packet, target, CVBRTolerance)
    case ModeCBR:
        target := targetBytesForBitrate(e.bitrate, frameSize)
        packet = padToSize(packet, target)
    }

    return packet, nil
}
```
  </action>
  <verify>
`go build ./internal/encoder/` compiles.
Encoder has SetBitrateMode and SetBitrate methods.
  </verify>
  <done>Encoder has bitrate mode and target bitrate control</done>
</task>

<task type="auto">
  <name>Task 3: Bitrate Control Tests</name>
  <files>internal/encoder/encoder_test.go</files>
  <action>
Create comprehensive tests for VBR/CBR/CVBR modes.

```go
func TestBitrateModeVBR(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeHybrid)
    enc.SetBandwidth(gopus.BandwidthSuperwideband)
    enc.SetBitrateMode(ModeVBR)

    // Encode different content types
    silence := make([]float64, 960)
    complex := generateComplexSignal(960)

    silentPacket, err := enc.Encode(silence, 960)
    require.NoError(t, err)

    complexPacket, err := enc.Encode(complex, 960)
    require.NoError(t, err)

    // VBR: complex content should produce larger packets
    t.Logf("Silent packet: %d bytes, Complex packet: %d bytes",
        len(silentPacket), len(complexPacket))
    // Note: Exact ratio depends on encoder, so just verify both work
    assert.NotEmpty(t, silentPacket)
    assert.NotEmpty(t, complexPacket)
}

func TestBitrateModeCBR(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeHybrid)
    enc.SetBandwidth(gopus.BandwidthSuperwideband)
    enc.SetBitrateMode(ModeCBR)
    enc.SetBitrate(64000) // 64 kbps

    // Target size: 64000 * 20 / 8000 = 160 bytes for 20ms
    expectedSize := 160

    // Encode multiple frames
    for i := 0; i < 5; i++ {
        pcm := generateTestSignal(960)
        packet, err := enc.Encode(pcm, 960)
        require.NoError(t, err)

        // CBR: all packets should be exactly target size
        assert.Equal(t, expectedSize, len(packet),
            "CBR packet %d should be %d bytes", i, expectedSize)
    }
}

func TestBitrateModeCVBR(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeHybrid)
    enc.SetBandwidth(gopus.BandwidthSuperwideband)
    enc.SetBitrateMode(ModeCVBR)
    enc.SetBitrate(64000)

    target := 160 // bytes for 20ms at 64kbps
    minSize := int(float64(target) * (1 - CVBRTolerance))
    maxSize := int(float64(target) * (1 + CVBRTolerance))

    // Encode multiple frames
    for i := 0; i < 10; i++ {
        pcm := generateVariableSignal(960, i)
        packet, err := enc.Encode(pcm, 960)
        require.NoError(t, err)

        // CVBR: packets within tolerance
        assert.GreaterOrEqual(t, len(packet), minSize,
            "CVBR packet %d should be >= %d bytes", i, minSize)
        assert.LessOrEqual(t, len(packet), maxSize,
            "CVBR packet %d should be <= %d bytes", i, maxSize)
    }
}

func TestBitrateRange(t *testing.T) {
    enc := NewEncoder(48000, 1)

    // Test minimum bitrate
    enc.SetBitrate(MinBitrate - 1000)
    assert.Equal(t, MinBitrate, enc.Bitrate())

    // Test maximum bitrate
    enc.SetBitrate(MaxBitrate + 100000)
    assert.Equal(t, MaxBitrate, enc.Bitrate())

    // Test valid bitrate
    enc.SetBitrate(64000)
    assert.Equal(t, 64000, enc.Bitrate())
}

func TestTargetBytesForBitrate(t *testing.T) {
    tests := []struct {
        bitrate   int
        frameSize int
        expected  int
    }{
        {64000, 960, 160},   // 64kbps, 20ms = 160 bytes
        {64000, 480, 80},    // 64kbps, 10ms = 80 bytes
        {128000, 960, 320},  // 128kbps, 20ms = 320 bytes
        {6000, 960, 15},     // 6kbps (min), 20ms = 15 bytes
    }

    for _, tt := range tests {
        got := targetBytesForBitrate(tt.bitrate, tt.frameSize)
        assert.Equal(t, tt.expected, got,
            "bitrate=%d frameSize=%d", tt.bitrate, tt.frameSize)
    }
}

// Helper functions
func generateComplexSignal(n int) []float64 {
    pcm := make([]float64, n)
    for i := range pcm {
        // Multiple frequencies + noise
        t := float64(i) / 48000.0
        pcm[i] = 0.3*math.Sin(2*math.Pi*440*t) +
                 0.2*math.Sin(2*math.Pi*880*t) +
                 0.1*math.Sin(2*math.Pi*1320*t) +
                 0.1*(rand.Float64()-0.5)
    }
    return pcm
}

func generateVariableSignal(n, seed int) []float64 {
    pcm := make([]float64, n)
    freq := float64(200 + seed*100)
    amp := 0.3 + float64(seed%5)*0.1
    for i := range pcm {
        t := float64(i) / 48000.0
        pcm[i] = amp * math.Sin(2*math.Pi*freq*t)
    }
    return pcm
}
```
  </action>
  <verify>
`go test -v ./internal/encoder/ -run TestBitrate` passes all tests.
CBR mode produces consistent packet sizes.
CVBR stays within tolerance.
  </verify>
  <done>All bitrate control tests pass</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./internal/encoder/` compiles
2. `go test -v ./internal/encoder/` passes all tests
3. CBR mode produces exact packet sizes
4. CVBR mode stays within +/-15% tolerance
5. VBR mode allows natural size variation
6. Bitrate is clamped to 6-510 kbps range
</verification>

<success_criteria>
- BitrateMode type with VBR/CVBR/CBR options
- SetBitrateMode and SetBitrate methods work
- CBR produces consistent packet sizes
- CVBR constrains size within tolerance
- VBR allows content-adaptive sizing
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-hybrid-encoder-controls/08-03-SUMMARY.md`
</output>
