---
phase: 08-hybrid-encoder-controls
plan: 06
type: execute
wave: 3
depends_on: ["08-01", "08-02", "08-03", "08-04", "08-05"]
files_modified:
  - internal/encoder/integration_test.go
  - internal/encoder/libopus_test.go
autonomous: true

must_haves:
  truths:
    - "Unified encoder round-trips with hybrid decoder"
    - "All modes (SILK, Hybrid, CELT) produce decodable packets"
    - "libopus can decode packets produced by gopus encoder"
    - "Signal quality verified with energy ratio >10%"
  artifacts:
    - path: "internal/encoder/integration_test.go"
      provides: "End-to-end encoder tests across all modes"
      min_lines: 200
    - path: "internal/encoder/libopus_test.go"
      provides: "Cross-validation with libopus/opusdec"
      min_lines: 150
  key_links:
    - from: "internal/encoder/integration_test.go"
      to: "internal/hybrid/decoder.go"
      via: "round-trip decode"
      pattern: "hybrid\\.NewDecoder"
    - from: "internal/encoder/libopus_test.go"
      to: "internal/celt/crossval_test.go"
      via: "Ogg Opus container"
      pattern: "writeOggOpus|opusdec"
---

<objective>
Create comprehensive integration tests and libopus cross-validation for the unified encoder.

Purpose: Validate that the encoder produces correct Opus packets by (1) round-tripping with our own decoders and (2) cross-validating with the reference libopus implementation. This is the final verification that the encoder implementation is correct.

Output: Comprehensive test suite verifying encoder output across all modes and configurations.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-hybrid-encoder-controls/08-RESEARCH.md

# Encoder to test
@internal/encoder/encoder.go

# Decoders for round-trip
@internal/hybrid/decoder.go
@internal/silk/silk.go
@internal/celt/decoder.go

# Existing libopus test infrastructure
@internal/celt/crossval_test.go
@internal/celt/libopus_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integration Tests - All Modes</name>
  <files>internal/encoder/integration_test.go</files>
  <action>
Create comprehensive integration tests for all encoder modes and configurations.

```go
package encoder

import (
    "math"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"

    "gopus"
    "gopus/internal/celt"
    "gopus/internal/hybrid"
    "gopus/internal/rangecoding"
    "gopus/internal/silk"
)

// Test configuration combinations
var testConfigs = []struct {
    name      string
    mode      Mode
    bandwidth gopus.Bandwidth
    frameSize int
    stereo    bool
}{
    // Hybrid mode (Phase 8 focus)
    {"Hybrid-SWB-10ms-mono", ModeHybrid, gopus.BandwidthSuperwideband, 480, false},
    {"Hybrid-SWB-20ms-mono", ModeHybrid, gopus.BandwidthSuperwideband, 960, false},
    {"Hybrid-FB-10ms-mono", ModeHybrid, gopus.BandwidthFullband, 480, false},
    {"Hybrid-FB-20ms-mono", ModeHybrid, gopus.BandwidthFullband, 960, false},
    {"Hybrid-SWB-20ms-stereo", ModeHybrid, gopus.BandwidthSuperwideband, 960, true},
    {"Hybrid-FB-20ms-stereo", ModeHybrid, gopus.BandwidthFullband, 960, true},

    // SILK mode
    {"SILK-NB-20ms-mono", ModeSILK, gopus.BandwidthNarrowband, 960, false},
    {"SILK-MB-20ms-mono", ModeSILK, gopus.BandwidthMediumband, 960, false},
    {"SILK-WB-20ms-mono", ModeSILK, gopus.BandwidthWideband, 960, false},
    {"SILK-WB-20ms-stereo", ModeSILK, gopus.BandwidthWideband, 960, true},

    // CELT mode
    {"CELT-NB-20ms-mono", ModeCELT, gopus.BandwidthNarrowband, 960, false},
    {"CELT-WB-20ms-mono", ModeCELT, gopus.BandwidthWideband, 960, false},
    {"CELT-FB-20ms-mono", ModeCELT, gopus.BandwidthFullband, 960, false},
    {"CELT-FB-20ms-stereo", ModeCELT, gopus.BandwidthFullband, 960, true},
}

func TestEncoderAllModes(t *testing.T) {
    for _, tc := range testConfigs {
        t.Run(tc.name, func(t *testing.T) {
            channels := 1
            if tc.stereo {
                channels = 2
            }

            enc := NewEncoder(48000, channels)
            enc.SetMode(tc.mode)
            enc.SetBandwidth(tc.bandwidth)

            // Generate test signal
            pcm := generateTestPCM(tc.frameSize * channels)

            // Encode
            packet, err := enc.Encode(pcm, tc.frameSize)
            require.NoError(t, err, "encoding should succeed")
            require.NotEmpty(t, packet, "packet should not be empty")

            // Verify TOC byte
            toc := gopus.ParseTOC(packet[0])
            assert.Equal(t, tc.mode, toc.Mode, "TOC mode mismatch")
            assert.Equal(t, tc.bandwidth, toc.Bandwidth, "TOC bandwidth mismatch")
            assert.Equal(t, tc.stereo, toc.Stereo, "TOC stereo mismatch")

            t.Logf("Encoded %d bytes for %s", len(packet), tc.name)
        })
    }
}

func TestEncoderHybridRoundTrip(t *testing.T) {
    tests := []struct {
        name      string
        bandwidth gopus.Bandwidth
        frameSize int
        channels  int
    }{
        {"SWB-10ms-mono", gopus.BandwidthSuperwideband, 480, 1},
        {"SWB-20ms-mono", gopus.BandwidthSuperwideband, 960, 1},
        {"FB-10ms-mono", gopus.BandwidthFullband, 480, 1},
        {"FB-20ms-mono", gopus.BandwidthFullband, 960, 1},
        {"SWB-20ms-stereo", gopus.BandwidthSuperwideband, 960, 2},
        {"FB-20ms-stereo", gopus.BandwidthFullband, 960, 2},
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            enc := NewEncoder(48000, tc.channels)
            enc.SetMode(ModeHybrid)
            enc.SetBandwidth(tc.bandwidth)

            dec := hybrid.NewDecoder(tc.channels)

            // Generate test signal
            pcm := generateSineWave(tc.frameSize*tc.channels, 440, 0.5)

            // Encode
            packet, err := enc.Encode(pcm, tc.frameSize)
            require.NoError(t, err)
            require.NotEmpty(t, packet)

            // Decode (skip TOC byte - decoder expects raw frame data)
            frameData := packet[1:]
            rd := rangecoding.NewDecoder(frameData)
            decoded, err := dec.Decode(rd, tc.frameSize, tc.channels == 2)
            require.NoError(t, err)
            require.Len(t, decoded, tc.frameSize*tc.channels)

            // Verify signal energy preserved
            inputEnergy := computeEnergy(pcm)
            outputEnergy := computeEnergy(decoded)

            ratio := outputEnergy / inputEnergy
            t.Logf("Energy ratio: %.2f (input: %.4f, output: %.4f)",
                ratio, inputEnergy, outputEnergy)

            assert.Greater(t, ratio, 0.1,
                "decoded signal should have >10%% of input energy")
        })
    }
}

func TestEncoderCELTRoundTrip(t *testing.T) {
    tests := []struct {
        name      string
        frameSize int
        channels  int
    }{
        {"20ms-mono", 960, 1},
        {"10ms-mono", 480, 1},
        {"5ms-mono", 240, 1},
        {"20ms-stereo", 960, 2},
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            enc := NewEncoder(48000, tc.channels)
            enc.SetMode(ModeCELT)
            enc.SetBandwidth(gopus.BandwidthFullband)

            dec := celt.NewDecoder(tc.channels)

            // Generate test signal
            pcm := generateSineWave(tc.frameSize*tc.channels, 440, 0.5)

            // Encode
            packet, err := enc.Encode(pcm, tc.frameSize)
            require.NoError(t, err)
            require.NotEmpty(t, packet)

            // Decode
            frameData := packet[1:] // Skip TOC
            rd := rangecoding.NewDecoder(frameData)
            decoded, err := dec.DecodeFrame(rd, tc.frameSize)
            require.NoError(t, err)
            require.Len(t, decoded, tc.frameSize*tc.channels)

            // Verify energy
            inputEnergy := computeEnergy(pcm)
            outputEnergy := computeEnergy(decoded)

            ratio := outputEnergy / inputEnergy
            t.Logf("Energy ratio: %.2f", ratio)

            assert.Greater(t, ratio, 0.1)
        })
    }
}

func TestEncoderMultipleFrames(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeHybrid)
    enc.SetBandwidth(gopus.BandwidthSuperwideband)

    dec := hybrid.NewDecoder(1)

    // Encode 10 consecutive frames
    numFrames := 10
    for i := 0; i < numFrames; i++ {
        // Different frequency each frame
        freq := 220 + float64(i*50)
        pcm := generateSineWave(960, freq, 0.5)

        packet, err := enc.Encode(pcm, 960)
        require.NoError(t, err, "frame %d encode failed", i)
        require.NotEmpty(t, packet, "frame %d packet empty", i)

        // Decode
        frameData := packet[1:]
        rd := rangecoding.NewDecoder(frameData)
        decoded, err := dec.Decode(rd, 960, false)
        require.NoError(t, err, "frame %d decode failed", i)
        require.Len(t, decoded, 960, "frame %d wrong length", i)

        // Verify has signal
        energy := computeEnergy(decoded)
        assert.Greater(t, energy, 0.01, "frame %d has no energy", i)
    }
}

func TestEncoderBitrateRange(t *testing.T) {
    bitrates := []int{6000, 12000, 24000, 48000, 64000, 96000, 128000}

    for _, bitrate := range bitrates {
        t.Run(fmt.Sprintf("%dkbps", bitrate/1000), func(t *testing.T) {
            enc := NewEncoder(48000, 1)
            enc.SetMode(ModeHybrid)
            enc.SetBandwidth(gopus.BandwidthSuperwideband)
            enc.SetBitrate(bitrate)
            enc.SetBitrateMode(ModeCBR)

            pcm := generateTestPCM(960)
            packet, err := enc.Encode(pcm, 960)
            require.NoError(t, err)
            require.NotEmpty(t, packet)

            // Verify packet size roughly matches bitrate
            expectedBytes := bitrate * 20 / 8000 // 20ms frame
            actualBytes := len(packet)

            t.Logf("Bitrate %d kbps: expected ~%d bytes, got %d bytes",
                bitrate/1000, expectedBytes, actualBytes)

            // Allow 20% tolerance for CBR
            assert.InDelta(t, expectedBytes, actualBytes, float64(expectedBytes)*0.2)
        })
    }
}

func TestEncoderAllFrameSizes(t *testing.T) {
    frameSizes := []struct {
        size int
        mode Mode
    }{
        // SILK frame sizes
        {240, ModeSILK},  // 5ms (not common but valid)
        {480, ModeSILK},  // 10ms
        {960, ModeSILK},  // 20ms

        // Hybrid frame sizes (only 10ms and 20ms)
        {480, ModeHybrid},  // 10ms
        {960, ModeHybrid},  // 20ms

        // CELT frame sizes
        {120, ModeCELT},  // 2.5ms
        {240, ModeCELT},  // 5ms
        {480, ModeCELT},  // 10ms
        {960, ModeCELT},  // 20ms
    }

    for _, tc := range frameSizes {
        t.Run(fmt.Sprintf("%s-%dms", tc.mode, tc.size*1000/48000), func(t *testing.T) {
            enc := NewEncoder(48000, 1)
            enc.SetMode(tc.mode)
            enc.SetBandwidth(gopus.BandwidthWideband)

            pcm := generateTestPCM(tc.size)
            packet, err := enc.Encode(pcm, tc.size)
            require.NoError(t, err)
            require.NotEmpty(t, packet)

            t.Logf("Frame size %d: %d bytes encoded", tc.size, len(packet))
        })
    }
}

// Helper functions

func generateTestPCM(n int) []float64 {
    pcm := make([]float64, n)
    for i := range pcm {
        t := float64(i) / 48000.0
        pcm[i] = 0.5 * math.Sin(2*math.Pi*440*t)
    }
    return pcm
}

func generateSineWave(n int, freq, amp float64) []float64 {
    pcm := make([]float64, n)
    for i := range pcm {
        t := float64(i) / 48000.0
        pcm[i] = amp * math.Sin(2*math.Pi*freq*t)
    }
    return pcm
}

func computeEnergy(samples []float64) float64 {
    if len(samples) == 0 {
        return 0
    }
    var sum float64
    for _, s := range samples {
        sum += s * s
    }
    return sum / float64(len(samples))
}
```
  </action>
  <verify>
`go test -v ./internal/encoder/ -run TestEncoder` passes all tests.
All modes and configurations produce valid packets.
  </verify>
  <done>Comprehensive integration tests for all encoder modes</done>
</task>

<task type="auto">
  <name>Task 2: Libopus Cross-Validation Tests</name>
  <files>internal/encoder/libopus_test.go</files>
  <action>
Create cross-validation tests using libopus's opusdec to verify encoded packets.
Reuse the Ogg Opus container writer from Phase 7 (internal/celt/crossval_test.go).

```go
package encoder

import (
    "bytes"
    "encoding/binary"
    "io"
    "os"
    "os/exec"
    "testing"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

// TestLibopusHybridDecode verifies libopus can decode hybrid packets.
func TestLibopusHybridDecode(t *testing.T) {
    if _, err := exec.LookPath("opusdec"); err != nil {
        t.Skip("opusdec not found in PATH")
    }

    tests := []struct {
        name      string
        bandwidth Bandwidth
        frameSize int
        channels  int
    }{
        {"SWB-20ms-mono", BandwidthSuperwideband, 960, 1},
        {"FB-20ms-mono", BandwidthFullband, 960, 1},
        {"SWB-20ms-stereo", BandwidthSuperwideband, 960, 2},
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            testLibopusDecode(t, ModeHybrid, tc.bandwidth, tc.frameSize, tc.channels)
        })
    }
}

// TestLibopusSILKDecode verifies libopus can decode SILK packets.
func TestLibopusSILKDecode(t *testing.T) {
    if _, err := exec.LookPath("opusdec"); err != nil {
        t.Skip("opusdec not found in PATH")
    }

    tests := []struct {
        name      string
        bandwidth Bandwidth
        frameSize int
        channels  int
    }{
        {"NB-20ms-mono", BandwidthNarrowband, 960, 1},
        {"WB-20ms-mono", BandwidthWideband, 960, 1},
        {"WB-20ms-stereo", BandwidthWideband, 960, 2},
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            testLibopusDecode(t, ModeSILK, tc.bandwidth, tc.frameSize, tc.channels)
        })
    }
}

// TestLibopusCELTDecode verifies libopus can decode CELT packets.
func TestLibopusCELTDecode(t *testing.T) {
    if _, err := exec.LookPath("opusdec"); err != nil {
        t.Skip("opusdec not found in PATH")
    }

    tests := []struct {
        name      string
        bandwidth Bandwidth
        frameSize int
        channels  int
    }{
        {"FB-20ms-mono", BandwidthFullband, 960, 1},
        {"FB-10ms-mono", BandwidthFullband, 480, 1},
        {"FB-20ms-stereo", BandwidthFullband, 960, 2},
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            testLibopusDecode(t, ModeCELT, tc.bandwidth, tc.frameSize, tc.channels)
        })
    }
}

func testLibopusDecode(t *testing.T, mode Mode, bandwidth Bandwidth, frameSize, channels int) {
    // Create encoder
    enc := NewEncoder(48000, channels)
    enc.SetMode(mode)
    enc.SetBandwidth(bandwidth)

    // Generate 1 second of audio (50 frames at 20ms each)
    numFrames := 50 * (960 / frameSize)
    packets := make([][]byte, numFrames)

    for i := 0; i < numFrames; i++ {
        // Generate test signal
        pcm := generateSineWave(frameSize*channels, 440, 0.5)

        packet, err := enc.Encode(pcm, frameSize)
        require.NoError(t, err)
        require.NotEmpty(t, packet)
        packets[i] = packet
    }

    // Write to Ogg Opus container
    var oggBuf bytes.Buffer
    err := writeOggOpus(&oggBuf, packets, channels, 48000)
    require.NoError(t, err)

    // Write to temp file
    tmpFile, err := os.CreateTemp("", "gopus_test_*.opus")
    require.NoError(t, err)
    defer os.Remove(tmpFile.Name())

    _, err = tmpFile.Write(oggBuf.Bytes())
    require.NoError(t, err)
    tmpFile.Close()

    // Create output file for decoded WAV
    wavFile, err := os.CreateTemp("", "gopus_test_*.wav")
    require.NoError(t, err)
    defer os.Remove(wavFile.Name())
    wavFile.Close()

    // Decode with opusdec
    cmd := exec.Command("opusdec", tmpFile.Name(), wavFile.Name())
    output, err := cmd.CombinedOutput()
    if err != nil {
        // Check for macOS provenance issues
        if bytes.Contains(output, []byte("provenance")) ||
           bytes.Contains(output, []byte("quarantine")) {
            t.Skip("opusdec blocked by macOS provenance - skipping")
        }
        t.Logf("opusdec output: %s", output)
        require.NoError(t, err, "opusdec failed")
    }

    // Read and verify decoded WAV
    wavData, err := os.ReadFile(wavFile.Name())
    require.NoError(t, err)
    require.Greater(t, len(wavData), 44, "WAV file should have data")

    // Parse WAV and check for signal
    samples := parseWAVSamples(wavData)
    require.NotEmpty(t, samples)

    energy := computeEnergyFloat32(samples)
    t.Logf("Decoded %d samples, energy: %.6f", len(samples), energy)

    assert.Greater(t, energy, 0.01, "decoded signal should have energy")
}

// writeOggOpus writes Opus packets to Ogg container.
// Minimal implementation per RFC 7845.
func writeOggOpus(w io.Writer, packets [][]byte, channels, sampleRate int) error {
    serialNo := uint32(12345)
    var granulePos uint64

    // Page 1: OpusHead header
    opusHead := makeOpusHead(channels, sampleRate)
    if err := writeOggPage(w, serialNo, 0, 2, 0, [][]byte{opusHead}); err != nil {
        return err
    }

    // Page 2: OpusTags header
    opusTags := makeOpusTags()
    if err := writeOggPage(w, serialNo, 1, 0, 0, [][]byte{opusTags}); err != nil {
        return err
    }

    // Data pages
    pageNo := uint32(2)
    for _, packet := range packets {
        // Assume 20ms frames for granule position
        granulePos += 960
        headerType := byte(0)
        if pageNo == uint32(len(packets)+1) {
            headerType = 4 // End of stream
        }
        if err := writeOggPage(w, serialNo, pageNo, headerType, granulePos, [][]byte{packet}); err != nil {
            return err
        }
        pageNo++
    }

    return nil
}

func makeOpusHead(channels, sampleRate int) []byte {
    head := make([]byte, 19)
    copy(head[0:8], "OpusHead")
    head[8] = 1  // Version
    head[9] = byte(channels)
    binary.LittleEndian.PutUint16(head[10:12], 0) // Pre-skip
    binary.LittleEndian.PutUint32(head[12:16], uint32(sampleRate))
    binary.LittleEndian.PutUint16(head[16:18], 0) // Output gain
    head[18] = 0 // Channel mapping family
    return head
}

func makeOpusTags() []byte {
    vendor := "gopus"
    tags := make([]byte, 8+4+len(vendor)+4)
    copy(tags[0:8], "OpusTags")
    binary.LittleEndian.PutUint32(tags[8:12], uint32(len(vendor)))
    copy(tags[12:12+len(vendor)], vendor)
    binary.LittleEndian.PutUint32(tags[12+len(vendor):], 0) // User comment count
    return tags
}

func writeOggPage(w io.Writer, serialNo, pageNo uint32, headerType byte, granulePos uint64, segments [][]byte) error {
    // Calculate segment table
    var segmentTable []byte
    for _, seg := range segments {
        remaining := len(seg)
        for remaining >= 255 {
            segmentTable = append(segmentTable, 255)
            remaining -= 255
        }
        segmentTable = append(segmentTable, byte(remaining))
    }

    // Page header
    header := make([]byte, 27+len(segmentTable))
    copy(header[0:4], "OggS")
    header[4] = 0 // Version
    header[5] = headerType
    binary.LittleEndian.PutUint64(header[6:14], granulePos)
    binary.LittleEndian.PutUint32(header[14:18], serialNo)
    binary.LittleEndian.PutUint32(header[18:22], pageNo)
    // CRC will be at [22:26]
    header[26] = byte(len(segmentTable))
    copy(header[27:], segmentTable)

    // Compute CRC
    crc := oggCRC(header)
    for _, seg := range segments {
        crc = oggCRCUpdate(crc, seg)
    }
    binary.LittleEndian.PutUint32(header[22:26], crc)

    // Write header
    if _, err := w.Write(header); err != nil {
        return err
    }

    // Write segments
    for _, seg := range segments {
        if _, err := w.Write(seg); err != nil {
            return err
        }
    }

    return nil
}

// Ogg CRC-32 (polynomial 0x04c11db7)
var oggCRCTable [256]uint32

func init() {
    for i := 0; i < 256; i++ {
        r := uint32(i) << 24
        for j := 0; j < 8; j++ {
            if r&0x80000000 != 0 {
                r = (r << 1) ^ 0x04c11db7
            } else {
                r <<= 1
            }
        }
        oggCRCTable[i] = r
    }
}

func oggCRC(data []byte) uint32 {
    return oggCRCUpdate(0, data)
}

func oggCRCUpdate(crc uint32, data []byte) uint32 {
    for _, b := range data {
        crc = (crc << 8) ^ oggCRCTable[byte(crc>>24)^b]
    }
    return crc
}

func parseWAVSamples(data []byte) []float32 {
    if len(data) < 44 {
        return nil
    }
    // Skip WAV header (44 bytes for standard format)
    data = data[44:]

    samples := make([]float32, len(data)/2)
    for i := 0; i < len(data)/2; i++ {
        s := int16(data[i*2]) | int16(data[i*2+1])<<8
        samples[i] = float32(s) / 32768.0
    }
    return samples
}

func computeEnergyFloat32(samples []float32) float64 {
    if len(samples) == 0 {
        return 0
    }
    var sum float64
    for _, s := range samples {
        sum += float64(s) * float64(s)
    }
    return sum / float64(len(samples))
}
```
  </action>
  <verify>
`go test -v ./internal/encoder/ -run TestLibopus` passes (or skips on macOS).
libopus successfully decodes gopus-encoded packets.
  </verify>
  <done>Libopus cross-validation tests pass</done>
</task>

<task type="auto">
  <name>Task 3: Signal Quality Verification Tests</name>
  <files>internal/encoder/integration_test.go</files>
  <action>
Add additional tests that verify signal quality metrics beyond just energy.

Append to integration_test.go:
```go
func TestEncoderSignalQuality(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeHybrid)
    enc.SetBandwidth(gopus.BandwidthSuperwideband)
    enc.SetBitrate(64000)

    dec := hybrid.NewDecoder(1)

    // Test with different signal types
    signals := []struct {
        name string
        gen  func(int) []float64
    }{
        {"sine440", func(n int) []float64 { return generateSineWave(n, 440, 0.7) }},
        {"sine1000", func(n int) []float64 { return generateSineWave(n, 1000, 0.7) }},
        {"mixed", func(n int) []float64 { return generateMixedSignal(n) }},
        {"chirp", func(n int) []float64 { return generateChirp(n, 200, 4000) }},
    }

    for _, sig := range signals {
        t.Run(sig.name, func(t *testing.T) {
            pcm := sig.gen(960)

            // Encode
            packet, err := enc.Encode(pcm, 960)
            require.NoError(t, err)

            // Decode
            frameData := packet[1:]
            rd := rangecoding.NewDecoder(frameData)
            decoded, err := dec.Decode(rd, 960, false)
            require.NoError(t, err)

            // Compute quality metrics
            inputEnergy := computeEnergy(pcm)
            outputEnergy := computeEnergy(decoded)
            energyRatio := outputEnergy / inputEnergy

            // Compute correlation
            correlation := computeCorrelation(pcm, decoded)

            t.Logf("%s: energy ratio=%.3f, correlation=%.3f",
                sig.name, energyRatio, correlation)

            // Quality requirements
            assert.Greater(t, energyRatio, 0.1, "energy ratio >10%%")
            // Note: correlation may be low due to codec processing
            // but should be positive for tonal signals
        })
    }
}

func TestEncoderBitrateQuality(t *testing.T) {
    // Higher bitrates should produce better quality
    bitrates := []int{12000, 24000, 48000, 96000}
    prevEnergy := 0.0

    dec := hybrid.NewDecoder(1)

    for _, bitrate := range bitrates {
        t.Run(fmt.Sprintf("%dkbps", bitrate/1000), func(t *testing.T) {
            enc := NewEncoder(48000, 1)
            enc.SetMode(ModeHybrid)
            enc.SetBandwidth(gopus.BandwidthSuperwideband)
            enc.SetBitrate(bitrate)

            pcm := generateMixedSignal(960)

            packet, err := enc.Encode(pcm, 960)
            require.NoError(t, err)

            frameData := packet[1:]
            rd := rangecoding.NewDecoder(frameData)
            decoded, err := dec.Decode(rd, 960, false)
            require.NoError(t, err)

            energy := computeEnergy(decoded)
            t.Logf("%d kbps: packet %d bytes, output energy %.6f",
                bitrate/1000, len(packet), energy)

            // Higher bitrate should preserve more energy (generally)
            if prevEnergy > 0 {
                // Allow some variance but trend should be positive
                // This is a weak assertion - mainly for logging
            }
            prevEnergy = energy
        })
    }
}

func TestEncoderNoClipping(t *testing.T) {
    enc := NewEncoder(48000, 1)
    enc.SetMode(ModeHybrid)
    enc.SetBandwidth(gopus.BandwidthSuperwideband)

    dec := hybrid.NewDecoder(1)

    // Test with full-scale signal
    pcm := generateSineWave(960, 440, 1.0)

    packet, err := enc.Encode(pcm, 960)
    require.NoError(t, err)

    frameData := packet[1:]
    rd := rangecoding.NewDecoder(frameData)
    decoded, err := dec.Decode(rd, 960, false)
    require.NoError(t, err)

    // Check for clipping (values exceeding [-1, 1])
    maxAbs := 0.0
    for _, s := range decoded {
        if abs := math.Abs(s); abs > maxAbs {
            maxAbs = abs
        }
    }

    t.Logf("Max absolute value: %.6f", maxAbs)
    assert.Less(t, maxAbs, 1.5, "decoded signal should not clip severely")
}

// Additional helper functions

func generateMixedSignal(n int) []float64 {
    pcm := make([]float64, n)
    for i := range pcm {
        t := float64(i) / 48000.0
        // Multiple harmonics typical of speech/music
        pcm[i] = 0.3*math.Sin(2*math.Pi*220*t) +
                 0.2*math.Sin(2*math.Pi*440*t) +
                 0.15*math.Sin(2*math.Pi*880*t) +
                 0.1*math.Sin(2*math.Pi*1320*t)
    }
    return pcm
}

func generateChirp(n int, startFreq, endFreq float64) []float64 {
    pcm := make([]float64, n)
    for i := range pcm {
        t := float64(i) / float64(n)
        freq := startFreq + (endFreq-startFreq)*t
        phase := 2 * math.Pi * freq * t / 48000.0 * float64(i)
        pcm[i] = 0.5 * math.Sin(phase)
    }
    return pcm
}

func computeCorrelation(a, b []float64) float64 {
    if len(a) != len(b) || len(a) == 0 {
        return 0
    }

    var sumA, sumB, sumAB, sumA2, sumB2 float64
    n := float64(len(a))

    for i := range a {
        sumA += a[i]
        sumB += b[i]
        sumAB += a[i] * b[i]
        sumA2 += a[i] * a[i]
        sumB2 += b[i] * b[i]
    }

    num := n*sumAB - sumA*sumB
    den := math.Sqrt((n*sumA2 - sumA*sumA) * (n*sumB2 - sumB*sumB))

    if den == 0 {
        return 0
    }
    return num / den
}
```
  </action>
  <verify>
`go test -v ./internal/encoder/ -run TestEncoderSignal` passes.
Signal quality metrics computed and logged.
  </verify>
  <done>Signal quality verification tests pass</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `go build ./internal/encoder/` compiles
2. `go test -v ./internal/encoder/` passes all tests
3. All modes (SILK, Hybrid, CELT) produce valid packets
4. Round-trip with internal decoders preserves signal energy
5. libopus can decode generated packets (when available)
6. Signal quality metrics verify >10% energy ratio
</verification>

<success_criteria>
- Integration tests cover all mode/bandwidth/frameSize combinations
- Round-trip tests verify encode->decode preserves signal
- libopus cross-validation tests pass (or skip gracefully)
- Signal quality tests verify energy ratio >10%
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/08-hybrid-encoder-controls/08-06-SUMMARY.md`
</output>
