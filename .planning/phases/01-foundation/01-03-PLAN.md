---
phase: 01-foundation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packet.go
  - packet_test.go
  - doc.go
autonomous: true

must_haves:
  truths:
    - "TOC byte correctly extracts configuration (mode, bandwidth, frame size)"
    - "TOC byte correctly extracts stereo flag"
    - "TOC byte correctly extracts frame count code (0-3)"
    - "Code 0 packets parse as single frame"
    - "Code 1 packets parse as two equal-size frames"
    - "Code 2 packets parse as two frames with sizes from header"
    - "Code 3 packets parse VBR/CBR with M frames"
    - "Frame lengths >251 bytes use two-byte encoding correctly"
  artifacts:
    - path: "packet.go"
      provides: "TOC parsing and packet frame extraction"
      exports: ["TOC", "Mode", "Bandwidth", "ParsePacket", "PacketInfo"]
    - path: "packet_test.go"
      provides: "Tests for TOC and packet parsing"
      contains: "func Test"
    - path: "doc.go"
      provides: "Package documentation"
      contains: "Package gopus"
  key_links:
    - from: "packet.go"
      to: "RFC 6716 Section 3"
      via: "implementation of"
      pattern: "TOC|FrameCode"
---

<objective>
Implement TOC byte parsing and packet structure handling per RFC 6716 Section 3.

Purpose: Every Opus packet starts with a TOC byte that indicates mode, bandwidth, frame size, and stereo configuration. The frame count codes (0-3) determine how many frames are in the packet and their sizes. This is essential for all decode operations.

Output: Complete packet parsing that extracts TOC information and frame boundaries.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement TOC byte parsing and types</name>
  <files>
    packet.go
  </files>
  <action>
Create the packet parsing module at the package root.

Create `packet.go` with:

1. **Mode type and constants**:
```go
type Mode uint8

const (
    ModeSILK   Mode = iota  // SILK-only mode (configs 0-11)
    ModeHybrid              // Hybrid SILK+CELT (configs 12-15)
    ModeCELT                // CELT-only mode (configs 16-31)
)
```

2. **Bandwidth type and constants**:
```go
type Bandwidth uint8

const (
    BandwidthNarrowband     Bandwidth = iota  // 4kHz audio, 8kHz sample rate
    BandwidthMediumband                        // 6kHz audio, 12kHz sample rate
    BandwidthWideband                          // 8kHz audio, 16kHz sample rate
    BandwidthSuperwideband                     // 12kHz audio, 24kHz sample rate
    BandwidthFullband                          // 20kHz audio, 48kHz sample rate
)
```

3. **TOC struct** and parsing:
```go
type TOC struct {
    Config     uint8     // Configuration 0-31
    Mode       Mode      // Derived from config
    Bandwidth  Bandwidth // Derived from config
    FrameSize  int       // Frame size in samples at 48kHz
    Stereo     bool      // True if stereo
    FrameCode  uint8     // Code 0-3
}

func ParseTOC(b byte) TOC {
    config := b >> 3           // Top 5 bits
    stereo := (b & 0x04) != 0  // Bit 2
    frameCode := b & 0x03      // Bottom 2 bits

    // Derive mode, bandwidth, frame size from config
    // See RFC 6716 Section 3.1 Table
    ...
}
```

4. **Configuration lookup table** (all 32 configs):
```go
var configTable = [32]struct {
    Mode      Mode
    Bandwidth Bandwidth
    FrameSize int  // In samples at 48kHz
}{
    // SILK-only NB: configs 0-3 (10/20/40/60ms)
    {ModeSILK, BandwidthNarrowband, 480},    // 0: 10ms
    {ModeSILK, BandwidthNarrowband, 960},    // 1: 20ms
    {ModeSILK, BandwidthNarrowband, 1920},   // 2: 40ms
    {ModeSILK, BandwidthNarrowband, 2880},   // 3: 60ms
    // SILK-only MB: configs 4-7
    {ModeSILK, BandwidthMediumband, 480},    // 4
    {ModeSILK, BandwidthMediumband, 960},    // 5
    {ModeSILK, BandwidthMediumband, 1920},   // 6
    {ModeSILK, BandwidthMediumband, 2880},   // 7
    // SILK-only WB: configs 8-11
    {ModeSILK, BandwidthWideband, 480},      // 8
    {ModeSILK, BandwidthWideband, 960},      // 9
    {ModeSILK, BandwidthWideband, 1920},     // 10
    {ModeSILK, BandwidthWideband, 2880},     // 11
    // Hybrid SWB: configs 12-13
    {ModeHybrid, BandwidthSuperwideband, 480},  // 12: 10ms
    {ModeHybrid, BandwidthSuperwideband, 960},  // 13: 20ms
    // Hybrid FB: configs 14-15
    {ModeHybrid, BandwidthFullband, 480},    // 14
    {ModeHybrid, BandwidthFullband, 960},    // 15
    // CELT NB: configs 16-19 (2.5/5/10/20ms)
    {ModeCELT, BandwidthNarrowband, 120},    // 16: 2.5ms
    {ModeCELT, BandwidthNarrowband, 240},    // 17: 5ms
    {ModeCELT, BandwidthNarrowband, 480},    // 18: 10ms
    {ModeCELT, BandwidthNarrowband, 960},    // 19: 20ms
    // CELT WB: configs 20-23
    {ModeCELT, BandwidthWideband, 120},      // 20
    {ModeCELT, BandwidthWideband, 240},      // 21
    {ModeCELT, BandwidthWideband, 480},      // 22
    {ModeCELT, BandwidthWideband, 960},      // 23
    // CELT SWB: configs 24-27
    {ModeCELT, BandwidthSuperwideband, 120}, // 24
    {ModeCELT, BandwidthSuperwideband, 240}, // 25
    {ModeCELT, BandwidthSuperwideband, 480}, // 26
    {ModeCELT, BandwidthSuperwideband, 960}, // 27
    // CELT FB: configs 28-31
    {ModeCELT, BandwidthFullband, 120},      // 28
    {ModeCELT, BandwidthFullband, 240},      // 29
    {ModeCELT, BandwidthFullband, 480},      // 30
    {ModeCELT, BandwidthFullband, 960},      // 31
}
```

Note: CELT MB (mediumband) does not exist in the config table - configs 16-19 are NB, 20-23 are WB (not MB).
  </action>
  <verify>
Run `go build ./...` - should compile.
  </verify>
  <done>
TOC, Mode, Bandwidth types defined. ParseTOC correctly extracts all fields. Config table matches RFC 6716 Section 3.1.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement packet frame parsing</name>
  <files>
    packet.go
  </files>
  <action>
Add packet frame parsing to `packet.go`:

1. **PacketInfo struct**:
```go
type PacketInfo struct {
    TOC        TOC
    FrameCount int       // Number of frames (1-48 for code 3)
    FrameSizes []int     // Size in bytes of each frame
    Padding    int       // Padding bytes (code 3 only)
    TotalSize  int       // Total packet size
}
```

2. **ParsePacket(data []byte) (PacketInfo, error)** function:
   - Parse TOC byte first
   - Based on FrameCode, parse rest of packet:

   **Code 0** (single frame):
   - FrameCount = 1
   - FrameSizes = [len(data) - 1]

   **Code 1** (two equal frames):
   - FrameCount = 2
   - Each frame is (len(data) - 1) / 2 bytes
   - Return error if odd length

   **Code 2** (two frames, different sizes):
   - FrameCount = 2
   - Parse first frame length from byte(s) after TOC
   - Second frame is remainder
   - Handle two-byte encoding if first byte >= 252

   **Code 3** (arbitrary frame count):
   - Parse frame count byte: VBR bit (7), padding bit (6), M field (0-5)
   - If padding bit set, parse padding length (with continuation bytes)
   - Parse frame lengths (VBR: each frame, CBR: just first)
   - Handle two-byte encoding for lengths >= 252

3. **parseFrameLength(data []byte, offset int) (length, bytesRead int)**:
   - If data[offset] < 252: return data[offset], 1
   - Else: return 4*data[offset+1] + data[offset], 2
   - This is the two-byte encoding per RFC 6716 Section 3.2.1

4. **Error handling**:
   - Return `ErrPacketTooShort` if packet truncated
   - Return `ErrInvalidFrameCount` if M > 48 (max frames)
   - Return `ErrInvalidPacket` for malformed data
  </action>
  <verify>
Run `go build ./...` - should compile.
  </verify>
  <done>
ParsePacket correctly handles codes 0-3. Frame lengths extracted including two-byte encoding. Error cases handled.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add tests and package documentation</name>
  <files>
    packet_test.go
    doc.go
  </files>
  <action>
Create comprehensive tests and package documentation.

Create `packet_test.go` with:

1. **TestParseTOC** - test TOC byte parsing:
   - Test all 32 configs: verify mode, bandwidth, frame size
   - Test stereo bit extraction
   - Test frame code extraction
   - Example cases:
     - 0x00 -> config 0, mono, code 0
     - 0x04 -> config 0, stereo, code 0
     - 0x01 -> config 0, mono, code 1
     - 0xFC -> config 31, stereo, code 0

2. **TestParsePacketCode0** - single frame packets:
   - Various packet sizes
   - Verify frame count = 1, frame size = len-1

3. **TestParsePacketCode1** - two equal frames:
   - Even total size (valid)
   - Odd total size (error)
   - Verify frame sizes equal

4. **TestParsePacketCode2** - two different frames:
   - Small first frame (<252 bytes)
   - Large first frame (>251 bytes, two-byte encoding)
   - Verify both frame sizes

5. **TestParsePacketCode3** - multiple frames:
   - CBR mode (all frames same size)
   - VBR mode (each frame different)
   - With padding
   - Various M values (1, 2, 3, 48)

6. **TestTwoByteFrameLength** - edge cases:
   - Length 251 (single byte)
   - Length 252 (two bytes: 252, 0)
   - Length 255 (two bytes: 255, 0)
   - Length 256 (two bytes: 252, 1)
   - Large lengths

7. **TestParsePacketErrors**:
   - Empty packet
   - Truncated code 2 packet
   - Truncated code 3 packet
   - M > 48 error

Create `doc.go`:
```go
// Package gopus implements the Opus audio codec in pure Go.
//
// Opus is a lossy audio codec designed for interactive speech and music
// transmission. It supports bitrates from 6 to 510 kbit/s, sampling rates
// from 8 to 48 kHz, and frame sizes from 2.5 to 60 ms.
//
// This implementation follows RFC 6716 and is compatible with the
// reference libopus implementation. It requires no cgo dependencies.
//
// # Opus Modes
//
// Opus operates in three modes:
//   - SILK: speech-optimized, 8-24 kHz bandwidth
//   - CELT: audio-optimized, full 48 kHz bandwidth
//   - Hybrid: SILK for low frequencies + CELT for high frequencies
//
// The mode is determined by the TOC byte in each packet.
//
// # Packet Structure
//
// Each Opus packet starts with a TOC (Table of Contents) byte:
//   - Bits 7-3: Configuration (0-31)
//   - Bit 2: Stereo flag
//   - Bits 1-0: Frame count code (0-3)
//
// Use ParseTOC to extract these fields, and ParsePacket to determine
// the frame boundaries within a packet.
package gopus
```
  </action>
  <verify>
Run `go test -v ./...` - all tests pass.
Run `go doc gopus` - package documentation displays correctly.
Run `go build ./...` - builds with no cgo (verify with `go list -f '{{.CgoFiles}}' ./...` returns empty).
  </verify>
  <done>
All packet parsing tests pass. Package documentation describes Opus structure. Project builds with zero cgo dependencies.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` - entire project compiles
2. `go test -v ./...` - all tests pass (rangecoding + packet)
3. `go list -f '{{.CgoFiles}}' ./...` - returns empty (no cgo)
4. `go doc gopus` - documentation renders correctly
5. Manual: TOC config table matches RFC 6716 Section 3.1
</verification>

<success_criteria>
- ParseTOC extracts config, mode, bandwidth, frame size, stereo, frame code
- All 32 configurations map to correct mode/bandwidth/frame size
- ParsePacket handles codes 0-3 correctly
- Two-byte frame length encoding works for lengths 252+
- Code 3 VBR, CBR, and padding all parse correctly
- Error cases return appropriate errors
- Package compiles with zero cgo dependencies
- Package documentation is complete
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
