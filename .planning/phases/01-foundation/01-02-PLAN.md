---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/rangecoding/encoder.go
  - internal/rangecoding/encoder_test.go
  - internal/rangecoding/roundtrip_test.go
autonomous: true

must_haves:
  truths:
    - "Range encoder initializes with output buffer"
    - "Range encoder encodes symbols using frequency tables"
    - "Range encoder handles carry propagation correctly"
    - "Range encoder output can be decoded by range decoder (round-trip)"
  artifacts:
    - path: "internal/rangecoding/encoder.go"
      provides: "Range encoder implementation per RFC 6716"
      exports: ["Encoder", "Init", "Encode", "EncodeBit", "Done"]
    - path: "internal/rangecoding/encoder_test.go"
      provides: "Unit tests for encoder operations"
      contains: "func Test"
    - path: "internal/rangecoding/roundtrip_test.go"
      provides: "Round-trip encode/decode verification tests"
      contains: "func TestRoundTrip"
  key_links:
    - from: "internal/rangecoding/encoder.go"
      to: "internal/rangecoding/constants.go"
      via: "import"
      pattern: "EC_CODE_"
    - from: "internal/rangecoding/roundtrip_test.go"
      to: "internal/rangecoding/decoder.go"
      via: "import and use"
      pattern: "Decoder.*Init"
---

<objective>
Implement the range encoder as the symmetric inverse of the decoder.

Purpose: The encoder is required for Opus packet encoding (Phases 6-9). It must produce output that the decoder can read correctly. Round-trip testing validates both encoder and decoder.

Output: Working range encoder that produces output decodable by the range decoder.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement range encoder core</name>
  <files>
    internal/rangecoding/encoder.go
  </files>
  <action>
Implement the range encoder following libopus entenc.c.

Create `internal/rangecoding/encoder.go` with:

1. **Encoder struct** with state fields:
   - `buf []byte` - output buffer (pre-allocated)
   - `storage uint32` - buffer capacity
   - `offs uint32` - current write offset
   - `endOffs uint32` - end offset for raw bits
   - `endWindow uint32` - window for raw bits at end
   - `nendBits int` - bits in end window
   - `nbitsTotal int` - total bits written
   - `rng uint32` - range size
   - `val uint32` - low end of range
   - `rem int` - number of carry-propagating bytes
   - `ext uint32` - buffered byte for carry propagation

2. **Init(buf []byte)** method:
   - Set buffer and storage
   - Initialize `rng = EC_CODE_TOP`
   - Initialize `val = 0`
   - Initialize `rem = -1` (sentinel)
   - Initialize `ext = 0`
   - Set `offs = 0`

3. **normalize()** method - CRITICAL for carry propagation:
   ```go
   for d.rng <= EC_CODE_BOT {
       carryOut := int(d.val >> EC_CODE_SHIFT)
       d.val = (d.val << EC_SYM_BITS) & (EC_CODE_TOP - 1)
       d.rng <<= EC_SYM_BITS
       d.nbitsTotal += EC_SYM_BITS

       if carryOut+EC_SYM_MAX >= EC_SYM_MAX {
           // Propagate carry through buffered bytes
           if d.rem >= 0 {
               d.carryOut(carryOut)
           } else {
               d.rem = carryOut
           }
       } else {
           // Flush buffered bytes plus this one
           d.flushCarry(carryOut)
       }
   }
   ```

4. **carryOut(c int)** helper:
   - Handle carry propagation through rem/ext chain
   - Write bytes when carry is resolved

5. **Encode(fl, fh, ft uint32)** method:
   - Encode symbol with cumulative frequencies [fl, fh) out of ft
   - `r := d.rng / ft`
   - If `fl > 0`: `d.val += d.rng - r*(ft-fl)`, `d.rng = r*(fh-fl)`
   - Else: `d.rng -= r*(ft-fh)`
   - Call normalize()

6. **EncodeICDF(s int, icdf []uint8, ftb uint)** method:
   - Encode symbol s using ICDF table (inverse of DecodeICDF)
   - Convert ICDF to fl, fh, ft and call Encode

7. **EncodeBit(val int, logp uint)** method:
   - Encode single bit with given log probability
   - `r := d.rng >> logp`
   - If val == 1: `d.val += r`, `d.rng -= r`
   - Else: `d.rng = r`
   - Call normalize()

8. **Done() []byte** method:
   - Finalize encoding, flush all buffered data
   - Handle final carry propagation
   - Return slice of buf containing encoded data

9. **Tell() int** and **TellFrac() int** methods:
   - Return bits written (TellFrac in 1/8 bit precision)

IMPORTANT: Carry propagation is the hardest part. When the encoder outputs a byte, it may need to add 1 to previous bytes if a carry occurs. The rem/ext mechanism buffers potential carry chains.

Follow libopus entenc.c exactly. The encoder is non-trivial due to carry handling.
  </action>
  <verify>
Run `go build ./internal/rangecoding/` - should compile without errors.
  </verify>
  <done>
Encoder struct and all methods implemented following libopus exactly, including carry propagation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add encoder unit tests</name>
  <files>
    internal/rangecoding/encoder_test.go
  </files>
  <action>
Create unit tests for the range encoder.

Create `internal/rangecoding/encoder_test.go` with:

1. **TestEncoderInit** - test initialization:
   - Init with buffer - verify initial state
   - rng should be EC_CODE_TOP
   - val should be 0

2. **TestEncodeBit** - test single bit encoding:
   - Encode known bit sequences
   - Verify output bytes are non-empty after Done()
   - Test various log probabilities

3. **TestEncodeICDF** - test ICDF encoding:
   - Create ICDF tables
   - Encode symbols
   - Verify output is produced

4. **TestEncoderTell** - verify bit counting:
   - After encoding, Tell() should reflect bits used
   - Should be consistent with expected bit usage

5. **TestEncoderDone** - verify finalization:
   - After Done(), returned slice should be valid
   - Multiple calls to Done() should be safe

Use deterministic test cases. Do not test round-trip here - that's in roundtrip_test.go.
  </action>
  <verify>
Run `go test -v -run=TestEncode ./internal/rangecoding/` - all encoder tests pass.
  </verify>
  <done>
Encoder unit tests pass. Encoder produces output and tracks bits correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add round-trip encode/decode tests</name>
  <files>
    internal/rangecoding/roundtrip_test.go
  </files>
  <action>
Create round-trip tests that validate encoder output can be decoded by decoder.

Create `internal/rangecoding/roundtrip_test.go` with:

1. **TestRoundTripBits** - round-trip single bits:
   - Create encoder, encode sequence of bits
   - Get encoded bytes via Done()
   - Create decoder, init with encoded bytes
   - Decode same sequence of bits
   - Verify decoded bits match original

2. **TestRoundTripICDF** - round-trip ICDF symbols:
   - Create various ICDF tables (uniform, skewed, Opus-like)
   - Encode sequence of symbols
   - Decode and verify match

3. **TestRoundTripMixed** - mix bits and ICDF:
   - Encode: bit, symbol, bit, symbol, ...
   - Decode in same order
   - Verify all match

4. **TestRoundTripLong** - stress test:
   - Encode 1000+ symbols
   - Decode all
   - Verify match

5. **TestRoundTripEdgeCases**:
   - Single symbol
   - Maximum buffer usage
   - Symbols that trigger carry propagation

Test pattern for each:
```go
func TestRoundTripX(t *testing.T) {
    buf := make([]byte, 1024)
    enc := &Encoder{}
    enc.Init(buf)

    // Encode sequence
    original := []int{...}
    for _, v := range original {
        enc.EncodeXxx(v, ...)
    }
    encoded := enc.Done()

    // Decode sequence
    dec := &Decoder{}
    dec.Init(encoded)
    for i, want := range original {
        got := dec.DecodeXxx(...)
        if got != want {
            t.Errorf("symbol %d: got %d, want %d", i, got, want)
        }
    }
}
```

Round-trip tests are the most important validation - they prove encoder and decoder are symmetric.
  </action>
  <verify>
Run `go test -v -run=TestRoundTrip ./internal/rangecoding/` - all round-trip tests pass.
Run `go test -v ./internal/rangecoding/` - all tests pass (unit + round-trip).
  </verify>
  <done>
Round-trip tests pass. Encoder produces output that decoder reads correctly for bits, ICDF symbols, mixed sequences, and edge cases.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` - entire project compiles
2. `go test -v ./internal/rangecoding/` - all tests pass (decoder, encoder, round-trip)
3. `go test -cover ./internal/rangecoding/` - coverage reported for encoder
4. Manual review: carry propagation logic matches libopus
</verification>

<success_criteria>
- Range encoder produces valid output bytes
- EncodeBit and EncodeICDF work correctly
- Done() finalizes and returns encoded data
- All round-trip tests pass: encode then decode recovers original
- Carry propagation handles edge cases without corruption
- Tests achieve >80% coverage of encoder code
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
