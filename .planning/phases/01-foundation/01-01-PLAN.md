---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/rangecoding/constants.go
  - internal/rangecoding/decoder.go
  - internal/rangecoding/decoder_test.go
autonomous: true

must_haves:
  truths:
    - "Range decoder initializes correctly from byte buffer"
    - "Range decoder decodes symbols using ICDF probability tables"
    - "Range decoder normalizes range to maintain precision invariant"
    - "Range decoder tracks bit consumption accurately"
  artifacts:
    - path: "internal/rangecoding/constants.go"
      provides: "EC_CODE_BITS, EC_SYM_BITS, EC_CODE_TOP, EC_CODE_BOT constants"
      contains: "EC_CODE_BITS"
    - path: "internal/rangecoding/decoder.go"
      provides: "Range decoder implementation per RFC 6716 Section 4.1"
      exports: ["Decoder", "Init", "DecodeICDF", "DecodeBit"]
    - path: "internal/rangecoding/decoder_test.go"
      provides: "Unit tests for decoder operations"
      contains: "func Test"
  key_links:
    - from: "internal/rangecoding/decoder.go"
      to: "internal/rangecoding/constants.go"
      via: "import"
      pattern: "EC_CODE_"
---

<objective>
Implement the range decoder per RFC 6716 Section 4.1.

Purpose: The range coder is the entropy coding foundation used by both SILK and CELT layers. All symbol decoding in Opus goes through this component. Bit-exact implementation is critical for spec compliance.

Output: Working range decoder that can decode symbols from probability tables, with comprehensive tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create range coder constants and project structure</name>
  <files>
    internal/rangecoding/constants.go
  </files>
  <action>
Create the internal/rangecoding package with constants matching libopus exactly.

Create `internal/rangecoding/constants.go`:
```go
package rangecoding

// Constants from RFC 6716 Section 4.1 and libopus celt/mfrngcod.h
const (
    EC_SYM_BITS   = 8                                          // Bits output at a time
    EC_CODE_BITS  = 32                                         // Total state register bits
    EC_SYM_MAX    = (1 << EC_SYM_BITS) - 1                     // 255
    EC_CODE_TOP   = 1 << (EC_CODE_BITS - 1)                    // 0x80000000
    EC_CODE_BOT   = EC_CODE_TOP >> EC_SYM_BITS                 // 0x00800000
    EC_CODE_SHIFT = EC_CODE_BITS - EC_SYM_BITS - 1             // 23
    EC_CODE_EXTRA = (EC_CODE_BITS - 2) % EC_SYM_BITS + 1       // 7
)
```

These constants must match libopus exactly - do NOT change values or "simplify" expressions.
  </action>
  <verify>
Run `go build ./internal/rangecoding/` - should compile without errors.
Verify constants with: `go test -v -run=TestConstants ./internal/rangecoding/` (add simple constant value test).
  </verify>
  <done>
Constants file exists with correct values matching libopus. Package compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement range decoder core</name>
  <files>
    internal/rangecoding/decoder.go
  </files>
  <action>
Implement the range decoder per RFC 6716 Section 4.1.

Create `internal/rangecoding/decoder.go` with:

1. **Decoder struct** with state fields:
   - `buf []byte` - input buffer
   - `storage uint32` - buffer size
   - `offs uint32` - current read offset
   - `endOffs uint32` - end offset for raw bits
   - `endWindow uint32` - window for raw bits at end
   - `nendBits int` - number of valid bits in end window
   - `nbitsTotal int` - total bits read (for tell functions)
   - `rng uint32` - range size (must stay > EC_CODE_BOT after normalize)
   - `val uint32` - current value in range
   - `rem int` - buffered partial byte
   - `err int` - error flag

2. **Init(buf []byte)** method:
   - Set buffer and storage
   - Initialize `rng = 1 << EC_CODE_EXTRA` (128)
   - Read first byte, compute initial `val = rng - 1 - (rem >> (EC_SYM_BITS - EC_CODE_EXTRA))`
   - Call normalize()
   - Set `nbitsTotal` accounting for initial read

3. **readByte()** helper:
   - If offs < storage, return buf[offs] and increment offs
   - Else return 0 (reading past end returns zeros)

4. **normalize()** method - CRITICAL:
   ```go
   for d.rng <= EC_CODE_BOT {
       d.nbitsTotal += EC_SYM_BITS
       d.rng <<= EC_SYM_BITS

       sym := d.rem
       d.rem = int(d.readByte())
       sym = (sym<<EC_SYM_BITS | d.rem) >> (EC_SYM_BITS - EC_CODE_EXTRA)

       d.val = ((d.val << EC_SYM_BITS) + uint32(EC_SYM_MAX&^sym)) & (EC_CODE_TOP - 1)
   }
   ```

5. **DecodeICDF(icdf []uint8, ftb uint) int** method:
   - Decode symbol using inverse cumulative distribution function
   - `r := d.rng >> ftb`
   - Loop through icdf to find symbol where `d.val >= r * icdf[k]`
   - Update `d.val` and `d.rng`
   - Call normalize()
   - Return symbol index

6. **DecodeBit(logp uint) int** method:
   - Decode single bit with given log probability
   - `r := d.rng >> logp`
   - If `d.val >= r`: return 1, update val and rng
   - Else: return 0, just update rng
   - Call normalize()

7. **Tell() int** and **TellFrac() int** methods:
   - Return bits consumed (TellFrac returns 1/8 bit precision)

Follow libopus entdec.c exactly. Do NOT "optimize" or change the algorithm - bit-exactness is required.
  </action>
  <verify>
Run `go build ./internal/rangecoding/` - should compile without errors.
  </verify>
  <done>
Decoder struct and all methods implemented following RFC 6716 and libopus exactly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add decoder tests</name>
  <files>
    internal/rangecoding/decoder_test.go
  </files>
  <action>
Create comprehensive tests for the range decoder.

Create `internal/rangecoding/decoder_test.go` with:

1. **TestConstants** - verify constant values match expected:
   - EC_SYM_BITS == 8
   - EC_CODE_BITS == 32
   - EC_SYM_MAX == 255
   - EC_CODE_TOP == 0x80000000
   - EC_CODE_BOT == 0x00800000
   - EC_CODE_SHIFT == 23
   - EC_CODE_EXTRA == 7

2. **TestDecoderInit** - test initialization:
   - Init with empty buffer - should not panic
   - Init with single byte - rng should be > EC_CODE_BOT after normalize
   - Init with multi-byte buffer - verify state

3. **TestDecodeBit** - test single bit decoding:
   - Create known byte sequences
   - Decode bits with various log probabilities
   - Verify expected bit values

4. **TestDecodeICDF** - test ICDF decoding:
   - Create simple ICDF tables (e.g., uniform distribution)
   - Decode symbols and verify
   - Test with Opus-like ICDF tables (values decrease from 256 to 0)

5. **TestTell** - verify bit counting:
   - After init, Tell() should return initial bit count
   - After decoding, Tell() should increase appropriately

6. **TestDecoderSequence** - decode a sequence:
   - Encode a known sequence (by hand or reference)
   - Decode and verify each symbol matches

Use table-driven tests where appropriate. Tests should be deterministic (no random data without fixed seed).
  </action>
  <verify>
Run `go test -v ./internal/rangecoding/` - all tests should pass.
Run `go test -cover ./internal/rangecoding/` - aim for >80% coverage.
  </verify>
  <done>
Tests pass. Decoder correctly initializes, decodes bits, decodes ICDF symbols, and tracks bit consumption.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` - entire project compiles
2. `go test -v ./internal/rangecoding/` - all decoder tests pass
3. `go test -cover ./internal/rangecoding/` - coverage reported
4. Manual inspection: constants match libopus values exactly
</verification>

<success_criteria>
- Range decoder initializes from byte buffer without panic
- DecodeICDF correctly decodes symbols using probability tables
- DecodeBit correctly decodes single bits with log probability
- Normalization maintains rng > EC_CODE_BOT invariant
- Tell() accurately reports bits consumed
- All tests pass with >80% coverage
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
