---
phase: 15-celt-decoder-quality
plan: 07
type: execute
wave: 2
depends_on: ["15-06"]
files_modified:
  - internal/celt/cwrs_test.go
  - internal/celt/pvq_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "CWRS DecodePulses produces correct pulse vectors for known indices"
    - "PVQ normalization produces unit-norm vectors"
    - "Round-trip encode/decode matches for PVQ vectors"
  artifacts:
    - path: "internal/celt/cwrs_test.go"
      provides: "Comprehensive CWRS decoding tests"
      contains: "TestDecodePulsesKnownVectors"
    - path: "internal/celt/pvq_test.go"
      provides: "PVQ unit vector verification tests"
      contains: "TestPVQUnitNorm"
  key_links:
    - from: "internal/celt/pvq.go"
      to: "internal/celt/cwrs.go"
      via: "DecodePulses call"
      pattern: "DecodePulses"
---

<objective>
Verify PVQ and CWRS decoding correctness by testing against known reference values

Purpose: PVQ (Pyramid Vector Quantization) is how CELT encodes band shapes. If CWRS indexing or normalization is wrong, all band coefficients will be garbage, causing Q=-100. This plan adds comprehensive tests comparing against libopus reference values.

Output: Tests verifying CWRS and PVQ correctness, identifying any encoding/decoding bugs
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-celt-decoder-quality/15-VERIFICATION.md

Key files:
@internal/celt/cwrs.go (CWRS encoding/decoding - combinatorial indexing)
@internal/celt/pvq.go (PVQ vector decoding - L2 normalization)
@internal/celt/bands.go (uses PVQ to decode band shapes)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add comprehensive CWRS test vectors</name>
  <files>internal/celt/cwrs_test.go</files>
  <action>
Add tests to cwrs_test.go that verify DecodePulses against known reference values.

1. TestDecodePulsesKnownVectors:
   Test cases derived from mathematical properties of CWRS:
   - V(n=2, k=1) = 4 codewords: [+1,0], [-1,0], [0,+1], [0,-1]
     - index=0 -> [1,0], index=1 -> [-1,0], index=2 -> [0,1], index=3 -> [0,-1]
   - V(n=3, k=1) = 6 codewords
   - V(n=3, k=2) = 18 codewords (verify a few)
   - V(n=4, k=2) = 32 codewords (verify a few)

2. TestDecodePulsesSymmetry:
   - Verify that all codewords have sum(|pulses|) == k
   - Verify that sign patterns are handled correctly
   - For n=2, k=2: [2,0], [-2,0], [0,2], [0,-2], [1,1], [1,-1], [-1,1], [-1,-1]

3. TestEncodePulsesRoundtrip:
   - For various (n, k) pairs, enumerate all valid pulse vectors
   - Encode each, then decode
   - Verify round-trip produces original vector

4. TestPVQ_VRecurrence:
   - Verify V(n,k) = V(n-1,k) + V(n,k-1) + V(n-1,k-1)
   - Test boundary conditions: V(n,0)=1, V(1,k)=2, V(0,k)=0

Expected failures to look for:
- Off-by-one in index calculation
- Incorrect sign bit extraction
- Wrong recurrence for V(n,k)
- Edge case handling for k=0 or n=1
  </action>
  <verify>go test -v ./internal/celt/... -run TestDecodePulses -count=1</verify>
  <done>CWRS tests exist and all pass, confirming DecodePulses is correct for known vectors</done>
</task>

<task type="auto">
  <name>Task 2: Add PVQ normalization and integration tests</name>
  <files>internal/celt/pvq_test.go</files>
  <action>
Create pvq_test.go (or add to existing) with tests for PVQ decoding correctness.

1. TestNormalizeVectorUnit:
   - Various input vectors -> verify output has L2 norm = 1.0 (within tolerance)
   - Edge cases: zero vector, single element, large values

2. TestPVQUnitNorm:
   - For various (n, k) combinations:
     - Call DecodePVQ(n, k) with a mock range decoder returning known indices
     - Verify result has L2 norm = 1.0 (within 1e-6 tolerance)
   - Test n=8, k=4 (typical band size)
   - Test n=16, k=8 (larger band)
   - Test n=4, k=1 (small band, few pulses)

3. TestPVQDeterminism:
   - Same index, n, k -> always same output
   - Initialize decoder with same bytes twice, decode same n, k -> same result

4. TestPVQEnergyDistribution:
   - Decode many random indices for (n=8, k=4)
   - Verify energy is distributed across bins (not concentrated in one)
   - This catches bugs where all pulses go to same position

Create a mock range decoder for testing:
```go
type mockRangeDecoder struct {
    uniformValue uint32
}
func (m *mockRangeDecoder) DecodeUniform(ft uint32) uint32 {
    if m.uniformValue >= ft {
        return ft - 1
    }
    return m.uniformValue
}
```
  </action>
  <verify>go test -v ./internal/celt/... -run TestPVQ -count=1 and -run TestNormalize -count=1</verify>
  <done>PVQ tests exist and pass, confirming normalization and decode correctness</done>
</task>

<task type="auto">
  <name>Task 3: Test bitsToK and bit allocation integration</name>
  <files>internal/celt/bands_test.go</files>
  <action>
Add tests to bands_test.go verifying bit allocation to pulse count conversion.

1. TestBitsToKBoundaries:
   - Test bitsToK edge cases:
     - bits=0 -> k=0
     - bits < minBits -> k=0
     - bits just above threshold -> k=1
   - For n=8: find minimum bits needed for k=1, k=2, k=4

2. TestBitsToKMonotonic:
   - For fixed n, verify bitsToK(bits, n) is monotonically non-decreasing
   - More bits should never result in fewer pulses

3. TestKToBitsRoundtrip:
   - For k in 1..10 and n in 2..20:
     - Compute bits = kToBits(k, n)
     - Verify bitsToK(bits, n) >= k (can encode at least k pulses)
     - Verify bitsToK(bits-1, n) < k (bits-1 is not enough)

4. TestDecodeBandsWithKnownEnergy:
   - Create synthetic energies (all zeros, known values)
   - Decode bands with minimal allocation (k=1 per band)
   - Verify output is non-zero and has correct structure
   - Compare against expected coefficient pattern

This tests the critical path: allocation -> k -> PVQ -> coefficients
  </action>
  <verify>go test -v ./internal/celt/... -run TestBitsToK -count=1 and -run TestDecodeBands -count=1</verify>
  <done>Bit allocation tests pass, confirming bits -> k -> PVQ path is correct</done>
</task>

</tasks>

<verification>
- All new tests pass: `go test ./internal/celt/... -count=1`
- CWRS DecodePulses matches expected vectors for known indices
- PVQ output always has unit L2 norm
- bitsToK is monotonic and correctly maps bits to pulse counts
- No panics or errors in edge cases
</verification>

<success_criteria>
- CWRS indexing verified correct for small (n, k) where hand-computation is possible
- PVQ normalization produces unit vectors for all tested cases
- bitsToK correctly converts bit allocation to pulse count
- If any test fails, root cause of Q=-100 may be identified
</success_criteria>

<output>
After completion, create `.planning/phases/15-celt-decoder-quality/15-07-SUMMARY.md`
</output>
