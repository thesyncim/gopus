---
phase: 15-celt-decoder-quality
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/celt/decoder_test.go
  - internal/celt/debug_trace.go
  - internal/celt/debug_trace_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Debug tracing captures all CELT decoding pipeline stages"
    - "Trace output shows intermediate values at each decoding step"
    - "Trace can be compared with libopus reference values"
  artifacts:
    - path: "internal/celt/debug_trace.go"
      provides: "Debug tracing infrastructure for CELT decoder"
      min_lines: 100
    - path: "internal/celt/debug_trace_test.go"
      provides: "Tests for trace output format and content"
      min_lines: 50
    - path: "internal/celt/decoder_test.go"
      provides: "Test that runs single packet with trace enabled"
      contains: "TestDecodeWithTrace"
  key_links:
    - from: "internal/celt/debug_trace.go"
      to: "internal/celt/decoder.go"
      via: "Trace calls from decoder methods"
      pattern: "Trace"
---

<objective>
Add comprehensive debug tracing to the CELT decoder pipeline to identify where decoded values diverge from reference

Purpose: The Q=-100 failure indicates complete output mismatch. Without visibility into intermediate values, we cannot identify which stage (energy, allocation, PVQ, synthesis) is producing incorrect results. This plan adds trace infrastructure that outputs key values at each decoding stage.

Output: Debug trace infrastructure + trace-enabled test + sample trace output identifying divergence points
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-celt-decoder-quality/15-VERIFICATION.md

Prior work (do NOT repeat):
- 15-01: Fixed BetaCoef coefficients
- 15-02: Fixed range decoder DecodeSymbol
- 15-03: Verified denormalization formula
- 15-04: Verified IMDCT implementation
- 15-05: Verified all frame sizes decode without crashes

These were all structurally correct, but Q=-100 persists. Root cause unknown.

Key files to trace:
@internal/celt/decoder.go (main decode pipeline)
@internal/celt/energy.go (coarse/fine energy decoding)
@internal/celt/bands.go (band decoding, PVQ dispatch)
@internal/celt/pvq.go (PVQ vector decoding)
@internal/celt/cwrs.go (pulse vector decoding)
@internal/celt/alloc.go (bit allocation)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create debug trace infrastructure</name>
  <files>internal/celt/debug_trace.go</files>
  <action>
Create a new file `internal/celt/debug_trace.go` that provides tracing infrastructure:

1. Define a `Tracer` interface with methods:
   - `TraceHeader(frameSize, channels, lm, intra, transient int)` - log frame header
   - `TraceEnergy(band int, coarse, fine, total float64)` - log per-band energy
   - `TraceAllocation(band, bits, k int)` - log bit allocation and pulse count
   - `TracePVQ(band int, index uint32, k, n int, pulses []int)` - log PVQ decode
   - `TraceCoeffs(band int, coeffs []float64)` - log denormalized coefficients
   - `TraceSynthesis(stage string, samples []float64)` - log synthesis stages

2. Define `NoopTracer` that implements Tracer with empty methods (default)

3. Define `LogTracer` that implements Tracer by writing to a provided io.Writer:
   - Format: `[CELT:stage] key=value key=value ...`
   - For arrays, output first 8 values + "..."
   - Include frame byte offset for comparison with libopus

4. Add a global `var DefaultTracer Tracer = &NoopTracer{}`

5. Add `func SetTracer(t Tracer)` to set the global tracer

Example trace output format:
```
[CELT:header] frameSize=960 channels=2 lm=3 intra=false transient=false
[CELT:energy] band=0 coarse=-12.3 fine=0.2 total=-12.1
[CELT:alloc] band=0 bits=24 k=3
[CELT:pvq] band=0 index=1234 k=3 n=8 pulses=[1,-1,0,1,0,0,0,0]
[CELT:coeffs] band=0 coeffs=[0.12,-0.08,0.03,0.15,-0.02,0.01,-0.04,0.07]
[CELT:synthesis] stage=imdct samples=[0.001,-0.002,0.003...]
```
  </action>
  <verify>go build ./internal/celt/... compiles without errors</verify>
  <done>debug_trace.go exists with Tracer interface, NoopTracer, LogTracer, and global setter</done>
</task>

<task type="auto">
  <name>Task 2: Add trace calls to decoder pipeline</name>
  <files>internal/celt/decoder.go, internal/celt/energy.go, internal/celt/bands.go, internal/celt/pvq.go</files>
  <action>
Add trace calls at key points in the decoding pipeline. Use the global DefaultTracer so tracing is no-op by default.

In decoder.go DecodeFrame():
1. After decoding header flags: `DefaultTracer.TraceHeader(frameSize, d.channels, lm, boolToInt(intra), boolToInt(transient))`
2. After DecodeCoarseEnergy: trace will be called inside energy.go
3. After ComputeAllocation: for each band, `DefaultTracer.TraceAllocation(band, allocResult.BandBits[band], pulseCount)`
4. After DecodeBands: will be traced inside bands.go
5. After Synthesize: `DefaultTracer.TraceSynthesis("final", samples[:min(16, len(samples))])`

In energy.go DecodeCoarseEnergy():
1. After each band's energy is computed: `DefaultTracer.TraceEnergy(band, pred, float64(qi)*DB6, energy)`

In energy.go DecodeFineEnergy():
1. After each band's fine energy: `DefaultTracer.TraceEnergy(band, 0, offset*DB6, energies[idx])` (fine only)

In bands.go DecodeBands():
1. After PVQ decoding for each band: `DefaultTracer.TracePVQ(band, index, k, n, pulses)`
2. After denormalization for each band: `DefaultTracer.TraceCoeffs(band, coeffs[offset:offset+n])`

In pvq.go DecodePVQ():
1. After reading index: trace index value (will be traced from bands.go)
2. After DecodePulses: trace pulse vector (will be traced from bands.go)

Add helper function boolToInt(b bool) int in decoder.go.
  </action>
  <verify>go test -v ./internal/celt/... -run TestDecodeFrame -count=1 passes (tracing is no-op by default)</verify>
  <done>Trace calls added to decoder.go, energy.go, bands.go. Tests still pass (tracing disabled by default).</done>
</task>

<task type="auto">
  <name>Task 3: Create trace-enabled test and capture sample output</name>
  <files>internal/celt/debug_trace_test.go, internal/celt/decoder_test.go</files>
  <action>
1. Create debug_trace_test.go with:
   - TestLogTracerFormat: verify trace output format is correct
   - TestTracerInterface: verify all Tracer methods are called during decode

2. Add to decoder_test.go:
   - TestDecodeWithTrace: runs a single known CELT packet with tracing enabled
     - Use a minimal valid CELT packet (can be synthesized or extracted from test vectors)
     - Enable LogTracer writing to bytes.Buffer
     - Decode the packet
     - Verify trace output contains expected sections: [CELT:header], [CELT:energy], [CELT:alloc], [CELT:pvq], [CELT:coeffs]
     - Log the trace output for manual inspection

3. The test output will serve as documentation of current decoder behavior, enabling comparison with libopus.

Example test structure:
```go
func TestDecodeWithTrace(t *testing.T) {
    // Create trace buffer
    var buf bytes.Buffer
    SetTracer(&LogTracer{W: &buf})
    defer SetTracer(&NoopTracer{})

    // Create decoder
    dec := NewDecoder(1) // mono

    // Decode a minimal packet (2.5ms silence frame)
    data := []byte{0x00} // silence flag set
    samples, err := dec.DecodeFrame(data, 120)
    require.NoError(t, err)
    require.Len(t, samples, 120)

    // Verify trace output exists
    trace := buf.String()
    t.Logf("Trace output:\n%s", trace)
    assert.Contains(t, trace, "[CELT:header]")
}
```
  </action>
  <verify>go test -v ./internal/celt/... -run TestDecodeWithTrace -count=1 passes and outputs trace</verify>
  <done>TestDecodeWithTrace exists and outputs trace for manual inspection. Trace shows all pipeline stages.</done>
</task>

</tasks>

<verification>
- All tests in internal/celt pass: `go test ./internal/celt/... -count=1`
- TestDecodeWithTrace produces trace output showing all stages
- Trace format is consistent and parseable
- No performance impact when tracing disabled (NoopTracer)
</verification>

<success_criteria>
- Debug trace infrastructure exists and is documented
- Trace captures header, energy, allocation, PVQ, coefficients, synthesis
- Running with LogTracer shows intermediate values
- Trace output can be compared with libopus reference for divergence identification
- Tests still pass when tracing disabled
</success_criteria>

<output>
After completion, create `.planning/phases/15-celt-decoder-quality/15-06-SUMMARY.md`
</output>
