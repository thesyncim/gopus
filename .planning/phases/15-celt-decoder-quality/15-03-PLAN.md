---
phase: 15-celt-decoder-quality
plan: 03
type: execute
wave: 2
depends_on:
  - "15-01"
  - "15-02"
files_modified:
  - internal/celt/bands.go
  - internal/celt/bands_test.go
autonomous: true

must_haves:
  truths:
    - "Denormalization uses exp2(energy) correctly"
    - "Band coefficients have correct amplitude after denormalization"
    - "Energy scale is log2-based as per libopus"
  artifacts:
    - path: "internal/celt/bands.go"
      provides: "Verified denormalization formula"
      contains: "math.Exp2"
    - path: "internal/celt/bands_test.go"
      provides: "Denormalization validation tests"
      contains: "TestDenormalize"
  key_links:
    - from: "internal/celt/bands.go"
      to: "internal/celt/energy.go"
      via: "energy values from DecodeCoarseEnergy"
      pattern: "energies\\[band\\]"
---

<objective>
Verify and fix denormalization formula for correct amplitude scaling

Purpose: Denormalization converts normalized band shapes (unit vectors from PVQ) to actual MDCT coefficients by scaling by energy. The current code uses `math.Exp(energy * ln2)` which equals `math.Exp2(energy)`. This appears mathematically correct but needs verification against libopus to ensure energy scale assumptions are correct.

Output: Verified denormalization that produces correct amplitude coefficients matching libopus celt/bands.c denormalise_bands().
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-celt-decoder-quality/15-RESEARCH.md
@internal/celt/bands.go
@internal/celt/energy.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor denormalization to use math.Exp2 explicitly</name>
  <files>internal/celt/bands.go</files>
  <action>
Replace the current denormalization calculation with explicit math.Exp2 for clarity and correctness.

Current code in multiple places:
```go
gain := math.Exp(energies[band] * 0.6931471805599453) // ln(2)
```

Replace with:
```go
gain := math.Exp2(energies[band])
```

This is mathematically equivalent but clearer. Apply this change in:
1. DecodeBands() - lines 93-95
2. DecodeBandsStereo() - lines 232-233
3. DenormalizeBand() - line 349

Also add a comment explaining the energy scale:
```go
// Denormalize: scale shape by energy
// Energy is in log2 scale (not dB): gain = 2^energy
// This matches libopus celt/bands.c denormalise_bands()
gain := math.Exp2(energies[band])
```

Additionally, add bounds checking to prevent extreme values:
```go
// Clamp energy to prevent overflow (libopus clamps to 32)
e := energies[band]
if e > 32 {
    e = 32
}
gain := math.Exp2(e)
```
  </action>
  <verify>go build ./internal/celt/... compiles without error</verify>
  <done>All denormalization uses math.Exp2 explicitly with energy clamped to prevent overflow</done>
</task>

<task type="auto">
  <name>Task 2: Add denormalization accuracy tests</name>
  <files>internal/celt/bands_test.go</files>
  <action>
Add tests verifying denormalization produces correct amplitudes:

```go
package celt

import (
    "math"
    "testing"
)

func TestDenormalizeBand(t *testing.T) {
    tests := []struct {
        name     string
        shape    []float64
        energy   float64
        wantGain float64 // Expected gain = 2^energy
    }{
        {
            name:     "zero energy",
            shape:    []float64{1.0, 0.0, 0.0},
            energy:   0.0,
            wantGain: 1.0, // 2^0 = 1
        },
        {
            name:     "positive energy",
            shape:    []float64{0.5, 0.5, 0.5, 0.5},
            energy:   3.0,
            wantGain: 8.0, // 2^3 = 8
        },
        {
            name:     "negative energy",
            shape:    []float64{1.0},
            energy:   -2.0,
            wantGain: 0.25, // 2^-2 = 0.25
        },
        {
            name:     "fractional energy",
            shape:    []float64{0.707, 0.707},
            energy:   1.5,
            wantGain: 2.828, // 2^1.5 ~= 2.828
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := DenormalizeBand(tt.shape, tt.energy)

            if len(result) != len(tt.shape) {
                t.Fatalf("len(result) = %d, want %d", len(result), len(tt.shape))
            }

            // Check that result[i] = shape[i] * gain
            actualGain := 0.0
            if tt.shape[0] != 0 {
                actualGain = result[0] / tt.shape[0]
            }

            tolerance := 0.01
            if math.Abs(actualGain-tt.wantGain) > tolerance {
                t.Errorf("gain = %v, want %v (tolerance %v)", actualGain, tt.wantGain, tolerance)
            }
        })
    }
}

func TestDenormalizeEnergyClamping(t *testing.T) {
    // Test that extreme energies don't cause overflow
    shape := []float64{1.0}

    // Very high energy should be clamped
    resultHigh := DenormalizeBand(shape, 100.0)
    if math.IsInf(resultHigh[0], 0) || math.IsNaN(resultHigh[0]) {
        t.Error("High energy caused overflow or NaN")
    }
    // Expect clamped to 2^32
    if resultHigh[0] > math.Exp2(33) {
        t.Errorf("High energy not clamped: got %v", resultHigh[0])
    }

    // Very low energy should still work
    resultLow := DenormalizeBand(shape, -100.0)
    if math.IsNaN(resultLow[0]) {
        t.Error("Low energy caused NaN")
    }
    // Should be very small but not zero
    if resultLow[0] == 0 && shape[0] != 0 {
        t.Log("Low energy resulted in zero (may be expected due to underflow)")
    }
}

func TestComputeBandEnergy(t *testing.T) {
    // Test round-trip: ComputeBandEnergy -> DenormalizeBand should preserve scale
    tests := []struct {
        name   string
        coeffs []float64
    }{
        {
            name:   "unit vector",
            coeffs: []float64{1.0, 0.0, 0.0, 0.0},
        },
        {
            name:   "scaled vector",
            coeffs: []float64{4.0, 3.0, 0.0},
        },
        {
            name:   "negative values",
            coeffs: []float64{-2.0, 2.0, -2.0, 2.0},
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Compute energy
            energy := ComputeBandEnergy(tt.coeffs)

            // Normalize to unit vector
            norm := 0.0
            for _, c := range tt.coeffs {
                norm += c * c
            }
            norm = math.Sqrt(norm)
            if norm == 0 {
                return
            }

            shape := make([]float64, len(tt.coeffs))
            for i, c := range tt.coeffs {
                shape[i] = c / norm
            }

            // Denormalize back
            result := DenormalizeBand(shape, energy)

            // Should get approximately original coefficients
            for i := range tt.coeffs {
                if math.Abs(result[i]-tt.coeffs[i]) > 0.1 {
                    t.Errorf("coeff[%d] = %v, want %v", i, result[i], tt.coeffs[i])
                }
            }
        })
    }
}
```
  </action>
  <verify>go test ./internal/celt/... -run "TestDenormalize|TestComputeBandEnergy" -v passes</verify>
  <done>Denormalization tests pass, verifying energy scale and amplitude accuracy</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles successfully
- `go test ./internal/celt/... -v` passes all tests
- DenormalizeBand(shape, 0) returns shape * 1.0
- DenormalizeBand(shape, 3) returns shape * 8.0
- Extreme energies don't cause overflow/NaN
</verification>

<success_criteria>
- Denormalization uses math.Exp2 explicitly (no ln2 constant needed)
- Energy values are clamped to prevent overflow
- Round-trip energy compute -> denormalize preserves amplitudes
- Tests validate energy scale assumptions
</success_criteria>

<output>
After completion, create `.planning/phases/15-celt-decoder-quality/15-03-SUMMARY.md`
</output>
