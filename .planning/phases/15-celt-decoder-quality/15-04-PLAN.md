---
phase: 15-celt-decoder-quality
plan: 04
type: execute
wave: 2
depends_on:
  - "15-01"
  - "15-02"
files_modified:
  - internal/celt/mdct.go
  - internal/celt/window.go
  - internal/celt/mdct_test.go
autonomous: true

must_haves:
  truths:
    - "IMDCT produces correct output for CELT sizes (120, 240, 480, 960)"
    - "Windowing applies correct Vorbis window coefficients"
    - "Overlap-add produces correct sample count per frame size"
  artifacts:
    - path: "internal/celt/mdct.go"
      provides: "Verified IMDCT implementation"
      contains: "IMDCTDirect"
    - path: "internal/celt/window.go"
      provides: "Vorbis window coefficients"
      contains: "ApplyWindow"
    - path: "internal/celt/mdct_test.go"
      provides: "IMDCT verification tests"
      contains: "TestIMDCT"
  key_links:
    - from: "internal/celt/synthesis.go"
      to: "internal/celt/mdct.go"
      via: "IMDCT call"
      pattern: "IMDCT\\(coeffs\\)"
---

<objective>
Verify and fix IMDCT synthesis for all CELT frame sizes

Purpose: CELT uses non-power-of-2 MDCT sizes (120, 240, 480, 960 samples). The current implementation falls back to IMDCTDirect() for these sizes. This plan verifies the IMDCT formula matches RFC 6716 Section 4.3.5 exactly, confirms Vorbis window coefficients are correct, and ensures overlap-add produces the right sample count for each frame size. Incorrect IMDCT causes Q=-100 regardless of energy decoding correctness.

Output: Verified IMDCT synthesis that produces correct sample counts and waveforms for all CELT frame sizes (2.5ms, 5ms, 10ms, 20ms).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-celt-decoder-quality/15-RESEARCH.md
@internal/celt/mdct.go
@internal/celt/window.go
@internal/celt/synthesis.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify IMDCTDirect formula matches RFC 6716</name>
  <files>internal/celt/mdct.go</files>
  <action>
Verify the IMDCTDirect() function matches the exact formula from RFC 6716 Section 4.3.5:

Expected formula:
```
y[n] = sum_{k=0}^{N-1} X[k] * cos(pi/N * (n + 0.5 + N/2) * (k + 0.5))
```

Current implementation should match. Verify:
1. The angle calculation is: `pi/N * (n + 0.5 + N/2) * (k + 0.5)`
2. Normalization factor is `2.0/N` (or verify against libopus)
3. Output length is exactly `2*N` samples

If any mismatch is found, fix the formula. Also ensure:
- For CELT sizes (120, 240, 480, 960), IMDCTDirect is used (not FFT path)
- No off-by-one errors in loop bounds

Add a comment at the top of IMDCTDirect referencing RFC 6716:
```go
// IMDCTDirect computes IMDCT per RFC 6716 Section 4.3.5.
// Formula: y[n] = sum_{k=0}^{N-1} X[k] * cos(pi/N * (n + 0.5 + N/2) * (k + 0.5))
// Input: N frequency coefficients
// Output: 2*N time samples
// Normalization: 2/N factor applied for proper amplitude
```
  </action>
  <verify>go build ./internal/celt/... compiles without error</verify>
  <done>IMDCTDirect matches RFC 6716 Section 4.3.5 formula exactly with correct normalization</done>
</task>

<task type="auto">
  <name>Task 2: Add IMDCT verification tests for all CELT sizes</name>
  <files>internal/celt/mdct_test.go</files>
  <action>
Add tests that verify IMDCT produces correct output for all CELT frame sizes:

```go
package celt

import (
    "math"
    "testing"
)

func TestIMDCTOutputLength(t *testing.T) {
    // CELT frame sizes: 120 (2.5ms), 240 (5ms), 480 (10ms), 960 (20ms)
    sizes := []int{120, 240, 480, 960}

    for _, n := range sizes {
        t.Run(fmt.Sprintf("N=%d", n), func(t *testing.T) {
            // Create test spectrum (all zeros except first bin)
            spectrum := make([]float64, n)
            spectrum[0] = 1.0

            output := IMDCT(spectrum)

            expectedLen := 2 * n
            if len(output) != expectedLen {
                t.Errorf("IMDCT(%d) produced %d samples, want %d",
                    n, len(output), expectedLen)
            }
        })
    }
}

func TestIMDCTEnergy Conservation(t *testing.T) {
    // Parseval's theorem: energy should be conserved (within factor)
    sizes := []int{120, 240, 480, 960}

    for _, n := range sizes {
        t.Run(fmt.Sprintf("N=%d", n), func(t *testing.T) {
            // Random-ish test spectrum
            spectrum := make([]float64, n)
            for i := range spectrum {
                spectrum[i] = math.Sin(float64(i) * 0.1)
            }

            // Input energy (frequency domain)
            inputEnergy := 0.0
            for _, x := range spectrum {
                inputEnergy += x * x
            }

            output := IMDCT(spectrum)

            // Output energy (time domain)
            outputEnergy := 0.0
            for _, x := range output {
                outputEnergy += x * x
            }

            // Ratio should be approximately constant (depends on normalization)
            // For proper IMDCT with 2/N normalization, ratio ~ 4/N
            ratio := outputEnergy / inputEnergy
            expectedRatio := 4.0 / float64(n)

            // Allow 50% tolerance due to normalization conventions
            if ratio < expectedRatio*0.5 || ratio > expectedRatio*2.0 {
                t.Errorf("Energy ratio %f outside expected range [%f, %f]",
                    ratio, expectedRatio*0.5, expectedRatio*2.0)
            }
        })
    }
}

func TestIMDCTDCComponent(t *testing.T) {
    // A DC component (spectrum[0]=1, rest 0) should produce specific pattern
    sizes := []int{120, 240, 480, 960}

    for _, n := range sizes {
        t.Run(fmt.Sprintf("N=%d", n), func(t *testing.T) {
            spectrum := make([]float64, n)
            spectrum[0] = 1.0

            output := IMDCT(spectrum)

            // DC component should produce non-zero output
            hasNonZero := false
            for _, x := range output {
                if math.Abs(x) > 1e-10 {
                    hasNonZero = true
                    break
                }
            }

            if !hasNonZero {
                t.Error("IMDCT of DC component produced all zeros")
            }
        })
    }
}

func TestIMDCTDirectVsFFT(t *testing.T) {
    // For power-of-2 sizes, compare FFT-based and direct results
    n := 256 // Power of 2

    spectrum := make([]float64, n)
    for i := range spectrum {
        spectrum[i] = math.Sin(float64(i) * 0.1)
    }

    directOut := IMDCTDirect(spectrum)

    // FFT path (if implemented)
    // Compare outputs for consistency
    // This test ensures our direct implementation is correct

    if len(directOut) != 2*n {
        t.Errorf("IMDCTDirect produced %d samples, want %d", len(directOut), 2*n)
    }
}
```
  </action>
  <verify>go test ./internal/celt/... -run "TestIMDCT" -v passes</verify>
  <done>IMDCT tests verify correct output length, energy conservation, and DC response for all CELT sizes</done>
</task>

<task type="auto">
  <name>Task 3: Verify Vorbis window and overlap-add</name>
  <files>internal/celt/window.go, internal/celt/mdct_test.go</files>
  <action>
Verify the Vorbis window coefficients and overlap-add operation:

1. Check window.go ApplyWindow function:
   - Vorbis window: w[n] = sin(pi/2 * sin^2(pi*(n+0.5)/N))
   - Window should be applied to first and last 'overlap' samples (120 at 48kHz)
   - Middle samples should NOT be windowed

2. Add window verification test to mdct_test.go:

```go
func TestVorbisWindow(t *testing.T) {
    overlap := 120 // CELT overlap at 48kHz

    // Generate window coefficients
    window := make([]float64, overlap)
    for n := 0; n < overlap; n++ {
        // Vorbis window formula
        inner := math.Pi * (float64(n) + 0.5) / float64(2*overlap)
        window[n] = math.Sin(math.Pi/2 * math.Pow(math.Sin(inner), 2))
    }

    // Verify window properties
    // 1. Window starts near 0
    if window[0] > 0.1 {
        t.Errorf("Window start too high: %f", window[0])
    }

    // 2. Window ends near 1
    if window[overlap-1] < 0.9 {
        t.Errorf("Window end too low: %f", window[overlap-1])
    }

    // 3. Window is monotonically increasing
    for n := 1; n < overlap; n++ {
        if window[n] < window[n-1] {
            t.Errorf("Window not monotonic at n=%d: %f < %f",
                n, window[n], window[n-1])
        }
    }

    // 4. Window satisfies perfect reconstruction:
    // w[n]^2 + w[overlap-1-n]^2 = 1
    for n := 0; n < overlap/2; n++ {
        sum := window[n]*window[n] + window[overlap-1-n]*window[overlap-1-n]
        if math.Abs(sum-1.0) > 0.01 {
            t.Errorf("Window reconstruction failed at n=%d: %f + %f = %f",
                n, window[n]*window[n], window[overlap-1-n]*window[overlap-1-n], sum)
        }
    }
}

func TestOverlapAddSampleCount(t *testing.T) {
    // Verify overlap-add produces correct sample count
    frameSizes := []int{120, 240, 480, 960}
    overlap := 120

    for _, frameSize := range frameSizes {
        t.Run(fmt.Sprintf("frame=%d", frameSize), func(t *testing.T) {
            // Simulate IMDCT output (2*frameSize samples)
            imdctOut := make([]float64, 2*frameSize)
            for i := range imdctOut {
                imdctOut[i] = float64(i) // Arbitrary values
            }

            // Previous overlap buffer
            prevOverlap := make([]float64, overlap)

            // Perform overlap-add
            output, newOverlap := OverlapAdd(imdctOut, prevOverlap, overlap)

            // Output should be frameSize samples
            if len(output) != frameSize {
                t.Errorf("OverlapAdd produced %d samples, want %d",
                    len(output), frameSize)
            }

            // New overlap should be overlap samples
            if len(newOverlap) != overlap {
                t.Errorf("New overlap has %d samples, want %d",
                    len(newOverlap), overlap)
            }
        })
    }
}
```

3. If any issues found in ApplyWindow or OverlapAdd, fix them.
  </action>
  <verify>go test ./internal/celt/... -run "TestVorbisWindow|TestOverlapAdd" -v passes</verify>
  <done>Vorbis window matches RFC 6716 specification, overlap-add produces correct sample counts</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles successfully
- `go test ./internal/celt/... -v` passes all tests
- IMDCT produces 2*N samples for all CELT sizes (120, 240, 480, 960)
- Window coefficients satisfy perfect reconstruction property
- Overlap-add produces frameSize samples per frame
</verification>

<success_criteria>
- IMDCTDirect formula verified against RFC 6716 Section 4.3.5
- All CELT frame sizes (120, 240, 480, 960) produce correct output length
- Vorbis window satisfies perfect reconstruction constraint
- Energy conservation verified within expected tolerance
</success_criteria>

<output>
After completion, create `.planning/phases/15-celt-decoder-quality/15-04-SUMMARY.md`
</output>
