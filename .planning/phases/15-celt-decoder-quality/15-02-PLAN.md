---
phase: 15-celt-decoder-quality
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/celt/energy.go
  - internal/rangecoding/decoder.go
  - internal/celt/energy_test.go
autonomous: true

must_haves:
  truths:
    - "Range decoder state updates correctly after Laplace symbol decode"
    - "Laplace decoding consumes correct entropy for each symbol"
    - "Energy decoding produces values within expected range"
  artifacts:
    - path: "internal/celt/energy.go"
      provides: "Fixed updateRange using proper range decoder API"
      contains: "DecodeSymbol"
    - path: "internal/rangecoding/decoder.go"
      provides: "DecodeSymbol method for proper updates"
      contains: "func.*DecodeSymbol"
    - path: "internal/celt/energy_test.go"
      provides: "Tests for range decoder integration"
      contains: "TestLaplaceDecode"
  key_links:
    - from: "internal/celt/energy.go"
      to: "internal/rangecoding/decoder.go"
      via: "DecodeSymbol call"
      pattern: "rd\\.DecodeSymbol"
---

<objective>
Fix range decoder integration for Laplace energy decoding

Purpose: The current updateRange() function uses a broken approximation with DecodeBit() calls instead of properly updating the range decoder state. This causes bitstream desynchronization - the decoder loses track of where it is in the entropy-coded data. This is the second-highest priority fix - after prediction coefficients, range decoder sync is critical.

Output: Proper range decoder state updates using DecodeSymbol API, matching libopus ec_dec_update() behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-celt-decoder-quality/15-RESEARCH.md
@internal/celt/energy.go
@internal/rangecoding/decoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DecodeSymbol method to rangecoding.Decoder</name>
  <files>internal/rangecoding/decoder.go</files>
  <action>
Add a DecodeSymbol method that properly updates range decoder state after decoding a symbol. This matches libopus ec_dec_update() semantics.

First, check if DecodeSymbol already exists. If not, add:

```go
// DecodeSymbol decodes a symbol given cumulative frequencies and updates state.
// fl: cumulative frequency of symbols before this one
// fh: frequency of this symbol (fl + fh <= ft)
// ft: total frequency (sum of all symbol frequencies)
//
// This implements the range decoder update: rng = s * fh, val = val - s * fl
// where s = rng / ft (the scale factor).
//
// Reference: libopus celt/entdec.c ec_dec_update()
func (d *Decoder) DecodeSymbol(fl, fh, ft uint32) {
    if ft == 0 {
        return
    }

    // Scale factor
    s := d.rng / ft

    // Update val: subtract cumulative frequency of symbols before this one
    d.val -= s * fl

    // Update range: new range is s * fh (the frequency of this symbol)
    if fl+fh >= ft {
        // Last symbol: use remaining range to avoid precision loss
        d.rng -= s * fl
    } else {
        d.rng = s * fh
    }

    // Renormalize if needed
    d.normalize()
}
```

If the Decoder struct uses different field names (e.g., Range, Val), adjust accordingly.
Also ensure normalize() or equivalent renormalization is called.
  </action>
  <verify>go build ./internal/rangecoding/... compiles without error</verify>
  <done>DecodeSymbol method exists and properly updates range and val fields</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite updateRange to use DecodeSymbol</name>
  <files>internal/celt/energy.go</files>
  <action>
Replace the broken updateRange() implementation with proper range decoder state update:

Current broken code (DELETE THIS):
```go
func (d *Decoder) updateRange(fl, fh, ft uint32) {
    rd := d.rangeDecoder
    if rd == nil {
        return
    }
    // BROKEN: uses DecodeBit approximation
    if fh > 0 && ft > 0 {
        ratio := float64(ft) / float64(fh)
        bits := 0
        for ratio > 2 && bits < 16 {
            ratio /= 2
            bits++
        }
        for i := 0; i < bits; i++ {
            rd.DecodeBit(1)
        }
    }
}
```

Replace with:
```go
// updateRange updates the range decoder state after decoding a symbol.
// fl: cumulative frequency of symbols before this one
// fh: frequency of this symbol
// ft: total frequency
func (d *Decoder) updateRange(fl, fh, ft uint32) {
    rd := d.rangeDecoder
    if rd == nil {
        return
    }
    rd.DecodeSymbol(fl, fh, ft)
}
```

This delegates to the proper rangecoding.Decoder.DecodeSymbol() method.
  </action>
  <verify>go build ./internal/celt/... compiles without error</verify>
  <done>updateRange calls rd.DecodeSymbol instead of DecodeBit approximation</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for Laplace decoding entropy consumption</name>
  <files>internal/celt/energy_test.go</files>
  <action>
Add or update tests to verify Laplace decoding consumes correct entropy:

```go
package celt

import (
    "testing"
    "github.com/thesyncim/gopus/internal/rangecoding"
)

func TestLaplaceDecodeEntropyConsumption(t *testing.T) {
    // Test that decoding a Laplace symbol consumes reasonable entropy
    // A symbol with probability p should consume approximately -log2(p) bits

    // Create test data - a simple packet that encodes some energy values
    testData := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

    d := NewDecoder(1)
    rd := &rangecoding.Decoder{}
    rd.Init(testData)
    d.SetRangeDecoder(rd)

    initialBits := rd.Tell()

    // Decode a Laplace value
    decay := 16384
    _ = d.decodeLaplace(laplaceFS, decay)

    consumedBits := rd.Tell() - initialBits

    // Should consume at least 1 bit for any symbol
    if consumedBits < 1 {
        t.Errorf("Laplace decode consumed %d bits, expected at least 1", consumedBits)
    }

    // Symbol 0 has highest probability, should consume few bits
    // Non-zero symbols should consume more
    t.Logf("Laplace decode consumed %d bits", consumedBits)
}

func TestDecodeCoarseEnergyRangeSync(t *testing.T) {
    // Test that coarse energy decoding doesn't desynchronize
    // Decode multiple bands and verify range decoder state is consistent

    // Use some real-looking CELT frame data
    testData := make([]byte, 64)
    for i := range testData {
        testData[i] = byte(i * 7 % 256) // Deterministic test data
    }

    d := NewDecoder(1)
    rd := &rangecoding.Decoder{}
    rd.Init(testData)
    d.SetRangeDecoder(rd)

    // Decode energy for 10 bands
    energies := d.DecodeCoarseEnergy(10, false, 3) // inter-frame, LM=3 (20ms)

    // Verify energies are finite and reasonable
    for i, e := range energies {
        if e != e { // NaN check
            t.Errorf("Band %d energy is NaN", i)
        }
        if e < -100 || e > 100 {
            t.Errorf("Band %d energy %f out of reasonable range [-100, 100]", i, e)
        }
    }

    // Verify range decoder is still in valid state
    bitsUsed := rd.Tell()
    if bitsUsed < 0 || bitsUsed > len(testData)*8 {
        t.Errorf("Range decoder in invalid state: Tell() = %d", bitsUsed)
    }

    t.Logf("Decoded 10 band energies, consumed %d bits", bitsUsed)
}
```
  </action>
  <verify>go test ./internal/celt/... -run "TestLaplaceDecode|TestDecodeCoarseEnergy" -v passes</verify>
  <done>Tests verify Laplace decoding consumes entropy correctly and range decoder stays synchronized</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles successfully
- `go test ./internal/rangecoding/... -v` passes
- `go test ./internal/celt/... -v` passes
- Laplace decoding consumes non-zero bits
- Energy values are within reasonable range after decoding
</verification>

<success_criteria>
- DecodeSymbol method properly updates range decoder state
- updateRange delegates to DecodeSymbol (no more bit approximation)
- Laplace decoding produces consistent entropy consumption
- Range decoder stays synchronized through energy decoding
</success_criteria>

<output>
After completion, create `.planning/phases/15-celt-decoder-quality/15-02-SUMMARY.md`
</output>
