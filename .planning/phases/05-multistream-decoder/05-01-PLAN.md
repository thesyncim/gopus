---
phase: 05-multistream-decoder
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/multistream/decoder.go
  - internal/multistream/mapping.go
  - internal/multistream/stream.go
autonomous: true

must_haves:
  truths:
    - "MultistreamDecoder can be created with valid channel configuration"
    - "Channel mapping table correctly routes coupled/uncoupled stream indices to output channels"
    - "Self-delimiting framing correctly parses N-1 prefixed packets plus final standard packet"
    - "Invalid configurations rejected with appropriate errors"
  artifacts:
    - path: "internal/multistream/decoder.go"
      provides: "MultistreamDecoder struct and NewDecoder constructor"
      exports: ["Decoder", "NewDecoder", "ErrInvalidChannels", "ErrInvalidStreams"]
    - path: "internal/multistream/mapping.go"
      provides: "Vorbis channel mapping tables and DefaultMapping function"
      exports: ["DefaultMapping", "vorbisChannelOrder"]
    - path: "internal/multistream/stream.go"
      provides: "Self-delimiting packet parser"
      exports: ["parseMultistreamPacket", "ErrPacketTooShort", "ErrDurationMismatch"]
  key_links:
    - from: "internal/multistream/decoder.go"
      to: "internal/silk/silk.go"
      via: "streamDecoder interface wrapping silk.Decoder"
      pattern: "silk\\.NewDecoder"
    - from: "internal/multistream/decoder.go"
      to: "internal/celt/decoder.go"
      via: "streamDecoder interface wrapping celt.Decoder"
      pattern: "celt\\.NewDecoder"
    - from: "internal/multistream/decoder.go"
      to: "internal/hybrid/decoder.go"
      via: "streamDecoder interface wrapping hybrid.Decoder"
      pattern: "hybrid\\.NewDecoder"
---

<objective>
Create the multistream decoder foundation with decoder struct, channel mapping tables, and self-delimiting packet parser.

Purpose: Establish the structural foundation for surround sound decoding. The multistream decoder coordinates multiple elementary Opus streams (SILK/CELT/Hybrid) and routes decoded audio to output channels via a mapping table.

Output: `internal/multistream/` package with decoder struct, Vorbis channel mapping tables (1-8 channels), and self-delimiting framing parser per RFC 7845.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multistream-decoder/05-RESEARCH.md

# Existing decoder patterns to follow
@internal/hybrid/decoder.go
@internal/hybrid/hybrid.go
@internal/silk/silk.go
@internal/celt/decoder.go
@packet.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Channel mapping tables and helpers</name>
  <files>internal/multistream/mapping.go</files>
  <action>
Create `internal/multistream/mapping.go` with Vorbis channel mapping tables per RFC 7845 Section 5.1.1:

1. Define `vorbisChannelOrder` map for channel names by count (1-8 channels):
   - 1: mono
   - 2: left, right
   - 3: left, center, right
   - 4: front_left, front_right, rear_left, rear_right
   - 5: front_left, center, front_right, rear_left, rear_right
   - 6: front_left, center, front_right, rear_left, rear_right, LFE (5.1)
   - 7: front_left, center, front_right, side_left, side_right, rear_center, LFE
   - 8: front_left, center, front_right, side_left, side_right, rear_left, rear_right, LFE (7.1)

2. Implement `DefaultMapping(channels int) (streams, coupledStreams int, mapping []byte, err error)`:
   - Returns pre-defined mapping for mapping family 1 (Vorbis-style)
   - 1ch: 1 stream, 0 coupled, [0]
   - 2ch: 1 stream, 1 coupled, [0, 1]
   - 3ch: 2 streams, 1 coupled, [0, 2, 1]
   - 4ch: 2 streams, 2 coupled, [0, 1, 2, 3]
   - 5ch: 3 streams, 2 coupled, [0, 4, 1, 2, 3]
   - 6ch: 4 streams, 2 coupled, [0, 4, 1, 2, 3, 5]
   - 7ch: 5 streams, 2 coupled, [0, 4, 1, 2, 3, 5, 6]
   - 8ch: 5 streams, 3 coupled, [0, 6, 1, 2, 3, 4, 5, 7]
   - Return error for unsupported channel counts

3. Implement `streamChannels(streamIdx, coupledStreams int) int`:
   - Returns 2 if streamIdx < coupledStreams (coupled = stereo)
   - Returns 1 otherwise (uncoupled = mono)

4. Implement `resolveMapping(mappingIdx byte, coupledStreams int) (streamIdx, chanInStream int)`:
   - If mappingIdx < 2*coupledStreams: coupled stream
     - streamIdx = mappingIdx / 2
     - chanInStream = mappingIdx % 2 (0=left, 1=right)
   - Else if mappingIdx != 255: uncoupled stream
     - streamIdx = coupledStreams + (mappingIdx - 2*coupledStreams)
     - chanInStream = 0
   - If mappingIdx == 255: silent channel (return -1, -1)

Follow the existing package conventions (lowercase unexported helpers, clear comments).
  </action>
  <verify>
`go build ./internal/multistream/...` compiles successfully.
  </verify>
  <done>
Vorbis channel mapping tables defined for 1-8 channels. DefaultMapping returns correct stream/coupled counts and mapping bytes. resolveMapping correctly interprets mapping indices.
  </done>
</task>

<task type="auto">
  <name>Task 2: Self-delimiting packet parser</name>
  <files>internal/multistream/stream.go</files>
  <action>
Create `internal/multistream/stream.go` with multistream packet parsing per RFC 6716 Appendix B:

1. Define errors:
   - `ErrPacketTooShort` - insufficient data
   - `ErrDurationMismatch` - streams have different frame durations
   - `ErrInvalidStreamCount` - stream count mismatch

2. Implement `parseSelfDelimitedLength(data []byte) (length, consumed int, err error)`:
   - Uses same 1-2 byte encoding as standard frame lengths
   - If first byte < 252: length = firstByte, consumed = 1
   - Else: length = 4*secondByte + firstByte, consumed = 2
   - Return ErrPacketTooShort if insufficient bytes

3. Implement `parseMultistreamPacket(data []byte, numStreams int) ([][]byte, error)`:
   - Allocate packets slice of size numStreams
   - For first N-1 streams: parse self-delimiting length, extract packet bytes
   - For last stream: remaining bytes are the packet (standard framing)
   - Return ErrPacketTooShort if data exhausted early
   - Return ErrInvalidStreamCount if numStreams < 1

4. Implement `getFrameDuration(packet []byte) int`:
   - Parse TOC byte (first byte of packet) using same logic as gopus.ParseTOC
   - Extract config from top 5 bits
   - Return frame size in samples at 48kHz from config table
   - This validates all streams have consistent timing

Use the existing `parseFrameLength` pattern from packet.go as reference.
  </action>
  <verify>
`go build ./internal/multistream/...` compiles successfully.
  </verify>
  <done>
Self-delimiting packet parser extracts individual stream packets from multistream data. First N-1 packets parsed with length prefix, last packet uses remaining bytes.
  </done>
</task>

<task type="auto">
  <name>Task 3: MultistreamDecoder struct and constructor</name>
  <files>internal/multistream/decoder.go</files>
  <action>
Create `internal/multistream/decoder.go` with the main decoder struct:

1. Define errors:
   - `ErrInvalidChannels` - channels not in 1-255 range
   - `ErrInvalidStreams` - streams not in 1-255 range
   - `ErrInvalidCoupledStreams` - coupledStreams > streams or negative
   - `ErrTooManyChannels` - streams + coupledStreams > 255
   - `ErrInvalidMapping` - mapping length != channels or invalid indices

2. Define `streamDecoder` interface (unexported):
```go
type streamDecoder interface {
    Decode(data []byte, frameSize int) ([]float64, error)
    DecodeStereo(data []byte, frameSize int) ([]float64, error)
    Reset()
}
```
Note: This interface is a wrapper pattern. Individual decoders (silk, celt, hybrid) have different signatures - create wrapper types for each.

3. Define wrapper types to adapt existing decoders:
   - `silkStreamDecoder` wrapping `*silk.Decoder`
   - `celtStreamDecoder` wrapping `*celt.Decoder`
   - `hybridStreamDecoder` wrapping `*hybrid.Decoder`

Each wrapper implements streamDecoder by calling the underlying decoder's methods with appropriate parameter conversions. For SILK, use BandwidthWideband and a default frameSize conversion. For CELT/Hybrid, pass through directly.

4. Define `Decoder` struct:
```go
type Decoder struct {
    sampleRate     int           // 8000, 12000, 16000, 24000, 48000
    outputChannels int           // Total output channels (1-255)
    streams        int           // Total streams (N)
    coupledStreams int           // Coupled stereo streams (M)
    mapping        []byte        // Channel mapping table
    decoders       []streamDecoder // One decoder per stream
}
```

5. Implement `NewDecoder(sampleRate, channels, streams, coupledStreams int, mapping []byte) (*Decoder, error)`:
   - Validate all parameters:
     - channels: 1-255
     - streams: 1-255
     - coupledStreams: 0 to streams
     - streams + coupledStreams <= 255
     - len(mapping) == channels
     - Each mapping[i] < streams+coupledStreams OR == 255
   - Create stream decoders:
     - First M (coupledStreams) are stereo (hybrid.NewDecoder(2))
     - Remaining N-M are mono (hybrid.NewDecoder(1))
   - Use hybrid.Decoder for all streams (it handles SILK/CELT/Hybrid mode detection internally via TOC parsing)

6. Implement `Reset()` to reset all stream decoders.

7. Implement accessor methods: `Channels()`, `SampleRate()`, `Streams()`, `CoupledStreams()`.

Import existing packages: internal/hybrid, internal/silk, internal/celt.
  </action>
  <verify>
`go build ./internal/multistream/...` compiles. `go vet ./internal/multistream/...` passes.
  </verify>
  <done>
MultistreamDecoder struct created with parameter validation, stream decoder allocation, and proper channel/stream configuration. Constructor rejects invalid configurations with appropriate errors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Package compiles: `go build ./internal/multistream/...`
2. No vet issues: `go vet ./internal/multistream/...`
3. Exported types available: Decoder, NewDecoder, DefaultMapping
4. Errors defined: ErrInvalidChannels, ErrInvalidStreams, etc.

Verify channel mapping logic manually:
- 6-channel (5.1) config: 4 streams, 2 coupled
  - mapping[0]=0 -> stream 0, channel 0 (left of coupled pair 0)
  - mapping[1]=4 -> stream 2 (first uncoupled), channel 0 (mono)
  - mapping[2]=1 -> stream 0, channel 1 (right of coupled pair 0)
  - etc.
</verification>

<success_criteria>
- [ ] `internal/multistream/mapping.go` exists with Vorbis tables for 1-8 channels
- [ ] `internal/multistream/stream.go` exists with self-delimiting parser
- [ ] `internal/multistream/decoder.go` exists with Decoder struct and NewDecoder
- [ ] All parameter validation rejects invalid configurations
- [ ] Package builds and passes vet
- [ ] Channel mapping formula correctly handles coupled/uncoupled distinction
</success_criteria>

<output>
After completion, create `.planning/phases/05-multistream-decoder/05-01-SUMMARY.md`
</output>
