---
phase: 05-multistream-decoder
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/multistream/multistream.go
  - internal/multistream/multistream_test.go
autonomous: true

must_haves:
  truths:
    - "Multistream packets with coupled stereo streams decode correctly"
    - "Multistream packets with uncoupled mono streams decode correctly"
    - "Channel mapping table correctly routes streams to output channels"
    - "All streams decoded with consistent timing (same frame duration)"
    - "PLC generates concealment when data is nil"
  artifacts:
    - path: "internal/multistream/multistream.go"
      provides: "Decode methods and channel mapping application"
      exports: ["Decode", "DecodeToInt16", "DecodeToFloat32"]
    - path: "internal/multistream/multistream_test.go"
      provides: "Comprehensive multistream tests"
      min_lines: 150
  key_links:
    - from: "internal/multistream/multistream.go"
      to: "internal/multistream/stream.go"
      via: "parseMultistreamPacket call"
      pattern: "parseMultistreamPacket"
    - from: "internal/multistream/multistream.go"
      to: "internal/multistream/decoder.go"
      via: "d.decoders[i].Decode call"
      pattern: "d\\.decoders\\[.*\\]\\.Decode"
    - from: "internal/multistream/multistream.go"
      to: "internal/multistream/mapping.go"
      via: "resolveMapping and streamChannels calls"
      pattern: "resolveMapping|streamChannels"
---

<objective>
Implement the Decode methods and comprehensive tests for multistream decoding.

Purpose: Complete the multistream decoder with actual decoding capability, channel routing, and PLC support. This fulfills DEC-11 (Decode multistream packets) from requirements.

Output: Working Decode/DecodeToInt16/DecodeToFloat32 methods with channel mapping application and test suite validating coupled/uncoupled streams, channel routing, and edge cases.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multistream-decoder/05-RESEARCH.md
@.planning/phases/05-multistream-decoder/05-01-SUMMARY.md

# Existing decode API patterns
@internal/hybrid/hybrid.go
@internal/silk/silk.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Decode method with channel mapping</name>
  <files>internal/multistream/multistream.go</files>
  <action>
Create `internal/multistream/multistream.go` with decode methods:

1. Import required packages: internal/plc for PLC support

2. Define package-level PLC state:
```go
var multistreamPLCState = plc.NewState()
```

3. Implement `applyChannelMapping(decodedStreams [][]float64, mapping []byte, coupledStreams, frameSize, outputChannels int) []float64`:
   - Create output buffer: frameSize * outputChannels samples
   - For each output channel outCh 0 to outputChannels-1:
     - Get mappingIdx = mapping[outCh]
     - If mappingIdx == 255: silent channel, leave zeros
     - Else: call resolveMapping to get streamIdx, chanInStream
     - Get source stream: src = decodedStreams[streamIdx]
     - Get source channel count: srcChannels = streamChannels(streamIdx, coupledStreams)
     - Copy samples: for s = 0 to frameSize-1:
       - output[s*outputChannels + outCh] = src[s*srcChannels + chanInStream]
   - Return output (sample-interleaved format: [ch0_s0, ch1_s0, ch2_s0, ..., ch0_s1, ch1_s1, ...])

4. Implement `(d *Decoder) Decode(data []byte, frameSize int) ([]float64, error)`:
   - If data is nil: return d.decodePLC(frameSize)
   - Parse multistream packet: packets, err := parseMultistreamPacket(data, d.streams)
   - Validate frame durations match (all streams same duration):
     - expectedDuration := getFrameDuration(packets[0])
     - For i := 1 to d.streams-1: if getFrameDuration(packets[i]) != expectedDuration, return ErrDurationMismatch
   - Decode each stream:
     - decodedStreams := make([][]float64, d.streams)
     - For i := 0 to d.streams-1:
       - If i < d.coupledStreams: decoded, err = d.decoders[i].DecodeStereo(packets[i], frameSize)
       - Else: decoded, err = d.decoders[i].Decode(packets[i], frameSize)
       - If err != nil: return nil, fmt.Errorf("stream %d: %w", i, err)
       - decodedStreams[i] = decoded
   - Apply channel mapping: output := applyChannelMapping(decodedStreams, d.mapping, d.coupledStreams, frameSize, d.outputChannels)
   - Reset PLC state after success
   - Return output, nil

5. Implement `(d *Decoder) decodePLC(frameSize int) ([]float64, error)`:
   - Record loss: fadeFactor := multistreamPLCState.RecordLoss()
   - If fadeFactor < 0.001: return silence (zeros)
   - For each stream: call decoder.Decode(nil, frameSize) to get PLC output
   - Apply channel mapping to PLC outputs
   - Return mapped output

6. Implement convenience wrappers:

`(d *Decoder) DecodeToInt16(data []byte, frameSize int) ([]int16, error)`:
   - Call Decode, convert float64 to int16 (clamp to [-32768, 32767])
   - Scale: int16(sample * 32767.0) with clamping

`(d *Decoder) DecodeToFloat32(data []byte, frameSize int) ([]float32, error)`:
   - Call Decode, convert float64 to float32

7. Add doc comments explaining:
   - Output format is sample-interleaved: [ch0_s0, ch1_s0, ..., chN_s0, ch0_s1, ...]
   - frameSize is in samples at 48kHz per channel
   - nil data triggers PLC (packet loss concealment)
  </action>
  <verify>
`go build ./internal/multistream/...` compiles.
  </verify>
  <done>
Decode method parses multistream packet, decodes all streams, applies channel mapping, returns sample-interleaved output. PLC support for nil data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Comprehensive test suite</name>
  <files>internal/multistream/multistream_test.go</files>
  <action>
Create `internal/multistream/multistream_test.go` with comprehensive tests:

1. **TestNewDecoder_ValidConfigs**:
   - Test valid configurations: mono (1ch), stereo (2ch), 5.1 (6ch), 7.1 (8ch)
   - Use DefaultMapping for each
   - Verify decoder created without error
   - Verify Channels(), Streams(), CoupledStreams() return correct values

2. **TestNewDecoder_InvalidConfigs**:
   - channels < 1: expect ErrInvalidChannels
   - channels > 255: expect ErrInvalidChannels
   - streams < 1: expect ErrInvalidStreams
   - coupledStreams > streams: expect ErrInvalidCoupledStreams
   - coupledStreams < 0: expect ErrInvalidCoupledStreams
   - mapping length != channels: expect ErrInvalidMapping
   - mapping index >= streams+coupledStreams: expect ErrInvalidMapping

3. **TestDefaultMapping**:
   - Test DefaultMapping for channels 1-8
   - Verify streams, coupledStreams, mapping length for each
   - Test invalid channel count (0, 9) returns error

4. **TestResolveMapping**:
   - Test coupled stream indices (mappingIdx < 2*coupledStreams)
   - Test uncoupled stream indices
   - Test silent channel (mappingIdx == 255)
   - Verify streamIdx and chanInStream for various configurations

5. **TestStreamChannels**:
   - Verify streamChannels returns 2 for coupled, 1 for uncoupled

6. **TestParseMultistreamPacket**:
   - Create synthetic multistream packet with known structure:
     - Craft 2-stream packet: stream0 with length prefix, stream1 as remainder
     - Verify correct extraction of both stream packets
   - Test edge cases:
     - Single stream (no self-delimiting needed)
     - Empty data -> ErrPacketTooShort
     - Invalid stream count -> error

7. **TestApplyChannelMapping**:
   - Create mock decoded streams with known sample patterns
   - Apply 5.1 mapping (4 streams, 2 coupled)
   - Verify output channels receive correct samples from correct streams

8. **TestDecode_Integration** (can be skipped if synthetic packet construction is too complex):
   - If feasible: construct minimal valid multistream packet
   - Otherwise: test with nil data (PLC path) to verify method executes

9. **TestDecodePLC**:
   - Create decoder
   - Call Decode(nil, 960) for PLC
   - Verify output length is frameSize * channels
   - Verify no panic, reasonable output (faded/silence after multiple calls)

10. **TestDecodeToInt16** and **TestDecodeToFloat32**:
    - Test conversion wrappers with PLC path (nil data)
    - Verify output types and lengths

Use table-driven tests where appropriate. Mark complex integration tests with t.Skip() if synthetic packet construction proves too difficult (note: similar to Phase 4, programmatic packet encoding is complex).
  </action>
  <verify>
`go test ./internal/multistream/... -v` runs. Tests that can run should pass. Complex integration tests can be skipped with clear skip messages.
  </verify>
  <done>
Comprehensive test suite validates decoder creation, parameter validation, channel mapping logic, packet parsing, and PLC path. Core logic tested even if full packet decoding tests are skipped.
  </done>
</task>

<task type="auto">
  <name>Task 3: Fix issues and verify full package</name>
  <files>internal/multistream/decoder.go, internal/multistream/multistream.go, internal/multistream/stream.go, internal/multistream/mapping.go</files>
  <action>
Run full test suite and fix any issues:

1. Run: `go test ./internal/multistream/... -v`
2. Fix any compilation errors or test failures
3. Run: `go vet ./internal/multistream/...`
4. Fix any vet warnings

Common issues to check:
- Import cycles (should not have any - multistream imports silk/celt/hybrid, not vice versa)
- Nil pointer dereferences in edge cases
- Slice bounds in channel mapping
- Type assertions on streamDecoder interface

Ensure exported API is clean:
- Decoder type and NewDecoder constructor
- Decode, DecodeToInt16, DecodeToFloat32 methods
- DefaultMapping function
- Error variables: ErrInvalidChannels, etc.

Run tests with race detector to catch any data races:
`go test ./internal/multistream/... -race`
  </action>
  <verify>
`go test ./internal/multistream/... -v` all tests pass (or are properly skipped with explanation).
`go vet ./internal/multistream/...` no warnings.
`go test ./internal/multistream/... -race` no races detected.
  </verify>
  <done>
Multistream package builds, passes all tests, no vet warnings, no race conditions. Package ready for integration with unified decoder API.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Full test suite: `go test ./internal/multistream/... -v`
2. All project tests still pass: `go test ./...`
3. Race detector clean: `go test ./internal/multistream/... -race`
4. Vet clean: `go vet ./...`

Verify against phase success criteria:
- [ ] Multistream packets with coupled stereo streams decode correctly (via channel mapping tests)
- [ ] Multistream packets with uncoupled mono streams decode correctly (via channel mapping tests)
- [ ] Channel mapping table correctly routes streams to output channels (TestApplyChannelMapping)
- [ ] All streams decoded with consistent timing (duration validation in Decode)
</verification>

<success_criteria>
- [ ] `internal/multistream/multistream.go` exists with Decode methods
- [ ] `internal/multistream/multistream_test.go` exists with 10+ test functions
- [ ] Decode parses multistream packet and applies channel mapping
- [ ] PLC generates output when data is nil
- [ ] All tests pass (non-skipped)
- [ ] No vet warnings
- [ ] No race conditions
- [ ] All project tests still pass (`go test ./...`)
</success_criteria>

<output>
After completion, create `.planning/phases/05-multistream-decoder/05-02-SUMMARY.md`
</output>
