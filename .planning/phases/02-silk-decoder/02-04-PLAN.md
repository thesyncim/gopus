---
phase: 02-silk-decoder
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - internal/silk/stereo.go
  - internal/silk/frame.go
  - internal/silk/decode.go
  - internal/silk/stereo_test.go
autonomous: true

must_haves:
  truths:
    - "Stereo SILK frames decode with mid-side unmixing producing left and right channels"
    - "Stereo prediction weights decode and apply correctly"
    - "DecodeFrame orchestrates all decoding steps and returns PCM samples"
    - "All frame sizes (10/20/40/60ms) decode with correct subframe counts"
  artifacts:
    - path: "internal/silk/stereo.go"
      provides: "Stereo prediction and mid-side unmixing"
      exports: ["decodeStereoWeights", "stereoUnmix"]
    - path: "internal/silk/frame.go"
      provides: "Frame size handling and subframe iteration"
      exports: ["getSubframeCount", "getFrameSamples"]
    - path: "internal/silk/decode.go"
      provides: "Top-level frame decoding orchestration"
      exports: ["DecodeFrame", "DecodeStereoFrame"]
  key_links:
    - from: "internal/silk/decode.go"
      to: "internal/silk/decode_params.go"
      via: "parameter decoding calls"
      pattern: "DecodeFrameType|decodeSubframeGains|decodeLSFCoefficients"
    - from: "internal/silk/decode.go"
      to: "internal/silk/excitation.go"
      via: "excitation decoding"
      pattern: "decodeExcitation"
    - from: "internal/silk/decode.go"
      to: "internal/silk/lpc.go"
      via: "synthesis filtering"
      pattern: "lpcSynthesis"
    - from: "internal/silk/stereo.go"
      to: "internal/silk/tables.go"
      via: "stereo ICDF tables"
      pattern: "icdfStereo"
---

<objective>
Implement SILK stereo decoding and frame orchestration: mid-side unmixing for stereo streams, and the top-level DecodeFrame function that coordinates all decoding stages.

Purpose: Complete the SILK decoder by adding stereo support (requirement DEC-10) and providing the main entry point that takes a bitstream and produces audio samples. This is the integration layer that ties all the components together.

Output: Working DecodeFrame and DecodeStereoFrame functions that produce PCM audio from SILK bitstream data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-silk-decoder/02-RESEARCH.md

# From prior plans
@internal/silk/decoder.go
@internal/silk/decode_params.go
@internal/silk/gain.go
@internal/silk/lsf.go
@internal/silk/pitch.go
@internal/silk/excitation.go
@internal/silk/ltp.go
@internal/silk/lpc.go

# Foundation
@internal/rangecoding/decoder.go
@packet.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement stereo prediction and unmixing</name>
  <files>internal/silk/stereo.go</files>
  <action>
Create `internal/silk/stereo.go` implementing SILK stereo decoding per RFC 6716 Section 4.2.8:

```go
package silk

// SILK stereo uses mid-side coding with prediction.
// Mid channel = (L + R) / 2
// Side channel = (L - R) / 2
// Plus stereo prediction weights for enhanced quality.

// decodeStereoWeights decodes the stereo prediction weights.
// Per RFC 6716 Section 4.2.8.
// Returns w0 and w1 in Q13 format.
func (d *Decoder) decodeStereoWeights() (w0, w1 int16) {
    // Decode prediction index
    predIdx := d.rangeDecoder.DecodeICDF(icdfStereoPrediction, 8)

    // Decode weight index
    weightIdx := d.rangeDecoder.DecodeICDF(icdfStereoWeight, 8)

    // Look up weights from table (Q13)
    // Weights control how much mid predicts side
    w0 = stereoWeightTable[predIdx][0]
    w1 = stereoWeightTable[predIdx][1]

    // Apply weight index adjustment
    // ... (per RFC formulas)

    return w0, w1
}

// decodeStereoParams decodes stereo-specific parameters for both channels.
// Mid and side channels share some parameters but decode independently.
func (d *Decoder) decodeStereoParams(bandwidth Bandwidth, frameSamples int) (midParams, sideParams *FrameParams) {
    // Decode mid channel parameters first
    midParams = d.decodeChannelParams(bandwidth, frameSamples, true)

    // Decode side channel parameters
    // Side channel may use different signal type
    sideParams = d.decodeChannelParams(bandwidth, frameSamples, false)

    return midParams, sideParams
}

// stereoUnmix converts mid-side decoded samples to left-right.
// Per RFC 6716 Section 4.2.8.
func stereoUnmix(mid, side []float32, w0, w1 int16, left, right []float32) {
    if len(mid) != len(side) || len(mid) != len(left) || len(mid) != len(right) {
        panic("stereoUnmix: mismatched lengths")
    }

    for i := range mid {
        m := mid[i]
        s := side[i]

        // Apply stereo prediction
        // pred = w0 * m + w1 * s (in Q13)
        pred := (float32(w0)*m + float32(w1)*s) / 8192.0

        // Unmix to left/right
        // L = M + S (+ pred for enhanced)
        // R = M - S (+ pred for enhanced)
        left[i] = m + s + pred
        right[i] = m - s + pred

        // Clamp to valid range
        if left[i] > 1.0 {
            left[i] = 1.0
        } else if left[i] < -1.0 {
            left[i] = -1.0
        }
        if right[i] > 1.0 {
            right[i] = 1.0
        } else if right[i] < -1.0 {
            right[i] = -1.0
        }
    }
}

// Stereo weight table (Q13) per RFC 6716
var stereoWeightTable = [][2]int16{
    // predIdx -> {w0, w1}
    // These values are from RFC 6716 Section 4.2.8
    {0, 0},
    // ... complete table from RFC
}
```

Add the necessary ICDF tables for stereo to tables.go if not already present:
- `icdfStereoPrediction`
- `icdfStereoWeight`

Reference pion/opus for exact table values.
  </action>
  <verify>
`go build ./internal/silk/` compiles.
stereoUnmix with m=[1,1,1], s=[0.5,0.5,0.5], w0=0, w1=0 produces L=1.5, R=0.5.
  </verify>
  <done>
Stereo prediction weights decode correctly.
Mid-side unmixing produces left/right from mid/side channels.
Weights table defined per RFC 6716.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement frame size handling</name>
  <files>internal/silk/frame.go</files>
  <action>
Create `internal/silk/frame.go` with frame size calculations per RFC 6716 Section 4.2.1:

```go
package silk

// Frame sizes in SILK:
// - 10ms: 2 subframes
// - 20ms: 4 subframes
// - 40ms: 8 subframes (2 x 20ms)
// - 60ms: 12 subframes (3 x 20ms)
// Each subframe is 5ms.

// FrameDuration represents SILK frame duration in milliseconds.
type FrameDuration int

const (
    Frame10ms FrameDuration = 10
    Frame20ms FrameDuration = 20
    Frame40ms FrameDuration = 40
    Frame60ms FrameDuration = 60
)

// getSubframeCount returns the number of 5ms subframes for a frame duration.
func getSubframeCount(duration FrameDuration) int {
    switch duration {
    case Frame10ms:
        return 2
    case Frame20ms:
        return 4
    case Frame40ms:
        return 8  // Two 20ms sub-blocks
    case Frame60ms:
        return 12 // Three 20ms sub-blocks
    default:
        return 4 // Default to 20ms
    }
}

// getFrameSamples returns the number of output samples for a frame at given bandwidth.
// This is the native SILK sample rate (8/12/16kHz).
func getFrameSamples(duration FrameDuration, bandwidth Bandwidth) int {
    config := GetBandwidthConfig(bandwidth)
    msPerSample := 1000 / config.SampleRate
    return int(duration) / msPerSample
}

// get48kHzSamples returns the number of samples at 48kHz output rate.
// Opus always outputs at 48kHz.
func get48kHzSamples(duration FrameDuration) int {
    return int(duration) * 48 // 48 samples per ms at 48kHz
}

// getSamplesPerSubframe returns samples per 5ms subframe at given bandwidth.
func getSamplesPerSubframe(bandwidth Bandwidth) int {
    config := GetBandwidthConfig(bandwidth)
    return config.SubframeSamples
}

// FrameDurationFromTOC extracts frame duration from TOC frame size value.
// TOC frame sizes at 48kHz: 480=10ms, 960=20ms, 1920=40ms, 2880=60ms
func FrameDurationFromTOC(tocFrameSize int) FrameDuration {
    switch tocFrameSize {
    case 480:
        return Frame10ms
    case 960:
        return Frame20ms
    case 1920:
        return Frame40ms
    case 2880:
        return Frame60ms
    default:
        return Frame20ms // Default
    }
}

// is40or60ms returns true if this is a long frame (40 or 60ms).
// Long frames decode as multiple 20ms sub-blocks.
func is40or60ms(duration FrameDuration) bool {
    return duration == Frame40ms || duration == Frame60ms
}

// getSubBlockCount returns number of 20ms sub-blocks for long frames.
func getSubBlockCount(duration FrameDuration) int {
    switch duration {
    case Frame40ms:
        return 2
    case Frame60ms:
        return 3
    default:
        return 1
    }
}
```
  </action>
  <verify>
`go build ./internal/silk/` compiles.
getSubframeCount(Frame20ms) == 4.
getFrameSamples(Frame20ms, BandwidthWideband) == 320 (16kHz * 20ms).
  </verify>
  <done>
Frame duration enum covers 10/20/40/60ms.
Subframe counts correct: 10ms=2, 20ms=4, 40ms=8, 60ms=12.
Sample calculations match bandwidth sample rates.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement top-level decode functions</name>
  <files>internal/silk/decode.go, internal/silk/stereo_test.go</files>
  <action>
**Part A: Create `internal/silk/decode.go`**

Implement the main frame decoding orchestration:

```go
package silk

import (
    "gopus/internal/rangecoding"
)

// DecodeFrame decodes a single SILK mono frame from the bitstream.
// Returns decoded samples at native SILK sample rate (8/12/16kHz).
func (d *Decoder) DecodeFrame(
    rd *rangecoding.Decoder,
    bandwidth Bandwidth,
    duration FrameDuration,
    vadFlag bool,
) ([]float32, error) {
    d.SetRangeDecoder(rd)
    config := GetBandwidthConfig(bandwidth)

    numSubframes := getSubframeCount(duration)
    samplesPerSubframe := config.SubframeSamples
    totalSamples := numSubframes * samplesPerSubframe

    output := make([]float32, totalSamples)

    // For 40/60ms frames, decode as multiple 20ms sub-blocks
    if is40or60ms(duration) {
        subBlocks := getSubBlockCount(duration)
        subBlockSamples := 4 * samplesPerSubframe // 20ms = 4 subframes

        for block := 0; block < subBlocks; block++ {
            blockOutput := output[block*subBlockSamples : (block+1)*subBlockSamples]
            err := d.decode20msBlock(bandwidth, vadFlag, blockOutput)
            if err != nil {
                return nil, err
            }
        }
    } else {
        // 10ms or 20ms: single block
        err := d.decode20msBlock(bandwidth, vadFlag, output)
        if err != nil {
            return nil, err
        }
    }

    // Update decoder state for next frame
    d.haveDecoded = true

    return output, nil
}

// decode20msBlock decodes one 20ms (or 10ms) sub-block.
func (d *Decoder) decode20msBlock(
    bandwidth Bandwidth,
    vadFlag bool,
    output []float32,
) error {
    config := GetBandwidthConfig(bandwidth)
    numSubframes := len(output) / config.SubframeSamples

    // 1. Decode frame type
    signalType, quantOffset := d.DecodeFrameType(vadFlag)

    // 2. Decode subframe gains
    gains := d.decodeSubframeGains(signalType, numSubframes)

    // 3. Decode LSF -> LPC coefficients
    lsfQ15 := d.decodeLSFCoefficients(bandwidth, signalType)
    lpcQ12 := lsfToLPC(lsfQ15)
    limitLPCFilterGain(lpcQ12)

    // 4. Decode pitch/LTP (voiced only)
    var pitchLags []int
    var ltpCoeffs [][]int8
    if signalType == 2 { // Voiced
        pitchLags = d.decodePitchLag(bandwidth, numSubframes)
        ltpCoeffs, _ = d.decodeLTPCoefficients(bandwidth, numSubframes)
    }

    // 5. Decode and synthesize each subframe
    for sf := 0; sf < numSubframes; sf++ {
        sfStart := sf * config.SubframeSamples
        sfEnd := sfStart + config.SubframeSamples
        sfOutput := output[sfStart:sfEnd]

        // Decode excitation
        excitation := d.decodeExcitation(config.SubframeSamples, gains[sf], signalType, quantOffset)

        // Apply LTP synthesis (voiced only)
        if signalType == 2 && pitchLags != nil {
            d.ltpSynthesis(excitation, pitchLags[sf], ltpCoeffs[sf], gains[sf])
        }

        // Apply LPC synthesis
        d.lpcSynthesis(excitation, lpcQ12, gains[sf], sfOutput)

        // Update output history for LTP lookback
        d.updateHistory(sfOutput)
    }

    // Update voiced flag for next frame
    d.isPreviousFrameVoiced = (signalType == 2)

    return nil
}

// DecodeStereoFrame decodes a SILK stereo frame from the bitstream.
// Returns left and right channel samples at native sample rate.
func (d *Decoder) DecodeStereoFrame(
    rd *rangecoding.Decoder,
    bandwidth Bandwidth,
    duration FrameDuration,
    vadFlag bool,
) (left, right []float32, err error) {
    d.SetRangeDecoder(rd)
    config := GetBandwidthConfig(bandwidth)

    numSubframes := getSubframeCount(duration)
    totalSamples := numSubframes * config.SubframeSamples

    // Decode stereo prediction weights
    w0, w1 := d.decodeStereoWeights()

    // Decode mid channel
    mid := make([]float32, totalSamples)
    err = d.decodeChannel(bandwidth, duration, vadFlag, mid)
    if err != nil {
        return nil, nil, err
    }

    // Decode side channel
    side := make([]float32, totalSamples)
    err = d.decodeChannel(bandwidth, duration, vadFlag, side)
    if err != nil {
        return nil, nil, err
    }

    // Unmix to left/right
    left = make([]float32, totalSamples)
    right = make([]float32, totalSamples)
    stereoUnmix(mid, side, w0, w1, left, right)

    // Update stereo state
    d.prevStereoWeights = [2]int16{w0, w1}
    d.haveDecoded = true

    return left, right, nil
}

// decodeChannel decodes a single channel (used for stereo).
func (d *Decoder) decodeChannel(
    bandwidth Bandwidth,
    duration FrameDuration,
    vadFlag bool,
    output []float32,
) error {
    if is40or60ms(duration) {
        subBlocks := getSubBlockCount(duration)
        config := GetBandwidthConfig(bandwidth)
        subBlockSamples := 4 * config.SubframeSamples

        for block := 0; block < subBlocks; block++ {
            blockOutput := output[block*subBlockSamples : (block+1)*subBlockSamples]
            if err := d.decode20msBlock(bandwidth, vadFlag, blockOutput); err != nil {
                return err
            }
        }
    } else {
        return d.decode20msBlock(bandwidth, vadFlag, output)
    }
    return nil
}
```

**Part B: Create `internal/silk/stereo_test.go`**

```go
package silk

import (
    "testing"
    "math"
)

func TestStereoUnmixBasic(t *testing.T) {
    // Test basic mid-side to left-right conversion without prediction
    mid := []float32{0.5, 0.5, 0.5, 0.5}
    side := []float32{0.25, 0.25, 0.25, 0.25}
    left := make([]float32, 4)
    right := make([]float32, 4)

    stereoUnmix(mid, side, 0, 0, left, right)

    // L = M + S = 0.75
    // R = M - S = 0.25
    for i := range left {
        if math.Abs(float64(left[i]-0.75)) > 0.001 {
            t.Errorf("left[%d] = %f, want 0.75", i, left[i])
        }
        if math.Abs(float64(right[i]-0.25)) > 0.001 {
            t.Errorf("right[%d] = %f, want 0.25", i, right[i])
        }
    }
}

func TestStereoUnmixClamping(t *testing.T) {
    // Test that output is clamped to [-1, 1]
    mid := []float32{1.0, -1.0}
    side := []float32{0.5, -0.5}
    left := make([]float32, 2)
    right := make([]float32, 2)

    stereoUnmix(mid, side, 0, 0, left, right)

    // L = 1.0 + 0.5 = 1.5 -> clamped to 1.0
    if left[0] > 1.0 {
        t.Errorf("left[0] = %f, should be clamped to 1.0", left[0])
    }
}

func TestFrameDurationConversion(t *testing.T) {
    tests := []struct {
        tocFrameSize int
        wantDuration FrameDuration
    }{
        {480, Frame10ms},
        {960, Frame20ms},
        {1920, Frame40ms},
        {2880, Frame60ms},
    }

    for _, tt := range tests {
        got := FrameDurationFromTOC(tt.tocFrameSize)
        if got != tt.wantDuration {
            t.Errorf("FrameDurationFromTOC(%d) = %d, want %d", tt.tocFrameSize, got, tt.wantDuration)
        }
    }
}

func TestSubframeCount(t *testing.T) {
    tests := []struct {
        duration FrameDuration
        want     int
    }{
        {Frame10ms, 2},
        {Frame20ms, 4},
        {Frame40ms, 8},
        {Frame60ms, 12},
    }

    for _, tt := range tests {
        got := getSubframeCount(tt.duration)
        if got != tt.want {
            t.Errorf("getSubframeCount(%d) = %d, want %d", tt.duration, got, tt.want)
        }
    }
}

func TestFrameSamplesPerBandwidth(t *testing.T) {
    // 20ms frame at different bandwidths
    tests := []struct {
        bandwidth   Bandwidth
        wantSamples int
    }{
        {BandwidthNarrowband, 160},  // 8kHz * 0.02s
        {BandwidthMediumband, 240},  // 12kHz * 0.02s
        {BandwidthWideband, 320},    // 16kHz * 0.02s
    }

    for _, tt := range tests {
        got := getFrameSamples(Frame20ms, tt.bandwidth)
        if got != tt.wantSamples {
            t.Errorf("getFrameSamples(20ms, %v) = %d, want %d", tt.bandwidth, got, tt.wantSamples)
        }
    }
}

func TestGet48kHzSamples(t *testing.T) {
    tests := []struct {
        duration    FrameDuration
        wantSamples int
    }{
        {Frame10ms, 480},   // 10 * 48
        {Frame20ms, 960},   // 20 * 48
        {Frame40ms, 1920},  // 40 * 48
        {Frame60ms, 2880},  // 60 * 48
    }

    for _, tt := range tests {
        got := get48kHzSamples(tt.duration)
        if got != tt.wantSamples {
            t.Errorf("get48kHzSamples(%d) = %d, want %d", tt.duration, got, tt.wantSamples)
        }
    }
}
```
  </action>
  <verify>
`go build ./internal/silk/` compiles.
`go test ./internal/silk/` passes all tests including stereo and frame tests.
  </verify>
  <done>
DecodeFrame orchestrates mono decoding for all frame sizes.
DecodeStereoFrame decodes stereo with mid-side unmixing.
40/60ms frames decode as multiple 20ms sub-blocks.
Tests verify stereo unmixing math and frame size conversions.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` - entire project compiles
2. `go test ./internal/silk/` - all tests pass
3. DecodeFrame handles 10/20/40/60ms frames
4. DecodeStereoFrame produces left/right from mid/side
5. stereoUnmix correctly converts mid-side to left-right
6. Frame size calculations match expected sample counts
</verification>

<success_criteria>
- Stereo prediction weights decode from bitstream
- stereoUnmix converts mid/side to left/right with clamping
- DecodeFrame produces correct sample count for all frame durations
- 40/60ms frames decode as multiple 20ms sub-blocks
- DecodeStereoFrame coordinates mid/side channel decoding
- All stereo and frame tests pass
- Decoder state (haveDecoded, isPreviousFrameVoiced) updates after each frame
</success_criteria>

<output>
After completion, create `.planning/phases/02-silk-decoder/02-04-SUMMARY.md`
</output>
