---
phase: 02-silk-decoder
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/silk/decode_params.go
  - internal/silk/gain.go
  - internal/silk/lsf.go
  - internal/silk/pitch.go
  - internal/silk/decode_params_test.go
autonomous: true

must_haves:
  truths:
    - "Frame type decoding extracts signal type (inactive/unvoiced/voiced) and quantization offset"
    - "Subframe gains decode correctly with delta quantization from previous"
    - "LSF coefficients decode through two-stage VQ and convert to LPC coefficients"
    - "Pitch lag and LTP coefficients decode for voiced frames only"
  artifacts:
    - path: "internal/silk/decode_params.go"
      provides: "Top-level parameter decoding orchestration"
      exports: ["DecodeFrameParams", "FrameParams"]
    - path: "internal/silk/gain.go"
      provides: "Gain decoding functions"
      exports: ["decodeSubframeGains"]
    - path: "internal/silk/lsf.go"
      provides: "LSF decoding and LSF-to-LPC conversion"
      exports: ["decodeLSFCoefficients", "lsfToLPC"]
    - path: "internal/silk/pitch.go"
      provides: "Pitch lag and LTP coefficient decoding"
      exports: ["decodePitchLag", "decodeLTPCoefficients"]
  key_links:
    - from: "internal/silk/decode_params.go"
      to: "internal/silk/tables.go"
      via: "ICDF table usage"
      pattern: "icdf.*ICDF"
    - from: "internal/silk/lsf.go"
      to: "internal/silk/codebook.go"
      via: "codebook lookup"
      pattern: "lsfCodebook"
    - from: "internal/silk/decode_params.go"
      to: "internal/rangecoding"
      via: "DecodeICDF calls"
      pattern: "DecodeICDF"
---

<objective>
Implement SILK parameter decoding: extract frame type, gains, LSF/LPC coefficients, and pitch/LTP parameters from the bitstream using range decoding and codebook lookups.

Purpose: Before synthesis can produce audio, all control parameters must be decoded from the entropy-coded bitstream. This is the most table-intensive part of SILK decoding.

Output: Parameter decoding functions that transform range-coded bits into numeric values ready for synthesis filtering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-silk-decoder/02-RESEARCH.md

# From 02-01
@internal/silk/tables.go
@internal/silk/codebook.go
@internal/silk/decoder.go
@internal/silk/bandwidth.go

# Foundation
@internal/rangecoding/decoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement frame type and gain decoding</name>
  <files>internal/silk/decode_params.go, internal/silk/gain.go</files>
  <action>
**Part A: Create `internal/silk/decode_params.go`**

Define the FrameParams struct that holds all decoded parameters for one SILK frame:

```go
package silk

// FrameParams holds decoded parameters for a single SILK frame.
type FrameParams struct {
    // Frame classification
    SignalType  int   // 0=inactive, 1=unvoiced, 2=voiced
    QuantOffset int   // 0=low, 1=high quantization

    // Subframe parameters (4 subframes for 20ms, 2 for 10ms)
    NumSubframes int
    Gains        []int32   // Q16 format, one per subframe

    // LPC parameters
    LPCOrder     int
    LPCCoeffs    []int16   // Q12 format

    // Pitch parameters (voiced only)
    PitchLags    []int     // One per subframe
    LTPCoeffs    [][]int8  // Q7 format, [subframe][5 taps]
    LTPPeriodicity int     // 0, 1, or 2 (selects LTP codebook)

    // Excitation (filled by excitation decoder)
    Excitation   []int32
}

// DecodeFrameType decodes signal type and quantization offset from VAD flag.
// Per RFC 6716 Section 4.2.7.3.
func (d *Decoder) DecodeFrameType(vadFlag bool) (signalType, quantOffset int) {
    if !vadFlag {
        // Inactive frame - no range coding needed
        return 0, 0
    }
    // Decode 2 bits packed as single symbol
    idx := d.rangeDecoder.DecodeICDF(icdfFrameTypeVADActive, 8)
    signalType = idx >> 1   // 0, 1, or 2
    quantOffset = idx & 1   // 0 or 1
    return
}
```

**Part B: Create `internal/silk/gain.go`**

Implement gain decoding per RFC 6716 Section 4.2.7.4:

```go
package silk

// decodeSubframeGains decodes gains for all subframes.
// First gain is absolute (MSB + LSB), subsequent are delta-coded.
// Returns Q16 gains.
func (d *Decoder) decodeSubframeGains(signalType, numSubframes int) []int32 {
    gains := make([]int32, numSubframes)

    // Select MSB table based on signal type
    var msb int
    switch signalType {
    case 0: // Inactive
        msb = d.rangeDecoder.DecodeICDF(icdfGainMSBInactive, 8)
    case 1: // Unvoiced
        msb = d.rangeDecoder.DecodeICDF(icdfGainMSBUnvoiced, 8)
    case 2: // Voiced
        msb = d.rangeDecoder.DecodeICDF(icdfGainMSBVoiced, 8)
    }

    // Decode LSB (3 bits)
    lsb := d.rangeDecoder.DecodeICDF(icdfGainLSB, 8)

    // First subframe gain index
    gainIndex := msb*8 + lsb

    // Convert to Q16 (using gain table or formula per RFC)
    gains[0] = gainIndexToQ16(gainIndex, d.previousLogGain, d.haveDecoded)

    // Subsequent subframes use delta coding
    for i := 1; i < numSubframes; i++ {
        delta := d.rangeDecoder.DecodeICDF(icdfDeltaGain, 8)
        // Delta is centered at 4, so subtract 4
        gainIndex += delta - 4
        // Clamp to valid range [0, 63]
        if gainIndex < 0 { gainIndex = 0 }
        if gainIndex > 63 { gainIndex = 63 }
        gains[i] = gainIndexToQ16Linear(gainIndex)
    }

    // Update state for next frame
    d.previousLogGain = gains[numSubframes-1]

    return gains
}

// gainIndexToQ16 converts gain index to Q16 fixed-point gain.
// Per RFC 6716 Section 4.2.7.4, gain = 2^((gainIndex-14)/8) scaled to Q16.
func gainIndexToQ16(index int, prevLogGain int32, haveDecoded bool) int32 {
    // Implementation follows RFC formula
    // log_gain = max(0, gainIndex - 2*max(0, gainIndex - 16)) if first frame
    // or uses delta from previous
    // Then: gain = 2^(log_gain/128) in Q16
    // ... (full implementation per RFC)
    return 0 // Placeholder - implement per RFC 6716 Section 4.2.7.4
}

func gainIndexToQ16Linear(index int) int32 {
    // Direct conversion for delta-coded gains
    return 0 // Placeholder
}
```

Use the exact formulas from RFC 6716 Section 4.2.7.4 for gain calculation. The gain table can be precomputed or calculated on-the-fly.
  </action>
  <verify>
`go build ./internal/silk/` compiles.
Unit test: DecodeFrameType with vadFlag=false returns (0, 0).
  </verify>
  <done>
Frame type decoding returns signalType 0/1/2 and quantOffset 0/1.
Gain decoding produces Q16 gains with delta coding between subframes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement LSF decoding and LSF-to-LPC conversion</name>
  <files>internal/silk/lsf.go</files>
  <action>
Create `internal/silk/lsf.go` implementing two-stage VQ LSF decoding per RFC 6716 Section 4.2.7.5:

```go
package silk

// decodeLSFCoefficients decodes LSF coefficients using two-stage VQ.
// Returns LSF in Q15 format.
func (d *Decoder) decodeLSFCoefficients(bandwidth Bandwidth, signalType int) []int16 {
    config := GetBandwidthConfig(bandwidth)
    lpcOrder := config.LPCOrder
    isWideband := bandwidth == BandwidthWideband
    isVoiced := signalType == 2

    lsfQ15 := make([]int16, lpcOrder)

    // Stage 1: Decode codebook index
    var stage1Idx int
    if isWideband {
        if isVoiced {
            stage1Idx = d.rangeDecoder.DecodeICDF(icdfLSFStage1WBVoiced, 8)
        } else {
            stage1Idx = d.rangeDecoder.DecodeICDF(icdfLSFStage1WBUnvoiced, 8)
        }
    } else {
        if isVoiced {
            stage1Idx = d.rangeDecoder.DecodeICDF(icdfLSFStage1NBMBVoiced, 8)
        } else {
            stage1Idx = d.rangeDecoder.DecodeICDF(icdfLSFStage1NBMBUnvoiced, 8)
        }
    }

    // Stage 2: Decode residuals for each coefficient
    // Select codebook map based on stage1 index
    mapIdx := stage1Idx >> 2 // Maps 0-31 to 0-7

    residuals := make([]int, lpcOrder)
    for i := 0; i < lpcOrder; i++ {
        var icdf []uint8
        if isWideband {
            icdf = icdfLSFStage2WB[mapIdx][i]
        } else {
            icdf = icdfLSFStage2NBMB[mapIdx][i]
        }
        residuals[i] = d.rangeDecoder.DecodeICDF(icdf, 8)
    }

    // Decode interpolation index (for smoothing with previous frame)
    interpIdx := d.rangeDecoder.DecodeICDF(icdfLSFInterpolation, 8)

    // Combine stage 1 codebook + stage 2 residuals
    var codebook [][]uint8
    var stage2Res [][][]int8
    if isWideband {
        codebook = lsfCodebookWB[:]
        stage2Res = lsfStage2ResWB[:]
    } else {
        codebook = lsfCodebookNBMB[:]
        stage2Res = lsfStage2ResNBMB[:]
    }

    // Reconstruct LSF: base + residual + prediction from previous
    for i := 0; i < lpcOrder; i++ {
        base := int(codebook[stage1Idx][i])
        res := int(stage2Res[mapIdx][residuals[i]][i])
        // Apply prediction weight from previous frame
        pred := int(d.prevLSFQ15[i]) * predWeight / 256 // predWeight from table
        lsfQ15[i] = int16((base << 7) + res + pred) // Scale to Q15
    }

    // Stabilize LSF (ensure minimum spacing)
    stabilizeLSF(lsfQ15, isWideband)

    // Update state
    copy(d.prevLSFQ15, lsfQ15)

    return lsfQ15
}

// stabilizeLSF ensures minimum spacing between adjacent LSF values.
// Per RFC 6716 Section 4.2.7.5.5.
func stabilizeLSF(lsf []int16, isWideband bool) {
    var minSpacing []int
    if isWideband {
        minSpacing = lsfMinSpacingWB[:]
    } else {
        minSpacing = lsfMinSpacingNBMB[:]
    }

    // Sort LSF values (they should already be ordered)
    // Enforce minimum spacing
    for i := 1; i < len(lsf); i++ {
        minVal := lsf[i-1] + int16(minSpacing[i])
        if lsf[i] < minVal {
            lsf[i] = minVal
        }
    }
    // Ensure last value doesn't exceed pi
    maxVal := int16(32767 - minSpacing[len(lsf)])
    if lsf[len(lsf)-1] > maxVal {
        lsf[len(lsf)-1] = maxVal
    }
}

// lsfToLPC converts LSF coefficients to LPC coefficients.
// Per RFC 6716 Section 4.2.7.5.6.
func lsfToLPC(lsfQ15 []int16) []int16 {
    order := len(lsfQ15)
    lpcQ12 := make([]int16, order)

    // Convert LSF to cosines using cosineTable
    cos := make([]int32, order)
    for i := 0; i < order; i++ {
        // Map Q15 [0, 32767] to table index [0, 128]
        idx := int(lsfQ15[i]) >> 8
        frac := int(lsfQ15[i]) & 0xFF
        // Linear interpolation
        cos[i] = cosineTable[idx] + (cosineTable[idx+1]-cosineTable[idx])*int32(frac)/256
    }

    // Compute LPC from cosines using Chebyshev recursion
    // Per RFC 6716 Section 4.2.7.5.6
    // ... (implementation of polynomial evaluation)

    return lpcQ12
}
```

The LSF-to-LPC conversion uses Chebyshev polynomial evaluation. Implement the full algorithm from RFC 6716 Section 4.2.7.5.6.
  </action>
  <verify>
`go build ./internal/silk/` compiles.
LSF decoding produces values in valid Q15 range [0, 32767].
  </verify>
  <done>
LSF coefficients decode through two-stage VQ with correct codebook selection.
LSF-to-LPC conversion produces Q12 LPC coefficients.
stabilizeLSF ensures minimum spacing.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement pitch lag and LTP decoding</name>
  <files>internal/silk/pitch.go, internal/silk/decode_params_test.go</files>
  <action>
**Part A: Create `internal/silk/pitch.go`**

Implement pitch/LTP decoding per RFC 6716 Section 4.2.7.6:

```go
package silk

// decodePitchLag decodes pitch lag for all subframes (voiced frames only).
// Returns absolute pitch lag in samples for each subframe.
func (d *Decoder) decodePitchLag(bandwidth Bandwidth, numSubframes int) []int {
    config := GetBandwidthConfig(bandwidth)
    pitchLags := make([]int, numSubframes)

    // Decode pitch lag MSB (coarse)
    var lagMSB int
    switch bandwidth {
    case BandwidthNarrowband:
        lagMSB = d.rangeDecoder.DecodeICDF(icdfPitchLagNB, 8)
    case BandwidthMediumband:
        lagMSB = d.rangeDecoder.DecodeICDF(icdfPitchLagMB, 8)
    case BandwidthWideband:
        lagMSB = d.rangeDecoder.DecodeICDF(icdfPitchLagWB, 8)
    }

    // Decode pitch lag LSB (fine, 2 bits)
    lagLSB := d.rangeDecoder.DecodeICDF(icdfPitchLagLSB, 8)

    // Base pitch lag for first subframe
    baseLag := config.PitchLagMin + lagMSB*4 + lagLSB
    pitchLags[0] = baseLag

    // Decode contour (delta per subframe)
    var contourIdx int
    var contour []int8
    switch bandwidth {
    case BandwidthNarrowband:
        if numSubframes == 4 {
            contourIdx = d.rangeDecoder.DecodeICDF(icdfPitchContourNB20ms, 8)
            contour = pitchContourNB20ms[contourIdx][:]
        } else {
            contourIdx = d.rangeDecoder.DecodeICDF(icdfPitchContourNB10ms, 8)
            contour = pitchContourNB10ms[contourIdx][:]
        }
    case BandwidthMediumband:
        if numSubframes == 4 {
            contourIdx = d.rangeDecoder.DecodeICDF(icdfPitchContourMB20ms, 8)
            contour = pitchContourMB20ms[contourIdx][:]
        } else {
            contourIdx = d.rangeDecoder.DecodeICDF(icdfPitchContourMB10ms, 8)
            contour = pitchContourMB10ms[contourIdx][:]
        }
    case BandwidthWideband:
        if numSubframes == 4 {
            contourIdx = d.rangeDecoder.DecodeICDF(icdfPitchContourWB20ms, 8)
            contour = pitchContourWB20ms[contourIdx][:]
        } else {
            contourIdx = d.rangeDecoder.DecodeICDF(icdfPitchContourWB10ms, 8)
            contour = pitchContourWB10ms[contourIdx][:]
        }
    }

    // Apply contour to get per-subframe pitch lags
    for i := 1; i < numSubframes; i++ {
        pitchLags[i] = baseLag + int(contour[i])
        // Clamp to valid range
        if pitchLags[i] < config.PitchLagMin {
            pitchLags[i] = config.PitchLagMin
        }
        if pitchLags[i] > config.PitchLagMax {
            pitchLags[i] = config.PitchLagMax
        }
    }

    return pitchLags
}

// decodeLTPCoefficients decodes LTP filter coefficients (voiced frames only).
// Returns Q7 coefficients: [numSubframes][5].
func (d *Decoder) decodeLTPCoefficients(bandwidth Bandwidth, numSubframes int) ([][]int8, int) {
    // Decode periodicity index (selects codebook variant)
    periodicity := d.rangeDecoder.DecodeICDF(icdfLTPPeriodicity, 8)

    ltpCoeffs := make([][]int8, numSubframes)

    for sf := 0; sf < numSubframes; sf++ {
        // Decode LTP filter index for this subframe
        ltpIdx := d.rangeDecoder.DecodeICDF(icdfLTPFilterIndex[periodicity], 8)

        // Look up coefficients from codebook
        ltpCoeffs[sf] = make([]int8, 5)
        if bandwidth == BandwidthWideband {
            copy(ltpCoeffs[sf], ltpFilterWB[periodicity][ltpIdx][:])
        } else {
            copy(ltpCoeffs[sf], ltpFilterNBMB[periodicity][ltpIdx][:])
        }
    }

    // Decode LTP scale (for gain adjustment)
    ltpScale := d.rangeDecoder.DecodeICDF(icdfLTPScale, 8)
    _ = ltpScale // Used in synthesis

    return ltpCoeffs, periodicity
}
```

**Part B: Create `internal/silk/decode_params_test.go`**

Add basic unit tests for parameter decoding:

```go
package silk

import (
    "testing"
)

func TestBandwidthConfig(t *testing.T) {
    tests := []struct {
        bw       Bandwidth
        wantLPC  int
        wantRate int
    }{
        {BandwidthNarrowband, 10, 8000},
        {BandwidthMediumband, 10, 12000},
        {BandwidthWideband, 16, 16000},
    }
    for _, tt := range tests {
        cfg := GetBandwidthConfig(tt.bw)
        if cfg.LPCOrder != tt.wantLPC {
            t.Errorf("LPCOrder for %v: got %d, want %d", tt.bw, cfg.LPCOrder, tt.wantLPC)
        }
        if cfg.SampleRate != tt.wantRate {
            t.Errorf("SampleRate for %v: got %d, want %d", tt.bw, cfg.SampleRate, tt.wantRate)
        }
    }
}

func TestFrameTypeInactive(t *testing.T) {
    d := NewDecoder()
    // VAD inactive should return (0, 0) without range decoding
    sig, quant := d.DecodeFrameType(false)
    if sig != 0 || quant != 0 {
        t.Errorf("Inactive frame: got (%d, %d), want (0, 0)", sig, quant)
    }
}
```

Add more tests as the implementation solidifies.
  </action>
  <verify>
`go build ./internal/silk/` compiles.
`go test ./internal/silk/` passes.
  </verify>
  <done>
Pitch lag decoding returns valid lags in [PitchLagMin, PitchLagMax] range.
LTP coefficients decode as [numSubframes][5] Q7 arrays.
Tests verify bandwidth config and inactive frame handling.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./...` - entire project compiles
2. `go test ./internal/silk/` - parameter tests pass
3. Parameter decoding functions exist: DecodeFrameType, decodeSubframeGains, decodeLSFCoefficients, decodePitchLag, decodeLTPCoefficients
4. FrameParams struct holds all decoded values
</verification>

<success_criteria>
- Frame type decoding extracts signal type (0/1/2) and quant offset (0/1)
- Gain decoding produces Q16 values with delta coding
- LSF decoding uses two-stage VQ with correct table selection
- LSF-to-LPC conversion produces Q12 coefficients
- Pitch lag decoding produces values in valid range per bandwidth
- LTP coefficients decode as 5-tap Q7 filters
- All parameter functions use range decoder for entropy decoding
- Unit tests pass for bandwidth config and frame type
</success_criteria>

<output>
After completion, create `.planning/phases/02-silk-decoder/02-02-SUMMARY.md`
</output>
