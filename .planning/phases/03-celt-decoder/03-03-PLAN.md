---
phase: 03-celt-decoder
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/celt/energy.go
  - internal/celt/alloc.go
  - internal/celt/energy_test.go
autonomous: true

must_haves:
  truths:
    - "Coarse energy decodes from Laplace-distributed residuals"
    - "Fine energy refinement applies sub-6dB precision"
    - "Inter-frame prediction uses alpha coefficient by frame size"
    - "Inter-band prediction uses beta coefficient"
    - "Bit allocation computes band bits from quality level"
  artifacts:
    - path: "internal/celt/energy.go"
      provides: "Coarse and fine energy decoding"
      exports: ["DecodeCoarseEnergy", "DecodeFineEnergy", "DecodeEnergyRemainder"]
    - path: "internal/celt/alloc.go"
      provides: "Bit allocation computation"
      exports: ["ComputeAllocation"]
    - path: "internal/celt/energy_test.go"
      provides: "Unit tests for energy decoding"
      contains: "func Test"
  key_links:
    - from: "internal/celt/energy.go"
      to: "internal/celt/tables.go"
      via: "alpha/beta coefficient lookup"
      pattern: "alphaCoef|betaCoef"
    - from: "internal/celt/energy.go"
      to: "internal/rangecoding"
      via: "entropy decoding"
      pattern: "rangecoding\\.Decoder"
---

<objective>
Implement CELT energy decoding (coarse and fine stages) and bit allocation computation.

Purpose: Energy envelope defines the loudness of each frequency band and is critical for audio reconstruction. Bit allocation determines how many bits each band receives for PVQ shape coding. Both must exactly match libopus to ensure correct decoding.

Output: `internal/celt/energy.go` with two-stage energy decoding, `internal/celt/alloc.go` with bit allocation, and tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-celt-decoder/03-RESEARCH.md
@internal/celt/tables.go
@internal/celt/modes.go
@internal/celt/decoder.go
@internal/rangecoding/decoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement coarse energy decoding</name>
  <files>internal/celt/energy.go</files>
  <action>
Create `internal/celt/energy.go` with coarse energy decoding per RFC 6716 Section 4.3.2:

1. **Laplace model decoding** for energy residuals:
   ```go
   // decodeLaplace decodes a Laplace-distributed integer using range coder.
   // Uses probability model from RFC 6716 Section 4.3.2.1.
   func (d *Decoder) decodeLaplace(fs, decay int) int
   ```

   The Laplace model uses:
   - `fs` = 32768 (total frequency)
   - `decay` parameter controls distribution spread
   - Decode magnitude first, then sign

2. **Intra-frame vs inter-frame mode**:
   ```go
   // DecodeCoarseEnergy decodes coarse (6dB step) band energies.
   // intra=true: no inter-frame prediction (first frame or after loss)
   // intra=false: uses alpha prediction from previous frame
   func (d *Decoder) DecodeCoarseEnergy(nbBands int, intra bool) []float64
   ```

3. **Energy prediction**:
   - Inter-frame: `pred = alpha * prevEnergy[band] + beta * prevBandEnergy`
   - Intra-frame: `pred = beta * prevBandEnergy` (alpha=0)
   - Alpha/beta coefficients from tables.go based on LM (frame size)

4. **Energy update**:
   - `energy[band] = pred + residual * 6.0` (6 dB per step)
   - Store in decoder's prevEnergy for next frame

Reference libopus `celt/quant_bands.c` function `unquant_coarse_energy()`.
  </action>
  <verify>
`go build ./internal/celt/` compiles. Test that decoded energies are finite floats.
  </verify>
  <done>
energy.go contains DecodeCoarseEnergy with Laplace decoding, inter-frame/inter-band prediction, and 6dB stepping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement fine energy and remainder decoding</name>
  <files>internal/celt/energy.go</files>
  <action>
Add fine energy decoding to `internal/celt/energy.go`:

1. **DecodeFineEnergy** - Sub-6dB precision refinement:
   ```go
   // DecodeFineEnergy adds fine energy precision to coarse values.
   // fineBits[band] specifies bits allocated for refinement (0 = no refinement).
   func (d *Decoder) DecodeFineEnergy(energies []float64, nbBands int, fineBits []int)
   ```

   For each band with fineBits[band] > 0:
   - Decode `fineBits[band]` bits uniformly
   - Compute offset: `(q + 0.5) / (1 << fineBits) - 0.5`
   - Add `offset * 6.0` to coarse energy

2. **DecodeEnergyRemainder** - Use leftover bits after PVQ:
   ```go
   // DecodeEnergyRemainder uses remaining bits for additional energy precision.
   // Called after all PVQ bands decoded.
   func (d *Decoder) DecodeEnergyRemainder(energies []float64, nbBands int, remainderBits []int)
   ```

   Similar to fine energy but uses bits left over from bit allocation.

3. **Helper for uniform decoding**:
   ```go
   // decodeUniform decodes a value uniformly in [0, ft)
   func (d *Decoder) decodeUniform(ft uint) int
   ```

Reference libopus `celt/quant_bands.c` functions `unquant_fine_energy()` and `unquant_energy_finalise()`.
  </action>
  <verify>
`go build ./internal/celt/` compiles. Fine energy adds sub-6dB precision.
  </verify>
  <done>
energy.go contains DecodeFineEnergy and DecodeEnergyRemainder for sub-6dB precision using uniform bits.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement bit allocation computation</name>
  <files>internal/celt/alloc.go</files>
  <action>
Create `internal/celt/alloc.go` with bit allocation per RFC 6716 Section 4.3.3:

1. **Band allocation table** (11 quality levels x 21 bands):
   ```go
   // bandAlloc contains base bits per band at each quality level.
   // Index: bandAlloc[quality][band]
   var bandAlloc = [11][21]int{...}
   ```
   Extract exact values from libopus `celt/static_modes_float.h`.

2. **ComputeAllocation** - Main allocation function:
   ```go
   // ComputeAllocation computes bits per band from total budget.
   // Returns: bandBits (bits per band), fineBits (fine energy bits), pulseCaps
   func ComputeAllocation(
       totalBits int,
       nbBands int,
       cap []int,       // Per-band caps
       dynalloc []int,  // Dynamic allocation boosts
       trim int,        // Allocation trim (-6 to 6)
       intensity int,   // Intensity stereo start band
       dualStereo bool,
       lm int,          // Frame size mode
   ) (bandBits, fineBits []int)
   ```

3. **Allocation steps**:
   - Compute base allocation from quality interpolation
   - Apply dynamic allocation (dynalloc)
   - Apply trim adjustment
   - Apply band caps
   - Split between coarse/fine energy and PVQ pulses
   - Handle intensity stereo allocation

4. **Helper: pulse cap by band width**:
   ```go
   // pulseCap returns maximum PVQ index bits for a band.
   func pulseCap(bandWidth int) int
   ```

This is complex - port directly from libopus `celt/rate.c` function `compute_allocation()`.
Do NOT simplify - exact bit allocation is required for decoder to match encoder.
  </action>
  <verify>
`go build ./internal/celt/` compiles. Allocation produces non-negative bit counts summing to budget.
  </verify>
  <done>
alloc.go contains ComputeAllocation with band allocation table, quality interpolation, trim, and stereo handling.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add energy and allocation tests</name>
  <files>internal/celt/energy_test.go</files>
  <action>
Create `internal/celt/energy_test.go` with unit tests:

1. **TestDecodeCoarseEnergy**:
   - Mock range decoder with known bytes
   - Verify energies are finite and in reasonable range (-20 to +40 dB typical)
   - Test both intra and inter-frame modes

2. **TestDecodeFineEnergy**:
   - Verify fine bits add sub-6dB precision
   - Test with 0, 1, 2, 3 fine bits per band

3. **TestComputeAllocation**:
   ```go
   func TestComputeAllocation(t *testing.T) {
       // Test cases from libopus
       tests := []struct{
           totalBits, nbBands int
           wantSum int  // bandBits should sum to ~totalBits
       }{
           {1000, 21, 1000},  // Full bandwidth
           {500, 13, 500},    // Reduced bandwidth
       }
       for _, tc := range tests {
           bandBits, _ := ComputeAllocation(tc.totalBits, tc.nbBands, ...)
           sum := 0
           for _, b := range bandBits { sum += b }
           // Allow small difference due to caps
           if abs(sum - tc.wantSum) > 50 {
               t.Errorf("allocation sum %d, want ~%d", sum, tc.wantSum)
           }
       }
   }
   ```

4. **TestAllocationNonNegative**:
   - Verify no band gets negative bits
   - Verify fineBits are non-negative

5. **BenchmarkDecodeCoarseEnergy**:
   ```go
   func BenchmarkDecodeCoarseEnergy(b *testing.B) {
       dec := NewDecoder(1)
       // Setup mock range decoder
       for i := 0; i < b.N; i++ {
           dec.DecodeCoarseEnergy(21, false)
       }
   }
   ```
  </action>
  <verify>
`go test ./internal/celt/... -v` passes all energy and allocation tests.
  </verify>
  <done>
energy_test.go contains tests for coarse/fine energy decoding, allocation computation, and benchmarks.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/celt/` compiles
2. `go test ./internal/celt/... -v` passes all tests
3. Energy values are finite and in reasonable range
4. Bit allocation sums correctly and respects caps
</verification>

<success_criteria>
- Coarse energy decoding with Laplace model and inter-frame prediction
- Fine energy refinement with uniform bit decoding
- Bit allocation matching libopus compute_allocation
- All tests passing with reasonable energy ranges
</success_criteria>

<output>
After completion, create `.planning/phases/03-celt-decoder/03-03-SUMMARY.md`
</output>
