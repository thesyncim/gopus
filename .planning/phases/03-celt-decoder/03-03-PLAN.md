---
phase: 03-celt-decoder
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/celt/energy.go
  - internal/celt/alloc.go
  - internal/celt/energy_test.go
autonomous: true

must_haves:
  truths:
    - "Coarse energy decodes from Laplace-distributed residuals"
    - "Fine energy refinement applies sub-6dB precision"
    - "Inter-frame prediction uses alpha coefficient by frame size"
    - "Inter-band prediction uses beta coefficient"
    - "Bit allocation computes band bits from quality level"
  artifacts:
    - path: "internal/celt/energy.go"
      provides: "Coarse and fine energy decoding"
      exports: ["DecodeCoarseEnergy", "DecodeFineEnergy", "DecodeEnergyRemainder"]
    - path: "internal/celt/alloc.go"
      provides: "Bit allocation computation"
      exports: ["ComputeAllocation"]
    - path: "internal/celt/energy_test.go"
      provides: "Unit tests for energy decoding"
      contains: "func Test"
  key_links:
    - from: "internal/celt/energy.go"
      to: "internal/celt/tables.go"
      via: "alpha/beta coefficient lookup"
      pattern: "alphaCoef|betaCoef"
    - from: "internal/celt/energy.go"
      to: "internal/rangecoding"
      via: "entropy decoding"
      pattern: "rangecoding\\.Decoder"
---

<objective>
Implement CELT energy decoding (coarse and fine stages) and bit allocation computation.

Purpose: Energy envelope defines the loudness of each frequency band and is critical for audio reconstruction. Bit allocation determines how many bits each band receives for PVQ shape coding. Both must exactly match libopus to ensure correct decoding.

Output: `internal/celt/energy.go` with two-stage energy decoding, `internal/celt/alloc.go` with bit allocation, and tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-celt-decoder/03-RESEARCH.md
@internal/celt/tables.go
@internal/celt/modes.go
@internal/celt/decoder.go
@internal/rangecoding/decoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement coarse energy decoding</name>
  <files>internal/celt/energy.go</files>
  <action>
Create `internal/celt/energy.go` with coarse energy decoding per RFC 6716 Section 4.3.2:

1. **Laplace model decoding** for energy residuals:
   ```go
   // decodeLaplace decodes a Laplace-distributed integer using range coder.
   // Uses probability model from RFC 6716 Section 4.3.2.1.
   func (d *Decoder) decodeLaplace(fs, decay int) int
   ```

   The Laplace model uses:
   - `fs` = 32768 (total frequency)
   - `decay` parameter controls distribution spread
   - Decode magnitude first, then sign

2. **Intra-frame vs inter-frame mode**:
   ```go
   // DecodeCoarseEnergy decodes coarse (6dB step) band energies.
   // intra=true: no inter-frame prediction (first frame or after loss)
   // intra=false: uses alpha prediction from previous frame
   func (d *Decoder) DecodeCoarseEnergy(nbBands int, intra bool) []float64
   ```

3. **Energy prediction**:
   - Inter-frame: `pred = alpha * prevEnergy[band] + beta * prevBandEnergy`
   - Intra-frame: `pred = beta * prevBandEnergy` (alpha=0)
   - Alpha/beta coefficients from tables.go based on LM (frame size)

4. **Energy update**:
   - `energy[band] = pred + residual * 6.0` (6 dB per step)
   - Store in decoder's prevEnergy for next frame

Reference libopus `celt/quant_bands.c` function `unquant_coarse_energy()`.
  </action>
  <verify>
`go build ./internal/celt/` compiles. Test that decoded energies are finite floats.
  </verify>
  <done>
energy.go contains DecodeCoarseEnergy with Laplace decoding, inter-frame/inter-band prediction, and 6dB stepping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement fine energy and remainder decoding</name>
  <files>internal/celt/energy.go</files>
  <action>
Add fine energy decoding to `internal/celt/energy.go`:

1. **DecodeFineEnergy** - Sub-6dB precision refinement:
   ```go
   // DecodeFineEnergy adds fine energy precision to coarse values.
   // fineBits[band] specifies bits allocated for refinement (0 = no refinement).
   func (d *Decoder) DecodeFineEnergy(energies []float64, nbBands int, fineBits []int)
   ```

   For each band with fineBits[band] > 0:
   - Decode `fineBits[band]` bits uniformly
   - Compute offset: `(q + 0.5) / (1 << fineBits) - 0.5`
   - Add `offset * 6.0` to coarse energy

2. **DecodeEnergyRemainder** - Use leftover bits after PVQ:
   ```go
   // DecodeEnergyRemainder uses remaining bits for additional energy precision.
   // Called after all PVQ bands decoded.
   func (d *Decoder) DecodeEnergyRemainder(energies []float64, nbBands int, remainderBits []int)
   ```

   Similar to fine energy but uses bits left over from bit allocation.

3. **Helper for uniform decoding**:
   ```go
   // decodeUniform decodes a value uniformly in [0, ft)
   func (d *Decoder) decodeUniform(ft uint) int
   ```

Reference libopus `celt/quant_bands.c` functions `unquant_fine_energy()` and `unquant_energy_finalise()`.
  </action>
  <verify>
`go build ./internal/celt/` compiles. Fine energy adds sub-6dB precision.
  </verify>
  <done>
energy.go contains DecodeFineEnergy and DecodeEnergyRemainder for sub-6dB precision using uniform bits.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement bit allocation computation</name>
  <files>internal/celt/alloc.go</files>
  <action>
Create `internal/celt/alloc.go` with bit allocation per RFC 6716 Section 4.3.3.

**This is a complex function - implement incrementally with verification at each step.**

**Step 3a: Band allocation table**
```go
// bandAlloc contains base bits per band at each quality level.
// Index: bandAlloc[quality][band]
var bandAlloc = [11][21]int{...}
```
Extract exact values from libopus `celt/static_modes_float.h`.

**Verification checkpoint 3a:** Write a test that compares bandAlloc values against libopus reference values for at least 5 quality levels.

**Step 3b: Quality interpolation**
```go
// interpolateAlloc computes allocation at fractional quality level.
// quality is in 1/8th steps (0-88 for 11 levels).
func interpolateAlloc(quality, nbBands int) []int
```
Interpolates between adjacent quality levels.

**Verification checkpoint 3b:** Test that `interpolateAlloc(0, 21)` matches bandAlloc[0], and `interpolateAlloc(80, 21)` matches bandAlloc[10]. Test that interpolation between levels produces values between the two.

**Step 3c: Trim and dynalloc adjustments**
```go
// applyTrim adjusts allocation based on trim value (-6 to +6).
// Boosts high bands when trim > 0, low bands when trim < 0.
func applyTrim(alloc []int, trim int)

// applyDynalloc applies per-band dynamic boosts.
func applyDynalloc(alloc []int, dynalloc []int)
```

**Verification checkpoint 3c:** Test trim=0 leaves allocation unchanged. Test trim=6 boosts high bands measurably. Test dynalloc adds exact amounts to specified bands.

**Step 3d: Full ComputeAllocation**
```go
// ComputeAllocation computes bits per band from total budget.
// Returns: bandBits (bits per band), fineBits (fine energy bits), pulseCaps
func ComputeAllocation(
    totalBits int,
    nbBands int,
    cap []int,       // Per-band caps
    dynalloc []int,  // Dynamic allocation boosts
    trim int,        // Allocation trim (-6 to 6)
    intensity int,   // Intensity stereo start band
    dualStereo bool,
    lm int,          // Frame size mode
) (bandBits, fineBits []int)
```

**Verification checkpoint 3d:** Test that sum(bandBits) + sum(fineBits) <= totalBits (within 8 bits tolerance for caps). Test with known inputs from libopus debug traces if available.

**Helper: pulse cap by band width**
```go
// pulseCap returns maximum PVQ index bits for a band.
func pulseCap(bandWidth int) int
```

Reference libopus `celt/rate.c` function `compute_allocation()`.
Do NOT simplify - exact bit allocation is required for decoder to match encoder.
  </action>
  <verify>
1. `go build ./internal/celt/` compiles
2. bandAlloc table matches libopus values (test)
3. Quality interpolation verified at boundaries and mid-points (test)
4. Trim/dynalloc adjustments tested separately (test)
5. Full allocation produces non-negative bit counts summing to budget (test)
  </verify>
  <done>
alloc.go contains ComputeAllocation with all sub-components verified: bandAlloc table matches libopus, quality interpolation works at boundaries and mid-points, trim/dynalloc tested independently, full allocation respects budget.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add energy and allocation tests</name>
  <files>internal/celt/energy_test.go</files>
  <action>
Create `internal/celt/energy_test.go` with unit tests:

1. **TestDecodeCoarseEnergy**:
   - Mock range decoder with known bytes
   - Verify energies are finite and in reasonable range (-20 to +40 dB typical)
   - Test both intra and inter-frame modes

2. **TestDecodeFineEnergy**:
   - Verify fine bits add sub-6dB precision
   - Test with 0, 1, 2, 3 fine bits per band

3. **TestBandAllocTable**:
   ```go
   func TestBandAllocTable(t *testing.T) {
       // Reference values from libopus celt/static_modes_float.h
       // Test at least quality levels 0, 5, 10
       expected := map[int][21]int{
           0: {...},  // Lowest quality
           5: {...},  // Mid quality
           10: {...}, // Highest quality
       }
       for q, want := range expected {
           for band := 0; band < 21; band++ {
               if bandAlloc[q][band] != want[band] {
                   t.Errorf("bandAlloc[%d][%d] = %d, want %d", q, band, bandAlloc[q][band], want[band])
               }
           }
       }
   }
   ```

4. **TestQualityInterpolation**:
   ```go
   func TestQualityInterpolation(t *testing.T) {
       // Boundary: exact quality level
       alloc0 := interpolateAlloc(0, 21)
       for i := 0; i < 21; i++ {
           if alloc0[i] != bandAlloc[0][i] {
               t.Errorf("interpolateAlloc(0)[%d] = %d, want %d", i, alloc0[i], bandAlloc[0][i])
           }
       }
       // Mid-point: should be between adjacent levels
       alloc4 := interpolateAlloc(4, 21)  // Between level 0 and 1
       for i := 0; i < 21; i++ {
           low, high := bandAlloc[0][i], bandAlloc[1][i]
           if low > high { low, high = high, low }
           if alloc4[i] < low || alloc4[i] > high {
               t.Errorf("interpolateAlloc(4)[%d] = %d, not between %d and %d", i, alloc4[i], low, high)
           }
       }
   }
   ```

5. **TestTrimAndDynalloc**:
   ```go
   func TestTrimAndDynalloc(t *testing.T) {
       // trim=0 should not change allocation
       alloc := []int{10, 20, 30, 40, 50}
       original := append([]int{}, alloc...)
       applyTrim(alloc, 0)
       for i := range alloc {
           if alloc[i] != original[i] {
               t.Errorf("trim=0 changed alloc[%d]: %d -> %d", i, original[i], alloc[i])
           }
       }

       // dynalloc adds exact amounts
       alloc = []int{10, 20, 30}
       dynalloc := []int{5, 0, 3}
       applyDynalloc(alloc, dynalloc)
       if alloc[0] != 15 || alloc[1] != 20 || alloc[2] != 33 {
           t.Errorf("dynalloc incorrect: got %v", alloc)
       }
   }
   ```

6. **TestComputeAllocation**:
   ```go
   func TestComputeAllocation(t *testing.T) {
       tests := []struct{
           totalBits, nbBands int
           wantSum int  // bandBits should sum to ~totalBits
       }{
           {1000, 21, 1000},  // Full bandwidth
           {500, 13, 500},    // Reduced bandwidth
       }
       for _, tc := range tests {
           bandBits, _ := ComputeAllocation(tc.totalBits, tc.nbBands, ...)
           sum := 0
           for _, b := range bandBits { sum += b }
           // Allow small difference due to caps
           if abs(sum - tc.wantSum) > 50 {
               t.Errorf("allocation sum %d, want ~%d", sum, tc.wantSum)
           }
       }
   }
   ```

7. **TestAllocationNonNegative**:
   - Verify no band gets negative bits
   - Verify fineBits are non-negative

8. **BenchmarkDecodeCoarseEnergy**:
   ```go
   func BenchmarkDecodeCoarseEnergy(b *testing.B) {
       dec := NewDecoder(1)
       // Setup mock range decoder
       for i := 0; i < b.N; i++ {
           dec.DecodeCoarseEnergy(21, false)
       }
   }
   ```
  </action>
  <verify>
`go test ./internal/celt/... -v` passes all energy and allocation tests.
  </verify>
  <done>
energy_test.go contains tests for coarse/fine energy decoding, bandAlloc table verification, quality interpolation, trim/dynalloc, full allocation computation, and benchmarks.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/celt/` compiles
2. `go test ./internal/celt/... -v` passes all tests
3. Energy values are finite and in reasonable range
4. Bit allocation sums correctly and respects caps
5. ComputeAllocation sub-components individually verified
</verification>

<success_criteria>
- Coarse energy decoding with Laplace model and inter-frame prediction
- Fine energy refinement with uniform bit decoding
- Bit allocation matching libopus compute_allocation with incremental verification:
  - bandAlloc table verified against libopus
  - Quality interpolation verified at boundaries
  - Trim/dynalloc verified independently
  - Full allocation verified for budget compliance
- All tests passing with reasonable energy ranges
</success_criteria>

<output>
After completion, create `.planning/phases/03-celt-decoder/03-03-SUMMARY.md`
</output>
