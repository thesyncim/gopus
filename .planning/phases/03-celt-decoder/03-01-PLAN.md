---
phase: 03-celt-decoder
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/celt/tables.go
  - internal/celt/modes.go
  - internal/celt/decoder.go
autonomous: true

must_haves:
  truths:
    - "Decoder accepts mono and stereo channel configurations"
    - "Decoder accepts all standard frame sizes (2.5/5/10/20ms)"
    - "Band processing can span all 21 frequency bands"
    - "Energy state persists correctly between frames"
  artifacts:
    - path: "internal/celt/tables.go"
      provides: "eBands table, alpha/beta coefficients, logN band widths"
      contains: "var eBands"
    - path: "internal/celt/modes.go"
      provides: "Frame configuration by size (120/240/480/960 samples)"
      contains: "type ModeConfig"
    - path: "internal/celt/decoder.go"
      provides: "Stateful CELT decoder struct"
      contains: "type Decoder struct"
  key_links:
    - from: "internal/celt/decoder.go"
      to: "internal/celt/modes.go"
      via: "frame config lookup"
      pattern: "GetModeConfig|modeConfigs"
---

<objective>
Create the CELT decoder foundation with static tables, mode configurations, and decoder struct.

Purpose: Establish the data structures and constants required by all subsequent CELT decoding operations. The decoder struct maintains state across frames for overlap-add synthesis and energy prediction.

Output: `internal/celt/tables.go`, `internal/celt/modes.go`, `internal/celt/decoder.go` with all foundational types and tables.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-celt-decoder/03-CONTEXT.md
@.planning/phases/03-celt-decoder/03-RESEARCH.md
@internal/rangecoding/decoder.go
@internal/silk/decoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CELT static tables</name>
  <files>internal/celt/tables.go</files>
  <action>
Create `internal/celt/tables.go` with all static lookup tables required for CELT decoding:

1. **eBands table** (22 values) - Band edge MDCT bin indices for 5ms base:
   ```go
   var eBands = [22]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 34, 40, 48, 60, 78, 100}
   ```
   These are bin indices, scaled for different frame sizes.

2. **Alpha coefficients** (4 values) - Inter-frame energy prediction by LM:
   ```go
   var alphaCoef = [4]float64{...} // For LM=0,1,2,3 (frame size modes)
   ```
   Extract exact values from RFC 6716 Section 4.3.2.

3. **Beta coefficients** (4 values) - Inter-band energy prediction by LM.

4. **logN table** (21 values) - Log2 of band widths for bit allocation:
   ```go
   var logN = [21]int{...} // log2(bandWidth) for each band
   ```

5. **Small division table** - For efficient Laplace decoding in energy:
   ```go
   var smallDiv = [129]uint16{...}
   ```

Add constants:
- `MaxBands = 21` - Maximum frequency bands
- `Overlap = 120` - Overlap samples at 48kHz (2.5ms)
- `DB6 = 6.0` - Coarse energy quantization step (6 dB)
- `PreemphCoef = 0.85` - De-emphasis filter coefficient

Reference libopus `celt/modes.c` and `celt/static_modes_float.h` for exact values.
  </action>
  <verify>
`go build ./internal/celt/` compiles without errors. Verify table lengths match expected counts.
  </verify>
  <done>
tables.go contains eBands[22], alphaCoef[4], betaCoef[4], logN[21], smallDiv[129], and all required constants.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CELT mode configuration</name>
  <files>internal/celt/modes.go</files>
  <action>
Create `internal/celt/modes.go` with frame size configuration:

1. **ModeConfig struct**:
   ```go
   type ModeConfig struct {
       FrameSize    int   // Samples at 48kHz: 120, 240, 480, 960
       ShortBlocks  int   // Number of short MDCTs if transient: 1, 2, 4, 8
       LM           int   // Log mode: 0, 1, 2, 3
       EffBands     int   // Effective bands for this frame size
       MDCTSize     int   // MDCT window size (always 120 for short blocks)
   }
   ```

2. **Mode configurations** by frame size:
   - 120 samples (2.5ms): LM=0, 1 short block, ~13 effective bands
   - 240 samples (5ms): LM=1, 2 short blocks, ~17 effective bands
   - 480 samples (10ms): LM=2, 4 short blocks, ~19 effective bands
   - 960 samples (20ms): LM=3, 8 short blocks, 21 effective bands

3. **GetModeConfig(frameSize int) ModeConfig** - Lookup function returning config for frame size.

4. **Bandwidth enumeration** for CELT:
   ```go
   type CELTBandwidth int
   const (
       CELTNarrowband   CELTBandwidth = iota // 4kHz
       CELTMediumband                         // 6kHz
       CELTWideband                           // 8kHz
       CELTSuperwideband                      // 12kHz
       CELTFullband                           // 20kHz
   )
   ```

5. **Bandwidth to effective bands mapping** - Returns number of coded bands based on bandwidth.

Reference libopus `celt/modes.c` for exact band counts per mode.
  </action>
  <verify>
`go build ./internal/celt/` compiles. `GetModeConfig(960).EffBands == 21` and `GetModeConfig(120).LM == 0`.
  </verify>
  <done>
modes.go contains ModeConfig struct, lookup by frame size, bandwidth enumeration, and band count mapping.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CELT decoder struct</name>
  <files>internal/celt/decoder.go</files>
  <action>
Create `internal/celt/decoder.go` with the stateful CELT decoder:

1. **Decoder struct** with required state:
   ```go
   type Decoder struct {
       // Configuration
       channels    int          // 1 or 2
       sampleRate  int          // Output sample rate

       // Range decoder (set per frame)
       rangeDecoder *rangecoding.Decoder

       // Energy state (persists across frames)
       prevEnergy  []float64    // Previous frame band energies [MaxBands * channels]
       prevEnergy2 []float64    // Two frames ago (for anti-collapse)

       // Synthesis state
       overlapBuffer []float64  // Previous frame overlap tail [Overlap * channels]
       preemphState  []float64  // De-emphasis filter state [channels]

       // Postfilter state
       postfilterPeriod  int
       postfilterGain    float64
       postfilterTapset  int

       // Error recovery / RNG
       rng uint32
   }
   ```

2. **NewDecoder(channels int) *Decoder** - Constructor with proper initialization:
   - Allocate slices for energy, overlap, preemph state
   - Initialize RNG seed

3. **Reset()** - Clear all state for new stream.

4. **SetRangeDecoder(rd *rangecoding.Decoder)** - Set decoder for current frame.

5. Accessor methods matching SILK decoder pattern:
   - `Channels() int`
   - `PrevEnergy() []float64`
   - `OverlapBuffer() []float64`

Follow the pattern established in `internal/silk/decoder.go` for consistency.
  </action>
  <verify>
`go build ./internal/celt/` compiles. `NewDecoder(2).Channels() == 2` and overlap buffer has length `240` (120 * 2 channels).
  </verify>
  <done>
decoder.go contains Decoder struct, NewDecoder constructor, Reset method, and accessor methods. State arrays properly sized for stereo.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/celt/` compiles without errors
2. `go test ./internal/celt/...` passes (no tests yet, but build succeeds)
3. Package exports: `Decoder`, `NewDecoder`, `GetModeConfig`, `eBands`, `MaxBands`
</verification>

<success_criteria>
- CELT package exists at `internal/celt/`
- eBands table has 22 entries with correct band edges
- ModeConfig provides frame size parameters for 120/240/480/960 samples
- Decoder struct maintains energy and overlap state for stereo
- Pattern matches existing SILK decoder for consistency
</success_criteria>

<output>
After completion, create `.planning/phases/03-celt-decoder/03-01-SUMMARY.md`
</output>
