---
phase: 03-celt-decoder
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/celt/cwrs.go
  - internal/celt/cwrs_test.go
autonomous: true

must_haves:
  truths:
    - "CWRS can decode pulse vectors from combinatorial indices"
    - "PVQ codebook sizes V(N,K) computed correctly"
    - "Sign bits extracted correctly for non-zero pulses"
  artifacts:
    - path: "internal/celt/cwrs.go"
      provides: "CWRS combinatorial decoding for PVQ"
      exports: ["DecodePulses", "PVQ_V"]
    - path: "internal/celt/cwrs_test.go"
      provides: "Unit tests for CWRS indexing"
      contains: "func Test"
  key_links:
    - from: "internal/celt/cwrs.go"
      to: "precomputed U table"
      via: "lookup"
      pattern: "pvqU\\["
---

<objective>
Implement CWRS (Combinatorial Radix-based With Signs) combinatorial indexing for PVQ (Pyramid Vector Quantization) decoding.

Purpose: CWRS is the core algorithm for decoding normalized band vectors from compact indices. It's mathematically complex (combinatorial recurrence relations) and must be implemented exactly per libopus to ensure bit-exact decoding.

Output: `internal/celt/cwrs.go` with U-table, V-function, and DecodePulses decoder.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-celt-decoder/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CWRS U-table and V-function</name>
  <files>internal/celt/cwrs.go</files>
  <action>
Create `internal/celt/cwrs.go` with the PVQ codebook size calculations:

1. **Precomputed U(N,K) table** - Port from libopus `celt/cwrs.c`:
   ```go
   // U(N,K) = number of PVQ codewords with N dimensions, K pulses,
   // where position 0 has no pulse.
   // Table indexed as: pvqU[n][k] for small n,k
   // For larger values, use recurrence relation.
   ```

   The table is approximately 1488 values. Extract exact values from `CELT_PVQ_U_DATA` in libopus.

   Use a compact representation:
   ```go
   // pvqU stores U(n,k) for n=0..MAX_N, k=0..MAX_K
   // Access: pvqU[n*stride + k] or 2D slice
   var pvqU = [][]uint32{...}
   ```

2. **PVQ_V(n, k int) uint32** - Compute V(N,K):
   ```go
   // V(N,K) = total codewords = U(N,K) + U(N,K+1) for K>0
   // V(N,0) = 1
   func PVQ_V(n, k int) uint32 {
       if k == 0 {
           return 1
       }
       if n == 1 {
           return uint32(2*k + 1) // -k to +k
       }
       return pvqU[n][k] + pvqU[n][k+1]
   }
   ```

3. **Constants**:
   ```go
   const (
       MaxPulses = 128  // Maximum K for precomputed table
       MaxDim    = 200  // Maximum N for precomputed table
   )
   ```

Reference: libopus `celt/cwrs.c` functions `icwrs()` and table `CELT_PVQ_U_DATA[]`.

Note: The U-table uses a specific indexing scheme. Follow libopus exactly - don't try to optimize the layout.
  </action>
  <verify>
`go build ./internal/celt/` compiles. `PVQ_V(2, 1) == 5` (vectors: [1,0], [-1,0], [0,1], [0,-1], and we need to check exact value).
  </verify>
  <done>
cwrs.go contains pvqU table with all required values and PVQ_V function matching libopus output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement DecodePulses function</name>
  <files>internal/celt/cwrs.go</files>
  <action>
Add the core CWRS decoding function to `internal/celt/cwrs.go`:

1. **DecodePulses(index uint32, n, k int) []int** - Decode pulse vector from index:
   ```go
   // DecodePulses converts a CWRS index to a pulse vector.
   // index: the combinatorial index (0 to V(n,k)-1)
   // n: number of dimensions (band width)
   // k: total number of pulses (sum of absolute values)
   // Returns: pulse vector of length n, where sum(|v[i]|) == k
   func DecodePulses(index uint32, n, k int) []int {
       y := make([]int, n)

       for i := 0; i < n-1 && k > 0; i++ {
           // Determine number of pulses at position i
           p := 0
           var cumulative uint32 = 0

           for {
               // Count codewords with exactly p pulses at position i
               // This uses the recurrence: V(n-i-1, k-p)
               vRemaining := PVQ_V(n-i-1, k-p)
               if index < cumulative + vRemaining {
                   break
               }
               cumulative += vRemaining
               p++
           }

           index -= cumulative

           // Extract sign if p > 0
           if p > 0 {
               if index&1 == 1 {
                   p = -p
               }
               index >>= 1
           }

           y[i] = p
           k -= abs(p)
       }

       // Last position gets remaining pulses
       if k > 0 {
           y[n-1] = k
           if index&1 == 1 {
               y[n-1] = -k
           }
       }

       return y
   }
   ```

2. **Helper function** `abs(x int) int` if not using math.Abs.

3. **EncodePulses (optional, for testing)** - The reverse operation to verify round-trip.
   If time permits, implement to validate DecodePulses works correctly.

The algorithm walks through positions, determining how many pulses go at each position by counting codewords in the combinatorial structure.

Reference: libopus `celt/cwrs.c` function `decode_pulses()`.
  </action>
  <verify>
`go build ./internal/celt/` compiles. Verify with known test case: `DecodePulses(0, 3, 2)` should produce a specific vector.
  </verify>
  <done>
DecodePulses function decodes combinatorial indices to pulse vectors with correct sign handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add CWRS unit tests</name>
  <files>internal/celt/cwrs_test.go</files>
  <action>
Create `internal/celt/cwrs_test.go` with comprehensive tests:

1. **TestPVQ_V** - Verify codebook sizes:
   ```go
   func TestPVQ_V(t *testing.T) {
       tests := []struct{n, k int; want uint32}{
           {1, 0, 1},    // Single dimension, no pulses
           {1, 1, 3},    // -1, 0, +1
           {2, 1, 5},    // Verify exact value
           {3, 2, ...},  // Known from libopus
           // Add more known values
       }
       for _, tc := range tests {
           got := PVQ_V(tc.n, tc.k)
           if got != tc.want {
               t.Errorf("PVQ_V(%d,%d) = %d, want %d", tc.n, tc.k, got, tc.want)
           }
       }
   }
   ```

2. **TestDecodePulses** - Verify decoding:
   ```go
   func TestDecodePulses(t *testing.T) {
       tests := []struct{
           index uint32
           n, k  int
           want  []int
       }{
           // Known test vectors from libopus
           {0, 2, 1, []int{1, 0}},  // First codeword
           // Add more cases
       }
       for _, tc := range tests {
           got := DecodePulses(tc.index, tc.n, tc.k)
           if !slicesEqual(got, tc.want) {
               t.Errorf("DecodePulses(%d, %d, %d) = %v, want %v",
                   tc.index, tc.n, tc.k, got, tc.want)
           }
       }
   }
   ```

3. **TestDecodePulsesRoundTrip** - If EncodePulses exists:
   - Generate random pulse vectors
   - Encode then decode
   - Verify output matches input

4. **TestDecodePulsesSumProperty** - Verify sum(|pulses|) == k for all outputs.

5. **BenchmarkDecodePulses** - Performance baseline:
   ```go
   func BenchmarkDecodePulses(b *testing.B) {
       for i := 0; i < b.N; i++ {
           DecodePulses(12345, 16, 8)
       }
   }
   ```
  </action>
  <verify>
`go test ./internal/celt/... -v` passes all CWRS tests. Verify sum property holds for decoded vectors.
  </verify>
  <done>
cwrs_test.go contains tests for PVQ_V, DecodePulses with known vectors, sum property verification, and benchmark.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/celt/` compiles
2. `go test ./internal/celt/... -v` passes all tests
3. `PVQ_V(n, k)` matches libopus values for small n,k
4. `DecodePulses` produces vectors where `sum(|v|) == k`
</verification>

<success_criteria>
- CWRS U-table populated with correct values from libopus
- PVQ_V computes codebook sizes matching reference
- DecodePulses correctly extracts pulse vectors from indices
- All test cases pass including sum property verification
</success_criteria>

<output>
After completion, create `.planning/phases/03-celt-decoder/03-02-SUMMARY.md`
</output>
