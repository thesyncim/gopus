---
phase: 03-celt-decoder
plan: 04
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - internal/celt/pvq.go
  - internal/celt/bands.go
  - internal/celt/folding.go
  - internal/celt/bands_test.go
autonomous: true

# Note: This plan has 4 tasks with tightly-coupled PVQ logic. Splitting would
# create artificial boundaries between components that must work together.
# The tasks are: (1) PVQ core decode, (2) folding for uncoded bands,
# (3) orchestration layer, (4) tests. Each is well-scoped at ~20% context.

must_haves:
  truths:
    - "PVQ vectors normalize to unit energy after pulse decoding"
    - "Bands with zero allocation use folded vectors from lower bands"
    - "Band processing iterates from low to high frequency"
    - "Collapse mask tracks which bands received pulses"
  artifacts:
    - path: "internal/celt/pvq.go"
      provides: "PVQ vector decoding and normalization"
      exports: ["DecodePVQ", "NormalizeVector"]
    - path: "internal/celt/bands.go"
      provides: "Band-by-band decoding orchestration"
      exports: ["DecodeBands"]
    - path: "internal/celt/folding.go"
      provides: "Band folding for uncoded bands"
      exports: ["FoldBand"]
    - path: "internal/celt/bands_test.go"
      provides: "Unit tests for band processing"
      contains: "func Test"
  key_links:
    - from: "internal/celt/pvq.go"
      to: "internal/celt/cwrs.go"
      via: "CWRS index to pulse vector"
      pattern: "DecodePulses"
    - from: "internal/celt/bands.go"
      to: "internal/celt/pvq.go"
      via: "PVQ decoding per band"
      pattern: "DecodePVQ"
    - from: "internal/celt/folding.go"
      to: "internal/celt/bands.go"
      via: "folding for uncoded bands"
      pattern: "FoldBand"
---

<objective>
Implement PVQ (Pyramid Vector Quantization) band decoding with CWRS index conversion and band folding for uncoded bands.

Purpose: PVQ encodes the "shape" of each frequency band as a normalized vector. Bands with insufficient bits use folding (copying from lower coded bands with sign variation). This completes the spectral coefficient reconstruction needed for IMDCT.

Output: `internal/celt/pvq.go`, `internal/celt/bands.go`, `internal/celt/folding.go` with band processing pipeline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-celt-decoder/03-RESEARCH.md
@internal/celt/cwrs.go
@internal/celt/tables.go
@internal/celt/decoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PVQ vector decoding and normalization</name>
  <files>internal/celt/pvq.go</files>
  <action>
Create `internal/celt/pvq.go` with PVQ shape decoding:

1. **DecodePVQ** - Decode PVQ vector for a band:
   ```go
   // DecodePVQ decodes a PVQ codeword from the range decoder.
   // n: band width (number of MDCT bins)
   // k: number of pulses (from bit allocation)
   // Returns: normalized float64 vector of length n
   func (d *Decoder) DecodePVQ(n, k int) []float64 {
       if k == 0 {
           // No pulses - return zero vector (will be folded)
           return make([]float64, n)
       }

       // Read CWRS index from range coder
       // Index has V(n,k) possible values
       vSize := PVQ_V(n, k)
       index := d.rangeDecoder.DecodeUniform(vSize)

       // Convert index to pulse vector using CWRS
       pulses := DecodePulses(index, n, k)

       // Normalize to unit energy
       return NormalizeVector(intToFloat(pulses))
   }
   ```

2. **NormalizeVector** - L2 normalization:
   ```go
   // NormalizeVector scales vector to unit L2 norm.
   func NormalizeVector(v []float64) []float64 {
       var energy float64
       for _, x := range v {
           energy += x * x
       }
       if energy < 1e-15 {
           return v // Avoid div by zero
       }
       scale := 1.0 / math.Sqrt(energy)
       result := make([]float64, len(v))
       for i, x := range v {
           result[i] = x * scale
       }
       return result
   }
   ```

3. **intToFloat** helper - Convert pulse ints to float64.

4. **Theta decoding** for stereo (if dual stereo):
   ```go
   // DecodeTheta decodes stereo angle for mid-side mixing.
   // Returns theta in [0, pi/2] range.
   func (d *Decoder) DecodeTheta(n int) float64
   ```

Reference libopus `celt/bands.c` function `quant_band()` (decode path).
  </action>
  <verify>
`go build ./internal/celt/` compiles. NormalizeVector produces unit-length vectors.
  </verify>
  <done>
pvq.go contains DecodePVQ with CWRS decoding, NormalizeVector for L2 normalization, and theta decoding for stereo.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement band folding</name>
  <files>internal/celt/folding.go</files>
  <action>
Create `internal/celt/folding.go` for uncoded band reconstruction:

1. **FoldBand** - Copy from lower band with sign variation:
   ```go
   // FoldBand generates a normalized vector by folding from a lower band.
   // lowband: the source band vector (already decoded)
   // n: width of target band
   // seed: RNG state for sign variation
   // Returns: normalized vector of length n
   func FoldBand(lowband []float64, n int, seed *uint32) []float64 {
       result := make([]float64, n)

       if len(lowband) == 0 {
           // No source band - generate noise
           for i := 0; i < n; i++ {
               *seed = *seed*1664525 + 1013904223  // LCG
               result[i] = float64(int32(*seed)) / float64(1<<31)
           }
       } else {
           // Copy from lower band with sign flips
           for i := 0; i < n; i++ {
               sign := 1.0
               if *seed&0x8000 != 0 {
                   sign = -1.0
               }
               *seed = *seed*1664525 + 1013904223
               result[i] = sign * lowband[i%len(lowband)]
           }
       }

       return NormalizeVector(result)
   }
   ```

2. **FindFoldSource** - Locate source band for folding:
   ```go
   // FindFoldSource finds the band to fold from for an uncoded band.
   // Returns index of source band and offset within it.
   func FindFoldSource(targetBand int, codedMask uint32) (srcBand, offset int)
   ```

   Logic: Search backwards for a coded band with sufficient width.

3. **Collapse mask tracking**:
   ```go
   // UpdateCollapseMask marks a band as having received pulses.
   func UpdateCollapseMask(mask *uint32, band int)

   // NeedsAntiCollapse checks if band collapsed (no pulses in transient).
   func NeedsAntiCollapse(mask uint32, band int) bool
   ```

Reference libopus `celt/bands.c` for folding and collapse logic.
  </action>
  <verify>
`go build ./internal/celt/` compiles. FoldBand produces unit-normalized vectors.
  </verify>
  <done>
folding.go contains FoldBand with sign variation, FindFoldSource for source band lookup, and collapse mask tracking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement band processing orchestration</name>
  <files>internal/celt/bands.go</files>
  <action>
Create `internal/celt/bands.go` with top-level band decoding:

1. **DecodeBands** - Process all bands in order:
   ```go
   // DecodeBands decodes all frequency bands from the bitstream.
   // energies: per-band energy values (from energy decoding)
   // bandBits: bits allocated per band (from allocation)
   // nbBands: number of bands to decode
   // Returns: MDCT coefficients (denormalized)
   func (d *Decoder) DecodeBands(
       energies []float64,
       bandBits []int,
       nbBands int,
       stereo bool,
   ) []float64
   ```

2. **Band processing loop**:
   ```go
   for band := 0; band < nbBands; band++ {
       n := bandWidth(band)  // From eBands table
       k := bitsToK(bandBits[band], n)  // Convert bits to pulse count

       var shape []float64
       if k > 0 {
           shape = d.DecodePVQ(n, k)
           updateCollapseMask(&collapseMask, band)
       } else {
           // No pulses - fold from lower band
           shape = FoldBand(prevBand, n, &d.rng)
       }

       // Denormalize: scale shape by energy
       gain := math.Exp(energies[band] * 0.6931471805599453) // ln(2)
       for i := range shape {
           coeffs[offset+i] = shape[i] * gain
       }

       offset += n
       prevBand = shape
   }
   ```

3. **bitsToK** - Convert bits to pulse count:
   ```go
   // bitsToK computes number of PVQ pulses from bit allocation.
   // Uses precomputed cache or iterative search.
   func bitsToK(bits, n int) int
   ```

   This is the inverse of the encoding rate computation.

4. **Stereo band processing** (if stereo):
   - Decode mid channel, then side channel
   - Apply theta rotation for mid-side mixing
   - Or intensity stereo: copy mid to both with inversion flag

Reference libopus `celt/bands.c` function `quant_all_bands()`.
  </action>
  <verify>
`go build ./internal/celt/` compiles. DecodeBands produces coefficient array with length matching frame size.
  </verify>
  <done>
bands.go contains DecodeBands orchestrating PVQ decoding, folding, and denormalization for all bands.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add band processing tests</name>
  <files>internal/celt/bands_test.go</files>
  <action>
Create `internal/celt/bands_test.go` with unit tests:

1. **TestNormalizeVector**:
   ```go
   func TestNormalizeVector(t *testing.T) {
       v := []float64{3, 4}
       norm := NormalizeVector(v)
       // Should be [0.6, 0.8]
       if math.Abs(norm[0]-0.6) > 1e-10 || math.Abs(norm[1]-0.8) > 1e-10 {
           t.Errorf("NormalizeVector(%v) = %v, want [0.6, 0.8]", v, norm)
       }
       // Check unit length
       var len2 float64
       for _, x := range norm { len2 += x*x }
       if math.Abs(len2-1.0) > 1e-10 {
           t.Errorf("normalized vector length^2 = %v, want 1.0", len2)
       }
   }
   ```

2. **TestFoldBand**:
   - Verify folded bands have unit norm
   - Verify sign variation with different seeds
   - Test noise generation when no source band

3. **TestBitsToK**:
   - Verify bits-to-pulses conversion for known cases
   - Test edge cases: 0 bits -> 0 pulses

4. **TestDecodeBands_Output**:
   - Mock range decoder with test data
   - Verify output length matches frame size
   - Verify denormalization applies energy scaling

5. **BenchmarkDecodeBands**:
   ```go
   func BenchmarkDecodeBands(b *testing.B) {
       dec := NewDecoder(1)
       energies := make([]float64, 21)
       bandBits := make([]int, 21)
       for i := range bandBits { bandBits[i] = 50 }

       b.ResetTimer()
       for i := 0; i < b.N; i++ {
           dec.DecodeBands(energies, bandBits, 21, false)
       }
   }
   ```
  </action>
  <verify>
`go test ./internal/celt/... -v` passes all band processing tests.
  </verify>
  <done>
bands_test.go contains tests for normalization, folding, bits-to-K conversion, and full band decoding.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/celt/` compiles
2. `go test ./internal/celt/... -v` passes all tests
3. PVQ vectors are unit-normalized
4. Folded bands maintain unit norm with sign variation
5. Band decoding produces correct-length coefficient arrays
</verification>

<success_criteria>
- PVQ decoding converts CWRS indices to normalized vectors
- Band folding reconstructs uncoded bands from lower bands
- Collapse mask tracks which bands received pulses
- DecodeBands orchestrates full spectral reconstruction
- All tests passing with normalized outputs
</success_criteria>

<output>
After completion, create `.planning/phases/03-celt-decoder/03-04-SUMMARY.md`
</output>
