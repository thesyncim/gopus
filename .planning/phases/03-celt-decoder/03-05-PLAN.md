---
phase: 03-celt-decoder
plan: 05
type: execute
wave: 3
depends_on: ["03-03", "03-04"]
files_modified:
  - internal/celt/mdct.go
  - internal/celt/window.go
  - internal/celt/stereo.go
  - internal/celt/synthesis.go
  - internal/celt/decoder.go
  - internal/celt/mdct_test.go
autonomous: true

must_haves:
  truths:
    - "IMDCT converts frequency coefficients to time-domain samples"
    - "Overlap-add produces continuous audio across frame boundaries"
    - "Vorbis window ensures power-complementary reconstruction"
    - "Stereo unmixing correctly separates left and right channels"
    - "Transient frames use multiple short MDCTs without audible artifacts"
    - "Decoder.DecodeFrame() produces complete audio output from raw bytes"
  artifacts:
    - path: "internal/celt/mdct.go"
      provides: "IMDCT via FFT"
      exports: ["IMDCT", "IMDCTShort"]
    - path: "internal/celt/window.go"
      provides: "Vorbis power-complementary window"
      exports: ["VorbisWindow", "WindowBuffer"]
    - path: "internal/celt/stereo.go"
      provides: "Mid-side and intensity stereo"
      exports: ["MidSideToLR", "IntensityStereo"]
    - path: "internal/celt/synthesis.go"
      provides: "Overlap-add synthesis"
      exports: ["OverlapAdd", "Synthesize"]
    - path: "internal/celt/decoder.go"
      provides: "Full frame decoding orchestration"
      exports: ["DecodeFrame"]
    - path: "internal/celt/mdct_test.go"
      provides: "Unit tests for MDCT and synthesis"
      contains: "func Test"
  key_links:
    - from: "internal/celt/synthesis.go"
      to: "internal/celt/mdct.go"
      via: "IMDCT for time-domain"
      pattern: "IMDCT"
    - from: "internal/celt/synthesis.go"
      to: "internal/celt/window.go"
      via: "windowing"
      pattern: "VorbisWindow|WindowBuffer"
    - from: "internal/celt/synthesis.go"
      to: "internal/celt/stereo.go"
      via: "channel separation"
      pattern: "MidSideToLR|IntensityStereo"
    - from: "internal/celt/decoder.go"
      to: "internal/celt/synthesis.go"
      via: "full frame assembly"
      pattern: "Synthesize|OverlapAdd"
---

<objective>
Implement IMDCT synthesis, Vorbis windowing, overlap-add reconstruction, stereo channel separation, and complete decoder frame orchestration.

Purpose: This completes the CELT decoder by converting frequency-domain coefficients back to time-domain audio samples. The IMDCT with overlap-add ensures seamless reconstruction. Stereo processing separates mid-side encoded channels. The DecodeFrame method ties all components together.

Output: `internal/celt/mdct.go`, `internal/celt/window.go`, `internal/celt/stereo.go`, `internal/celt/synthesis.go` with full synthesis pipeline, plus `DecodeFrame()` integration in `decoder.go`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-celt-decoder/03-RESEARCH.md
@internal/celt/decoder.go
@internal/celt/modes.go
@internal/celt/bands.go
@internal/celt/energy.go
@internal/celt/alloc.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FFT-based IMDCT</name>
  <files>internal/celt/mdct.go</files>
  <action>
Create `internal/celt/mdct.go` with IMDCT implementation:

1. **FFT helper** - Radix-2 Cooley-Tukey:
   ```go
   // fft computes in-place complex FFT.
   // Uses radix-2 decimation-in-time.
   func fft(real, imag []float64)

   // ifft computes in-place inverse FFT.
   func ifft(real, imag []float64)
   ```

   Or use a combined complex slice: `[]complex128`.

2. **IMDCT** - Inverse Modified DCT:
   ```go
   // IMDCT computes the inverse MDCT of frequency coefficients.
   // Input: n frequency bins
   // Output: 2*n time samples (only n unique due to symmetry)
   // Uses FFT for O(n log n) complexity.
   func IMDCT(spectrum []float64) []float64 {
       n := len(spectrum)
       n2 := n * 2

       // Pre-twiddle: multiply by exp(-i*pi*(k+0.5+n/2)/n)
       // Convert to complex for FFT

       // FFT of n/2 complex points

       // Post-twiddle: multiply by exp(-i*pi*(k+0.5)/(2*n))

       // Expand to 2*n points using MDCT symmetry

       return output
   }
   ```

3. **Precomputed twiddles** for efficiency:
   ```go
   // mdctTwiddles contains precomputed twiddle factors.
   // Generated for each supported MDCT size (120, 240, 480, 960).
   var mdctTwiddles = map[int][]complex128{...}

   // initTwiddles precomputes twiddle factors for a size.
   func initTwiddles(n int) []complex128
   ```

4. **Short block interleaving** for transients:
   ```go
   // IMDCTShort computes IMDCT for transient frames with multiple short blocks.
   // coeffs: interleaved coefficients for shortBlocks MDCTs
   // shortBlocks: number of short MDCTs (1, 2, 4, or 8)
   // Returns: interleaved time samples
   func IMDCTShort(coeffs []float64, shortBlocks int) []float64
   ```

Reference libopus `celt/mdct.c` and `celt/kiss_fft.c` for FFT approach.
  </action>
  <verify>
`go build ./internal/celt/` compiles. IMDCT produces correct output length (2*input length).
  </verify>
  <done>
mdct.go contains FFT-based IMDCT with precomputed twiddles and short block support for transients.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Vorbis window and overlap-add</name>
  <files>internal/celt/window.go, internal/celt/synthesis.go</files>
  <action>
Create `internal/celt/window.go` with Vorbis window:

1. **VorbisWindow** - Power-complementary window function:
   ```go
   // VorbisWindow computes the Vorbis window value at position i of n.
   // w(i) = sin(pi/2 * sin^2(pi*(i+0.5)/n))
   func VorbisWindow(i, n int) float64 {
       x := float64(i) + 0.5
       return math.Sin(math.Pi / 2.0 * math.Pow(math.Sin(math.Pi*x/float64(n)), 2))
   }
   ```

2. **Precomputed window buffer**:
   ```go
   // windowBuffer contains precomputed window for overlap size.
   // Generated for overlap=120 (2.5ms at 48kHz).
   var windowBuffer = make([]float64, 120)

   func init() {
       for i := 0; i < 120; i++ {
           windowBuffer[i] = VorbisWindow(i, 240) // 240 = 2*overlap
       }
   }
   ```

Create `internal/celt/synthesis.go` with overlap-add:

3. **OverlapAdd** - Combine overlapping frames:
   ```go
   // OverlapAdd combines current frame with previous overlap.
   // current: windowed IMDCT output
   // prevOverlap: tail from previous frame
   // Returns: reconstructed samples and new overlap tail
   func OverlapAdd(current, prevOverlap []float64, overlap int) (output, newOverlap []float64) {
       n := len(current)
       output = make([]float64, n-overlap)

       // First overlap samples: sum with previous
       for i := 0; i < overlap; i++ {
           output[i] = prevOverlap[i] + current[i]
       }

       // Middle samples: copy directly
       copy(output[overlap:], current[overlap:n-overlap])

       // New overlap: tail of current frame
       newOverlap = make([]float64, overlap)
       copy(newOverlap, current[n-overlap:])

       return output, newOverlap
   }
   ```

4. **WindowAndOverlap** - Apply window then overlap-add:
   ```go
   // WindowAndOverlap applies Vorbis window and performs overlap-add.
   func (d *Decoder) WindowAndOverlap(imdctOut []float64) []float64
   ```

5. **Synthesize** - Full synthesis for a frame:
   ```go
   // Synthesize performs IMDCT + windowing + overlap-add for decoded coefficients.
   // coeffs: MDCT coefficients from DecodeBands
   // transient: true if frame uses short blocks
   // shortBlocks: number of short MDCTs if transient
   // Returns: PCM samples for this frame
   func (d *Decoder) Synthesize(coeffs []float64, transient bool, shortBlocks int) []float64
   ```

Reference RFC 6716 Section 4.3.5 and libopus `celt/celt_decoder.c`.
  </action>
  <verify>
`go build ./internal/celt/` compiles. Overlap-add produces continuous samples across frames.
  </verify>
  <done>
window.go contains VorbisWindow and precomputed buffer. synthesis.go contains OverlapAdd and Synthesize for seamless reconstruction.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement stereo processing</name>
  <files>internal/celt/stereo.go</files>
  <action>
Create `internal/celt/stereo.go` with stereo modes:

1. **MidSideToLR** - Convert mid-side to left-right:
   ```go
   // MidSideToLR converts mid-side stereo to left-right.
   // mid, side: frequency-domain coefficients for each band
   // theta: stereo angle (0 = mono, pi/2 = full stereo)
   // Returns: left, right coefficient arrays
   func MidSideToLR(mid, side []float64, theta float64) (left, right []float64) {
       n := len(mid)
       left = make([]float64, n)
       right = make([]float64, n)

       cosT := math.Cos(theta)
       sinT := math.Sin(theta)

       for i := 0; i < n; i++ {
           left[i] = cosT*mid[i] + sinT*side[i]
           right[i] = cosT*mid[i] - sinT*side[i]
       }

       return left, right
   }
   ```

2. **IntensityStereo** - Simple intensity stereo:
   ```go
   // IntensityStereo creates stereo from mono with optional inversion.
   // mono: the mid channel coefficients
   // invert: if true, right channel is inverted
   // Returns: left, right coefficient arrays
   func IntensityStereo(mono []float64, invert bool) (left, right []float64) {
       n := len(mono)
       left = make([]float64, n)
       right = make([]float64, n)

       copy(left, mono)
       if invert {
           for i := 0; i < n; i++ {
               right[i] = -mono[i]
           }
       } else {
           copy(right, mono)
       }

       return left, right
   }
   ```

3. **DualStereo** - Full dual-channel decode:
   ```go
   // DualStereo decodes two independent channels.
   // Called when dual_stereo flag is set in bitstream.
   // Returns: coefficients for both channels
   func (d *Decoder) DualStereo(nbBands int, energies [][]float64, bandBits [][]int) (left, right []float64)
   ```

4. **Per-band stereo mode selection**:
   ```go
   // StereoMode for a band
   type StereoMode int
   const (
       StereoMidSide StereoMode = iota
       StereoIntensity
       StereoDual
   )

   // GetStereoMode determines stereo mode for a band.
   func GetStereoMode(band, intensityBand int, dualStereo bool) StereoMode
   ```

Reference libopus `celt/bands.c` stereo handling.
  </action>
  <verify>
`go build ./internal/celt/` compiles. MidSideToLR produces correct left-right separation.
  </verify>
  <done>
stereo.go contains MidSideToLR, IntensityStereo, DualStereo, and per-band mode selection.
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement Decoder.DecodeFrame() integration</name>
  <files>internal/celt/decoder.go</files>
  <action>
Add the full frame decoding method to `internal/celt/decoder.go`:

1. **DecodeFrame** - Complete frame decoding pipeline:
   ```go
   // DecodeFrame decodes a complete CELT frame from raw bytes.
   // data: raw CELT frame bytes (without Opus framing)
   // frameSize: expected output samples (120, 240, 480, or 960)
   // Returns: PCM samples as float64 slice, interleaved if stereo
   func (d *Decoder) DecodeFrame(data []byte, frameSize int) ([]float64, error) {
       // 1. Initialize range decoder with frame data
       rd, err := rangecoding.NewDecoder(data)
       if err != nil {
           return nil, fmt.Errorf("range decoder init: %w", err)
       }
       d.SetRangeDecoder(rd)

       // 2. Get mode config for frame size
       mode := GetModeConfig(frameSize)

       // 3. Decode frame header flags
       //    - silence flag
       //    - postfilter flag
       //    - transient flag
       //    - intra flag
       //    - spread decision
       transient := d.decodeTransientFlag()
       intra := d.decodeIntraFlag()

       // 4. Decode energy envelope
       //    DecodeCoarseEnergy -> DecodeFineEnergy
       nbBands := mode.EffBands
       energies := d.DecodeCoarseEnergy(nbBands, intra)

       // 5. Compute bit allocation
       totalBits := len(data)*8 - rd.BitsUsed()
       bandBits, fineBits := ComputeAllocation(totalBits, nbBands, ...)
       d.DecodeFineEnergy(energies, nbBands, fineBits)

       // 6. Decode bands (PVQ)
       stereo := d.channels == 2
       coeffs := d.DecodeBands(energies, bandBits, nbBands, stereo)

       // 7. Decode energy remainder (leftover bits)
       d.DecodeEnergyRemainder(energies, nbBands, remainderBits)

       // 8. Synthesis: IMDCT + window + overlap-add
       shortBlocks := 1
       if transient {
           shortBlocks = mode.ShortBlocks
       }
       samples := d.Synthesize(coeffs, transient, shortBlocks)

       // 9. Apply de-emphasis filter
       d.applyDeemphasis(samples)

       return samples, nil
   }
   ```

2. **Helper methods** for flag decoding:
   ```go
   func (d *Decoder) decodeTransientFlag() bool
   func (d *Decoder) decodeIntraFlag() bool
   func (d *Decoder) decodeSpread() int
   ```

3. **De-emphasis filter**:
   ```go
   // applyDeemphasis applies the de-emphasis filter for natural sound.
   // CELT uses pre-emphasis during encoding; this reverses it.
   func (d *Decoder) applyDeemphasis(samples []float64)
   ```

4. **Error handling** for malformed frames:
   - Range decoder underflow
   - Invalid frame size
   - Energy values out of range

Reference libopus `celt/celt_decoder.c` function `celt_decode_with_ec()`.
  </action>
  <verify>
`go build ./internal/celt/` compiles. DecodeFrame returns correct sample count for each frame size.
  </verify>
  <done>
decoder.go contains DecodeFrame() that orchestrates complete frame decoding: energy -> allocation -> bands -> synthesis -> de-emphasis.
  </done>
</task>

<task type="auto">
  <name>Task 5: Add synthesis and integration tests</name>
  <files>internal/celt/mdct_test.go</files>
  <action>
Create `internal/celt/mdct_test.go` with comprehensive tests:

1. **TestIMDCT_OutputLength**:
   ```go
   func TestIMDCT_OutputLength(t *testing.T) {
       for _, n := range []int{120, 240, 480, 960} {
           spectrum := make([]float64, n)
           out := IMDCT(spectrum)
           if len(out) != 2*n {
               t.Errorf("IMDCT(%d) output length = %d, want %d", n, len(out), 2*n)
           }
       }
   }
   ```

2. **TestIMDCT_KnownValues**:
   - Test with DC (all zeros except first bin)
   - Test with single sine wave
   - Verify output matches expected waveform

3. **TestIMDCTShort_Transients**:
   ```go
   func TestIMDCTShort_Transients(t *testing.T) {
       // Test that transient detection produces artifact-free output
       for _, shortBlocks := range []int{2, 4, 8} {
           coeffs := make([]float64, 120*shortBlocks)
           // Fill with test pattern (e.g., impulse at start of each block)
           for b := 0; b < shortBlocks; b++ {
               coeffs[b*120] = 1.0
           }

           out := IMDCTShort(coeffs, shortBlocks)

           // Verify output length
           expectedLen := 120 * shortBlocks * 2
           if len(out) != expectedLen {
               t.Errorf("IMDCTShort(%d blocks) length = %d, want %d",
                   shortBlocks, len(out), expectedLen)
           }

           // Verify no discontinuities between blocks (check for large jumps)
           maxJump := 0.0
           blockSize := len(out) / shortBlocks
           for b := 1; b < shortBlocks; b++ {
               boundary := b * blockSize
               jump := math.Abs(out[boundary] - out[boundary-1])
               if jump > maxJump {
                   maxJump = jump
               }
           }
           // Transient handling should keep boundaries smooth
           if maxJump > 0.5 {
               t.Errorf("IMDCTShort(%d blocks) has discontinuity: max jump = %v",
                   shortBlocks, maxJump)
           }
       }
   }
   ```

4. **TestVorbisWindow_PowerComplementary**:
   ```go
   func TestVorbisWindow_PowerComplementary(t *testing.T) {
       n := 240
       for i := 0; i < n/2; i++ {
           w1 := VorbisWindow(i, n)
           w2 := VorbisWindow(n-1-i, n)
           // Power complementary: w1^2 + w2^2 = 1
           sum := w1*w1 + w2*w2
           if math.Abs(sum-1.0) > 1e-10 {
               t.Errorf("window not power-complementary at %d: %v + %v = %v", i, w1*w1, w2*w2, sum)
           }
       }
   }
   ```

5. **TestOverlapAdd_Continuity**:
   - Create two synthetic frames
   - Verify overlap-add produces smooth transition
   - No discontinuities at frame boundary

6. **TestMidSideToLR_Inversion**:
   - Verify left+right = 2*mid (when side=0)
   - Verify left-right = 2*side (when mid=0)

7. **TestDecodeFrame_AllFrameSizes**:
   ```go
   func TestDecodeFrame_AllFrameSizes(t *testing.T) {
       dec := NewDecoder(1)
       for _, frameSize := range []int{120, 240, 480, 960} {
           // Create minimal valid frame (silence)
           data := createSilenceFrame(frameSize)

           samples, err := dec.DecodeFrame(data, frameSize)
           if err != nil {
               t.Errorf("DecodeFrame(frameSize=%d) error: %v", frameSize, err)
               continue
           }

           if len(samples) != frameSize {
               t.Errorf("DecodeFrame(frameSize=%d) returned %d samples, want %d",
                   frameSize, len(samples), frameSize)
           }
       }
   }
   ```

8. **TestDecodeFrame_StereoOutput**:
   ```go
   func TestDecodeFrame_StereoOutput(t *testing.T) {
       dec := NewDecoder(2) // stereo
       data := createSilenceFrame(960)

       samples, err := dec.DecodeFrame(data, 960)
       if err != nil {
           t.Fatalf("DecodeFrame error: %v", err)
       }

       // Stereo output should be 2x frame size (interleaved L,R,L,R...)
       if len(samples) != 960*2 {
           t.Errorf("stereo DecodeFrame returned %d samples, want %d", len(samples), 960*2)
       }
   }
   ```

9. **BenchmarkIMDCT**:
   ```go
   func BenchmarkIMDCT(b *testing.B) {
       spectrum := make([]float64, 960)
       b.ResetTimer()
       for i := 0; i < b.N; i++ {
           IMDCT(spectrum)
       }
   }
   ```

10. **BenchmarkDecodeFrame**:
    ```go
    func BenchmarkDecodeFrame(b *testing.B) {
        dec := NewDecoder(2)
        data := createTestFrame(960) // Realistic test frame

        b.ResetTimer()
        for i := 0; i < b.N; i++ {
            dec.DecodeFrame(data, 960)
        }
    }
    ```
  </action>
  <verify>
`go test ./internal/celt/... -v` passes all synthesis and integration tests.
  </verify>
  <done>
mdct_test.go contains tests for IMDCT (including short blocks for transients), Vorbis window, overlap-add, stereo processing, DecodeFrame integration for all frame sizes, and benchmarks.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/celt/` compiles
2. `go test ./internal/celt/... -v` passes all tests
3. IMDCT produces correct output lengths for all frame sizes
4. IMDCTShort handles transient frames without discontinuities
5. Vorbis window is power-complementary
6. Overlap-add produces continuous audio
7. Stereo processing correctly separates channels
8. DecodeFrame orchestrates complete pipeline for mono and stereo
</verification>

<success_criteria>
- FFT-based IMDCT converts frequency to time domain
- Short block IMDCT handles transient frames correctly
- Vorbis window verified as power-complementary
- Overlap-add produces seamless frame concatenation
- Mid-side and intensity stereo working correctly
- DecodeFrame() provides complete frame decoding API
- All tests passing including integration tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-celt-decoder/03-05-SUMMARY.md`
</output>
