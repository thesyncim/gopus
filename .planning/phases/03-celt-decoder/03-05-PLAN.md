---
phase: 03-celt-decoder
plan: 05
type: execute
wave: 3
depends_on: ["03-03", "03-04"]
files_modified:
  - internal/celt/mdct.go
  - internal/celt/window.go
  - internal/celt/stereo.go
  - internal/celt/synthesis.go
  - internal/celt/mdct_test.go
autonomous: true

must_haves:
  truths:
    - "IMDCT converts frequency coefficients to time-domain samples"
    - "Overlap-add produces continuous audio across frame boundaries"
    - "Vorbis window ensures power-complementary reconstruction"
    - "Stereo unmixing correctly separates left and right channels"
    - "Transient frames use multiple short MDCTs interleaved"
  artifacts:
    - path: "internal/celt/mdct.go"
      provides: "IMDCT via FFT"
      exports: ["IMDCT"]
    - path: "internal/celt/window.go"
      provides: "Vorbis power-complementary window"
      exports: ["VorbisWindow", "WindowBuffer"]
    - path: "internal/celt/stereo.go"
      provides: "Mid-side and intensity stereo"
      exports: ["MidSideToLR", "IntensityStereo"]
    - path: "internal/celt/synthesis.go"
      provides: "Overlap-add synthesis"
      exports: ["OverlapAdd", "Synthesize"]
    - path: "internal/celt/mdct_test.go"
      provides: "Unit tests for MDCT and synthesis"
      contains: "func Test"
  key_links:
    - from: "internal/celt/synthesis.go"
      to: "internal/celt/mdct.go"
      via: "IMDCT for time-domain"
      pattern: "IMDCT"
    - from: "internal/celt/synthesis.go"
      to: "internal/celt/window.go"
      via: "windowing"
      pattern: "VorbisWindow|WindowBuffer"
    - from: "internal/celt/synthesis.go"
      to: "internal/celt/stereo.go"
      via: "channel separation"
      pattern: "MidSideToLR|IntensityStereo"
---

<objective>
Implement IMDCT synthesis, Vorbis windowing, overlap-add reconstruction, and stereo channel separation.

Purpose: This completes the CELT decoder by converting frequency-domain coefficients back to time-domain audio samples. The IMDCT with overlap-add ensures seamless reconstruction. Stereo processing separates mid-side encoded channels.

Output: `internal/celt/mdct.go`, `internal/celt/window.go`, `internal/celt/stereo.go`, `internal/celt/synthesis.go` with full synthesis pipeline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-celt-decoder/03-RESEARCH.md
@internal/celt/decoder.go
@internal/celt/modes.go
@internal/celt/bands.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FFT-based IMDCT</name>
  <files>internal/celt/mdct.go</files>
  <action>
Create `internal/celt/mdct.go` with IMDCT implementation:

1. **FFT helper** - Radix-2 Cooley-Tukey:
   ```go
   // fft computes in-place complex FFT.
   // Uses radix-2 decimation-in-time.
   func fft(real, imag []float64)

   // ifft computes in-place inverse FFT.
   func ifft(real, imag []float64)
   ```

   Or use a combined complex slice: `[]complex128`.

2. **IMDCT** - Inverse Modified DCT:
   ```go
   // IMDCT computes the inverse MDCT of frequency coefficients.
   // Input: n frequency bins
   // Output: 2*n time samples (only n unique due to symmetry)
   // Uses FFT for O(n log n) complexity.
   func IMDCT(spectrum []float64) []float64 {
       n := len(spectrum)
       n2 := n * 2

       // Pre-twiddle: multiply by exp(-i*pi*(k+0.5+n/2)/n)
       // Convert to complex for FFT

       // FFT of n/2 complex points

       // Post-twiddle: multiply by exp(-i*pi*(k+0.5)/(2*n))

       // Expand to 2*n points using MDCT symmetry

       return output
   }
   ```

3. **Precomputed twiddles** for efficiency:
   ```go
   // mdctTwiddles contains precomputed twiddle factors.
   // Generated for each supported MDCT size (120, 240, 480, 960).
   var mdctTwiddles = map[int][]complex128{...}

   // initTwiddles precomputes twiddle factors for a size.
   func initTwiddles(n int) []complex128
   ```

4. **Short block interleaving** for transients:
   ```go
   // IMDCTShort computes IMDCT for transient frames with multiple short blocks.
   // coeffs: interleaved coefficients for shortBlocks MDCTs
   // Returns: interleaved time samples
   func IMDCTShort(coeffs []float64, shortBlocks int) []float64
   ```

Reference libopus `celt/mdct.c` and `celt/kiss_fft.c` for FFT approach.
  </action>
  <verify>
`go build ./internal/celt/` compiles. IMDCT produces correct output length (2*input length).
  </verify>
  <done>
mdct.go contains FFT-based IMDCT with precomputed twiddles and short block support.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Vorbis window and overlap-add</name>
  <files>internal/celt/window.go, internal/celt/synthesis.go</files>
  <action>
Create `internal/celt/window.go` with Vorbis window:

1. **VorbisWindow** - Power-complementary window function:
   ```go
   // VorbisWindow computes the Vorbis window value at position i of n.
   // w(i) = sin(pi/2 * sin^2(pi*(i+0.5)/n))
   func VorbisWindow(i, n int) float64 {
       x := float64(i) + 0.5
       return math.Sin(math.Pi / 2.0 * math.Pow(math.Sin(math.Pi*x/float64(n)), 2))
   }
   ```

2. **Precomputed window buffer**:
   ```go
   // windowBuffer contains precomputed window for overlap size.
   // Generated for overlap=120 (2.5ms at 48kHz).
   var windowBuffer = make([]float64, 120)

   func init() {
       for i := 0; i < 120; i++ {
           windowBuffer[i] = VorbisWindow(i, 240) // 240 = 2*overlap
       }
   }
   ```

Create `internal/celt/synthesis.go` with overlap-add:

3. **OverlapAdd** - Combine overlapping frames:
   ```go
   // OverlapAdd combines current frame with previous overlap.
   // current: windowed IMDCT output
   // prevOverlap: tail from previous frame
   // Returns: reconstructed samples and new overlap tail
   func OverlapAdd(current, prevOverlap []float64, overlap int) (output, newOverlap []float64) {
       n := len(current)
       output = make([]float64, n-overlap)

       // First overlap samples: sum with previous
       for i := 0; i < overlap; i++ {
           output[i] = prevOverlap[i] + current[i]
       }

       // Middle samples: copy directly
       copy(output[overlap:], current[overlap:n-overlap])

       // New overlap: tail of current frame
       newOverlap = make([]float64, overlap)
       copy(newOverlap, current[n-overlap:])

       return output, newOverlap
   }
   ```

4. **WindowAndOverlap** - Apply window then overlap-add:
   ```go
   // WindowAndOverlap applies Vorbis window and performs overlap-add.
   func (d *Decoder) WindowAndOverlap(imdctOut []float64) []float64
   ```

Reference RFC 6716 Section 4.3.5 and libopus `celt/celt_decoder.c`.
  </action>
  <verify>
`go build ./internal/celt/` compiles. Overlap-add produces continuous samples across frames.
  </verify>
  <done>
window.go contains VorbisWindow and precomputed buffer. synthesis.go contains OverlapAdd for seamless reconstruction.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement stereo processing</name>
  <files>internal/celt/stereo.go</files>
  <action>
Create `internal/celt/stereo.go` with stereo modes:

1. **MidSideToLR** - Convert mid-side to left-right:
   ```go
   // MidSideToLR converts mid-side stereo to left-right.
   // mid, side: frequency-domain coefficients for each band
   // theta: stereo angle (0 = mono, pi/2 = full stereo)
   // Returns: left, right coefficient arrays
   func MidSideToLR(mid, side []float64, theta float64) (left, right []float64) {
       n := len(mid)
       left = make([]float64, n)
       right = make([]float64, n)

       cosT := math.Cos(theta)
       sinT := math.Sin(theta)

       for i := 0; i < n; i++ {
           left[i] = cosT*mid[i] + sinT*side[i]
           right[i] = cosT*mid[i] - sinT*side[i]
       }

       return left, right
   }
   ```

2. **IntensityStereo** - Simple intensity stereo:
   ```go
   // IntensityStereo creates stereo from mono with optional inversion.
   // mono: the mid channel coefficients
   // invert: if true, right channel is inverted
   // Returns: left, right coefficient arrays
   func IntensityStereo(mono []float64, invert bool) (left, right []float64) {
       n := len(mono)
       left = make([]float64, n)
       right = make([]float64, n)

       copy(left, mono)
       if invert {
           for i := 0; i < n; i++ {
               right[i] = -mono[i]
           }
       } else {
           copy(right, mono)
       }

       return left, right
   }
   ```

3. **DualStereo** - Full dual-channel decode:
   ```go
   // DualStereo decodes two independent channels.
   // Called when dual_stereo flag is set in bitstream.
   // Returns: coefficients for both channels
   func (d *Decoder) DualStereo(nbBands int, energies [][]float64, bandBits [][]int) (left, right []float64)
   ```

4. **Per-band stereo mode selection**:
   ```go
   // StereoMode for a band
   type StereoMode int
   const (
       StereoMidSide StereoMode = iota
       StereoIntensity
       StereoDual
   )

   // GetStereoMode determines stereo mode for a band.
   func GetStereoMode(band, intensityBand int, dualStereo bool) StereoMode
   ```

Reference libopus `celt/bands.c` stereo handling.
  </action>
  <verify>
`go build ./internal/celt/` compiles. MidSideToLR produces correct left-right separation.
  </verify>
  <done>
stereo.go contains MidSideToLR, IntensityStereo, DualStereo, and per-band mode selection.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add synthesis tests</name>
  <files>internal/celt/mdct_test.go</files>
  <action>
Create `internal/celt/mdct_test.go` with comprehensive tests:

1. **TestIMDCT_OutputLength**:
   ```go
   func TestIMDCT_OutputLength(t *testing.T) {
       for _, n := range []int{120, 240, 480, 960} {
           spectrum := make([]float64, n)
           out := IMDCT(spectrum)
           if len(out) != 2*n {
               t.Errorf("IMDCT(%d) output length = %d, want %d", n, len(out), 2*n)
           }
       }
   }
   ```

2. **TestIMDCT_KnownValues**:
   - Test with DC (all zeros except first bin)
   - Test with single sine wave
   - Verify output matches expected waveform

3. **TestVorbisWindow_PowerComplementary**:
   ```go
   func TestVorbisWindow_PowerComplementary(t *testing.T) {
       n := 240
       for i := 0; i < n/2; i++ {
           w1 := VorbisWindow(i, n)
           w2 := VorbisWindow(n-1-i, n)
           // Power complementary: w1^2 + w2^2 = 1
           sum := w1*w1 + w2*w2
           if math.Abs(sum-1.0) > 1e-10 {
               t.Errorf("window not power-complementary at %d: %v + %v = %v", i, w1*w1, w2*w2, sum)
           }
       }
   }
   ```

4. **TestOverlapAdd_Continuity**:
   - Create two synthetic frames
   - Verify overlap-add produces smooth transition
   - No discontinuities at frame boundary

5. **TestMidSideToLR_Inversion**:
   - Verify left+right = 2*mid (when side=0)
   - Verify left-right = 2*side (when mid=0)

6. **BenchmarkIMDCT**:
   ```go
   func BenchmarkIMDCT(b *testing.B) {
       spectrum := make([]float64, 960)
       b.ResetTimer()
       for i := 0; i < b.N; i++ {
           IMDCT(spectrum)
       }
   }
   ```
  </action>
  <verify>
`go test ./internal/celt/... -v` passes all synthesis tests.
  </verify>
  <done>
mdct_test.go contains tests for IMDCT, Vorbis window, overlap-add, stereo processing, and benchmarks.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/celt/` compiles
2. `go test ./internal/celt/... -v` passes all tests
3. IMDCT produces correct output lengths
4. Vorbis window is power-complementary
5. Overlap-add produces continuous audio
6. Stereo processing correctly separates channels
</verification>

<success_criteria>
- FFT-based IMDCT converts frequency to time domain
- Vorbis window verified as power-complementary
- Overlap-add produces seamless frame concatenation
- Mid-side and intensity stereo working correctly
- All tests passing including known-value verification
</success_criteria>

<output>
After completion, create `.planning/phases/03-celt-decoder/03-05-SUMMARY.md`
</output>
