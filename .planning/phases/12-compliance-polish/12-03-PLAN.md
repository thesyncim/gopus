---
phase: 12-compliance-polish
plan: 03
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - build_test.go
  - example_test.go
  - container/ogg/example_test.go
autonomous: true

must_haves:
  truths:
    - "Package builds successfully with CGO_ENABLED=0"
    - "Testable examples compile and run via `go test`"
    - "Examples demonstrate core encoder/decoder usage"
    - "Container examples show Ogg Opus file read/write"
  artifacts:
    - path: "build_test.go"
      provides: "CGO-free build verification test"
      contains: "CGO_ENABLED=0"
    - path: "example_test.go"
      provides: "Testable examples for godoc"
      contains: "func Example"
    - path: "container/ogg/example_test.go"
      provides: "Ogg container examples"
      contains: "func Example"
  key_links:
    - from: "example_test.go"
      to: "encoder.go"
      via: "NewEncoder usage"
      pattern: "gopus\\.NewEncoder"
    - from: "example_test.go"
      to: "decoder.go"
      via: "NewDecoder usage"
      pattern: "gopus\\.NewDecoder"
---

<objective>
Verify zero cgo dependencies and add testable documentation examples

Purpose: Ensure the final release has verified CGO-free builds and comprehensive documentation examples that appear on pkg.go.dev and are validated by `go test`.

Output: Build verification test and testable examples demonstrating encoder, decoder, streaming, and Ogg container usage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@doc.go
@encoder.go
@decoder.go
@stream.go
@container/ogg/writer.go
@container/ogg/reader.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CGO-free build verification test</name>
  <files>build_test.go</files>
  <action>
Create a test that verifies the package builds without cgo dependencies.

**build_test.go:**
```go
package gopus

import (
    "os"
    "os/exec"
    "runtime"
    "testing"
)

// TestBuildNoCGO verifies the package builds with CGO_ENABLED=0
func TestBuildNoCGO(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping build test in short mode")
    }

    // Build the package with CGO disabled
    cmd := exec.Command("go", "build", "-o", os.DevNull, ".")
    cmd.Env = append(os.Environ(), "CGO_ENABLED=0")
    cmd.Dir = "." // Current package directory

    output, err := cmd.CombinedOutput()
    if err != nil {
        t.Fatalf("Build with CGO_ENABLED=0 failed: %v\n%s", err, output)
    }

    t.Log("PASS: Zero cgo dependencies verified")
}

// TestBuildAllPackages verifies all packages build without cgo
func TestBuildAllPackages(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping build test in short mode")
    }

    packages := []string{
        ".",
        "./container/ogg",
        "./internal/rangecoding",
        "./internal/silk",
        "./internal/celt",
        "./internal/hybrid",
        "./internal/plc",
        "./internal/multistream",
        "./internal/encoder",
        "./internal/types",
    }

    for _, pkg := range packages {
        t.Run(pkg, func(t *testing.T) {
            cmd := exec.Command("go", "build", "-o", os.DevNull, pkg)
            cmd.Env = append(os.Environ(), "CGO_ENABLED=0")

            output, err := cmd.CombinedOutput()
            if err != nil {
                t.Fatalf("Build %s with CGO_ENABLED=0 failed: %v\n%s", pkg, err, output)
            }
        })
    }
}

// TestNoUnsafeImports verifies no unsafe package usage (optional strictness)
func TestNoUnsafeImports(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping import check in short mode")
    }

    // Note: We allow unsafe in range coder for performance
    // This test documents that decision
    t.Log("INFO: Package may use unsafe for performance-critical paths")
    t.Log("INFO: Core codec logic does not require unsafe")
}
```

This test:
- Verifies CGO_ENABLED=0 builds succeed
- Tests all packages for cgo-free compilation
- Documents any unsafe usage decisions
- Skips in -short mode for fast CI
  </action>
  <verify>
`go test -v -run TestBuildNoCGO` passes
`go test -v -run TestBuildAllPackages` shows all packages build
  </verify>
  <done>CGO-free build verification test added and passing</done>
</task>

<task type="auto">
  <name>Task 2: Add testable examples for core API</name>
  <files>example_test.go</files>
  <action>
Create testable examples that demonstrate core encoder/decoder usage.

**example_test.go:**
```go
package gopus_test

import (
    "bytes"
    "fmt"
    "log"
    "math"

    "gopus"
)

func ExampleNewEncoder() {
    // Create an encoder for 48kHz stereo audio
    enc, err := gopus.NewEncoder(48000, 2, gopus.ApplicationAudio)
    if err != nil {
        log.Fatal(err)
    }

    // Configure encoder settings
    enc.SetBitrate(64000) // 64 kbps
    enc.SetComplexity(10) // Maximum quality

    fmt.Printf("Encoder: %dHz, %d channels\n", enc.SampleRate(), enc.Channels())
    // Output: Encoder: 48000Hz, 2 channels
}

func ExampleNewDecoder() {
    // Create a decoder for 48kHz stereo audio
    dec, err := gopus.NewDecoder(48000, 2)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Decoder: %dHz, %d channels\n", dec.SampleRate(), dec.Channels())
    // Output: Decoder: 48000Hz, 2 channels
}

func ExampleEncoder_EncodeFloat32() {
    enc, err := gopus.NewEncoder(48000, 2, gopus.ApplicationAudio)
    if err != nil {
        log.Fatal(err)
    }

    // Generate 20ms of stereo silence (960 samples per channel)
    pcm := make([]float32, 960*2)

    // Encode the frame
    packet, err := enc.EncodeFloat32(pcm)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Encoded %d samples to %d bytes\n", len(pcm)/2, len(packet))
    // Output will vary, but packet will be small for silence
}

func ExampleDecoder_DecodeFloat32() {
    // Create encoder and decoder
    enc, _ := gopus.NewEncoder(48000, 2, gopus.ApplicationAudio)
    dec, _ := gopus.NewDecoder(48000, 2)

    // Generate and encode a test signal
    pcm := make([]float32, 960*2)
    for i := range pcm {
        pcm[i] = float32(math.Sin(float64(i) * 0.01))
    }

    packet, _ := enc.EncodeFloat32(pcm)

    // Decode the packet
    decoded, err := dec.DecodeFloat32(packet)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Decoded %d bytes to %d samples\n", len(packet), len(decoded)/2)
}

func ExampleDecoder_DecodeFloat32_packetLoss() {
    dec, _ := gopus.NewDecoder(48000, 2)

    // First, decode a real packet to initialize state
    enc, _ := gopus.NewEncoder(48000, 2, gopus.ApplicationAudio)
    pcm := make([]float32, 960*2)
    packet, _ := enc.EncodeFloat32(pcm)
    dec.DecodeFloat32(packet)

    // Simulate packet loss by passing nil
    // Decoder uses PLC to generate concealment audio
    plcOutput, err := dec.DecodeFloat32(nil)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("PLC generated %d samples\n", len(plcOutput)/2)
}

func Example_roundTrip() {
    // Complete encode-decode round trip
    enc, _ := gopus.NewEncoder(48000, 1, gopus.ApplicationVoIP)
    dec, _ := gopus.NewDecoder(48000, 1)

    // 20ms of mono audio at 48kHz
    input := make([]float32, 960)
    for i := range input {
        input[i] = float32(math.Sin(float64(i) * 0.02))
    }

    // Encode
    packet, _ := enc.EncodeFloat32(input)

    // Decode
    output, _ := dec.DecodeFloat32(packet)

    fmt.Printf("Round trip: %d samples -> %d bytes -> %d samples\n",
        len(input), len(packet), len(output))
}
```

Each example:
- Has a clear purpose
- Uses realistic parameters
- Includes error handling
- Has an // Output: comment where deterministic
- Demonstrates a specific feature
  </action>
  <verify>
`go test -v -run Example` passes
Examples appear in `go doc gopus`
  </verify>
  <done>Core API examples added and validated by go test</done>
</task>

<task type="auto">
  <name>Task 3: Add testable examples for Ogg container</name>
  <files>container/ogg/example_test.go</files>
  <action>
Create testable examples demonstrating Ogg Opus file operations.

**container/ogg/example_test.go:**
```go
package ogg_test

import (
    "bytes"
    "fmt"
    "log"
    "math"

    "gopus"
    "gopus/container/ogg"
)

func ExampleNewWriter() {
    // Create a buffer to write Ogg Opus data
    var buf bytes.Buffer

    // Create writer for 48kHz stereo
    w, err := ogg.NewWriter(&buf, 48000, 2)
    if err != nil {
        log.Fatal(err)
    }
    defer w.Close()

    fmt.Println("Ogg Opus writer created")
    // Output: Ogg Opus writer created
}

func ExampleWriter_WritePacket() {
    var buf bytes.Buffer
    w, _ := ogg.NewWriter(&buf, 48000, 2)
    defer w.Close()

    // Create an encoder
    enc, _ := gopus.NewEncoder(48000, 2, gopus.ApplicationAudio)

    // Encode and write a frame
    pcm := make([]float32, 960*2) // 20ms stereo
    packet, _ := enc.EncodeFloat32(pcm)

    // Write packet with sample count
    err := w.WritePacket(packet, 960)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Wrote %d bytes to Ogg container\n", len(packet))
}

func ExampleNewReader() {
    // First create some Ogg Opus data
    var buf bytes.Buffer
    w, _ := ogg.NewWriter(&buf, 48000, 2)

    enc, _ := gopus.NewEncoder(48000, 2, gopus.ApplicationAudio)
    pcm := make([]float32, 960*2)
    packet, _ := enc.EncodeFloat32(pcm)
    w.WritePacket(packet, 960)
    w.Close()

    // Now read it back
    r, err := ogg.NewReader(bytes.NewReader(buf.Bytes()))
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Ogg Opus: %d channels, %d Hz\n", r.Channels(), r.SampleRate())
}

func ExampleReader_ReadPacket() {
    // Create Ogg data with multiple packets
    var buf bytes.Buffer
    w, _ := ogg.NewWriter(&buf, 48000, 1)
    enc, _ := gopus.NewEncoder(48000, 1, gopus.ApplicationAudio)

    for i := 0; i < 5; i++ {
        pcm := make([]float32, 960)
        for j := range pcm {
            pcm[j] = float32(math.Sin(float64(i*960+j) * 0.01))
        }
        packet, _ := enc.EncodeFloat32(pcm)
        w.WritePacket(packet, 960)
    }
    w.Close()

    // Read packets back
    r, _ := ogg.NewReader(bytes.NewReader(buf.Bytes()))
    dec, _ := gopus.NewDecoder(48000, 1)

    totalSamples := 0
    for {
        packet, _, err := r.ReadPacket()
        if err != nil {
            break
        }
        pcm, _ := dec.DecodeFloat32(packet)
        totalSamples += len(pcm)
    }

    fmt.Printf("Decoded %d total samples\n", totalSamples)
}

func Example_writeOggFile() {
    // Demonstrate creating an Ogg Opus file
    var buf bytes.Buffer

    // Create writer
    w, _ := ogg.NewWriter(&buf, 48000, 2)

    // Create encoder
    enc, _ := gopus.NewEncoder(48000, 2, gopus.ApplicationAudio)
    enc.SetBitrate(128000)

    // Write 1 second of audio (50 frames of 20ms each)
    for i := 0; i < 50; i++ {
        pcm := make([]float32, 960*2)
        // Generate stereo sine wave
        for j := 0; j < 960; j++ {
            t := float64(i*960+j) / 48000.0
            pcm[j*2] = float32(math.Sin(2 * math.Pi * 440 * t))   // Left: 440 Hz
            pcm[j*2+1] = float32(math.Sin(2 * math.Pi * 554 * t)) // Right: 554 Hz
        }
        packet, _ := enc.EncodeFloat32(pcm)
        w.WritePacket(packet, 960)
    }

    w.Close()

    fmt.Printf("Created Ogg Opus: %d bytes, 1 second of stereo audio\n", buf.Len())
}
```

Examples demonstrate:
- Creating Ogg writer/reader
- Writing encoded packets
- Reading and decoding
- Complete file creation workflow
  </action>
  <verify>
`go test -v ./container/ogg/... -run Example` passes
Examples appear in `go doc gopus/container/ogg`
  </verify>
  <done>Ogg container examples added and validated by go test</done>
</task>

</tasks>

<verification>
- `go test -run TestBuild` verifies CGO-free builds
- `go test -run Example` runs and validates all examples
- `go doc gopus` shows encoder/decoder examples
- `go doc gopus/container/ogg` shows container examples
</verification>

<success_criteria>
- CGO_ENABLED=0 build verified passing
- Testable examples for core API
- Testable examples for Ogg container
- All examples validate without errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-compliance-polish/12-03-SUMMARY.md`
</output>
