---
phase: 12-compliance-polish
plan: 02
type: execute
wave: 2
depends_on: [12-01]
files_modified:
  - internal/testvectors/parser.go
  - internal/testvectors/parser_test.go
  - internal/testvectors/quality.go
  - internal/testvectors/quality_test.go
  - internal/testvectors/compliance_test.go
autonomous: true

must_haves:
  truths:
    - "opus_demo .bit file format is correctly parsed (length + finalRange + data)"
    - "Decoder produces output comparable to reference .dec files"
    - "Quality metric Q >= 0 indicates passing test (per RFC 8251)"
    - "Both .dec and m.dec references checked; pass if either matches"
  artifacts:
    - path: "internal/testvectors/parser.go"
      provides: "opus_demo bitstream parser"
      exports: ["ParseOpusDemoBitstream", "Packet"]
    - path: "internal/testvectors/quality.go"
      provides: "Quality metric computation"
      exports: ["ComputeQuality", "QualityPasses"]
    - path: "internal/testvectors/compliance_test.go"
      provides: "RFC 8251 decoder compliance tests"
      contains: "TestDecoderCompliance"
  key_links:
    - from: "internal/testvectors/compliance_test.go"
      to: "internal/hybrid"
      via: "decoder.Decode()"
      pattern: "hybrid\\.NewDecoder"
    - from: "internal/testvectors/parser.go"
      to: ".bit files"
      via: "binary.LittleEndian.Uint32"
      pattern: "binary\\.LittleEndian\\.Uint32"
---

<objective>
Implement RFC 8251 test vector parsing and decoder compliance tests

Purpose: Validate that gopus decoder meets official Opus compliance criteria by parsing the official test vectors, running them through the decoder, and comparing output using the perceptual quality metric.

Output: A new internal/testvectors package with .bit file parser, quality metric computation, and compliance tests that download and validate against official RFC 8251 test vectors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-compliance-polish/12-RESEARCH.md
@internal/hybrid/decoder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement opus_demo bitstream parser</name>
  <files>internal/testvectors/parser.go, internal/testvectors/parser_test.go</files>
  <action>
Create the internal/testvectors package with opus_demo .bit file parser.

**internal/testvectors/parser.go:**
```go
package testvectors

// Packet represents a decoded opus_demo packet with metadata
type Packet struct {
    Data       []byte // Raw Opus packet data
    FinalRange uint32 // Range coder final state (for verification)
}

// ParseOpusDemoBitstream reads opus_demo .bit file format
// Format per packet: uint32_le packet_len + uint32_le enc_final_range + packet_data
func ParseOpusDemoBitstream(data []byte) ([]Packet, error)

// ReadBitstreamFile reads and parses a .bit file from disk
func ReadBitstreamFile(filename string) ([]Packet, error)
```

**internal/testvectors/parser_test.go:**
- Test parsing with synthetic .bit data (known packet lengths)
- Test empty file handling
- Test truncated file handling
- Test very large packet handling (>255 bytes)

The format from research:
- uint32_le: packet_length (4 bytes)
- uint32_le: enc_final_range (4 bytes)
- byte[packet_length]: opus_packet_data
- Repeat until EOF

Handle edge cases:
- Empty file (0 packets)
- Truncated header (< 8 bytes remaining)
- Truncated packet data (header says more data than available)
  </action>
  <verify>
`go test -v ./internal/testvectors/... -run TestParse` passes
Parser correctly extracts packet count and data from synthetic test cases
  </verify>
  <done>opus_demo .bit parser implemented with edge case handling</done>
</task>

<task type="auto">
  <name>Task 2: Implement quality metric computation</name>
  <files>internal/testvectors/quality.go, internal/testvectors/quality_test.go</files>
  <action>
Implement quality metric computation for decoder compliance testing.

**internal/testvectors/quality.go:**
```go
package testvectors

// ComputeQuality computes a quality metric between decoded and reference audio
// Uses simplified SNR-based comparison (full opus_compare psychoacoustic model
// deferred to future enhancement if needed)
//
// Returns Q value where Q >= 0 passes RFC 8251 threshold
func ComputeQuality(decoded, reference []int16, sampleRate int) float64

// QualityPasses returns true if quality metric meets RFC 8251 threshold
func QualityPasses(q float64) bool {
    return q >= 0
}

// CompareSamples computes mean squared error between sample slices
func CompareSamples(a, b []int16) float64

// NormalizedSNR computes signal-to-noise ratio in dB
func NormalizedSNR(signal, noise []int16) float64
```

The simplified quality metric:
1. Compute MSE between decoded and reference
2. Compute signal power of reference
3. SNR = 10 * log10(signalPower / MSE)
4. Q = (SNR - 48) * (100/48) + 0  // Normalize so 48dB SNR = Q=0

Per research: Q >= 0 corresponds to 48 dB SNR threshold.

**internal/testvectors/quality_test.go:**
- Test identical signals (Q should be very high)
- Test with known noise level (verify SNR calculation)
- Test with silence (handle divide by zero)
- Test sample length mismatch (truncate to shorter)

Note: This is a simplified metric. The full opus_compare uses psychoacoustic masking.
If this proves insufficient for compliance, enhance in a future plan.
  </action>
  <verify>
`go test -v ./internal/testvectors/... -run TestQuality` passes
Identical signals produce Q > 90
Known noise levels produce expected Q values
  </verify>
  <done>Quality metric implemented with SNR-based calculation</done>
</task>

<task type="auto">
  <name>Task 3: Implement decoder compliance test with test vector download</name>
  <files>internal/testvectors/compliance_test.go</files>
  <action>
Create compliance tests that download and validate against RFC 8251 test vectors.

**internal/testvectors/compliance_test.go:**
```go
package testvectors

import (
    "testing"
    "gopus/internal/hybrid"
)

const testVectorURL = "https://opus-codec.org/docs/opus_testvectors-rfc8251.tar.gz"
const testVectorDir = "testdata/opus_testvectors"

// TestDecoderCompliance runs all RFC 8251 test vectors
func TestDecoderCompliance(t *testing.T) {
    // Skip if test vectors not available (will be downloaded)
    ensureTestVectors(t)

    testVectors := []string{
        "testvector01", "testvector02", "testvector03", "testvector04",
        "testvector05", "testvector06", "testvector07", "testvector08",
        "testvector09", "testvector10", "testvector11", "testvector12",
    }

    for _, tv := range testVectors {
        t.Run(tv, func(t *testing.T) {
            runTestVector(t, tv)
        })
    }
}

func runTestVector(t *testing.T, name string) {
    // 1. Parse .bit file
    // 2. Create decoder (48kHz stereo to be safe)
    // 3. Decode all packets
    // 4. Read reference .dec file (raw int16 LE PCM)
    // 5. Read alternative reference m.dec
    // 6. Compute quality against both
    // 7. Pass if either Q >= 0
}

func ensureTestVectors(t *testing.T) {
    // Check if testdata/opus_testvectors exists
    // If not, download and extract from testVectorURL
    // Use t.Skip if download fails (network unavailable)
}
```

Test vector handling:
- Download once, cache in testdata/
- Parse TOC byte from first packet to determine channels/sample rate
- Handle variable frame sizes (TOC bits 0-1 for frame count)
- Compare against both .dec and m.dec (RFC 8251 phase shift)

Reference file format:
- Raw signed 16-bit little-endian PCM
- Sample rate determined by encoder config in bitstream
- Stereo interleaved if stereo

If test vectors cannot be downloaded (CI network policy), test should skip gracefully.
  </action>
  <verify>
`go test -v ./internal/testvectors/... -run TestDecoderCompliance` runs
Test vectors downloaded (or test skips gracefully if network unavailable)
Quality metrics computed and logged for each vector
  </verify>
  <done>RFC 8251 compliance tests implemented with auto-download and quality verification</done>
</task>

</tasks>

<verification>
- internal/testvectors package builds without errors
- Parser correctly handles opus_demo .bit format
- Quality metric computation produces sensible values
- Compliance tests run and log quality metrics
- Tests skip gracefully if network unavailable
</verification>

<success_criteria>
- opus_demo .bit parser working
- Quality metric implementation complete
- Compliance test infrastructure in place
- Test vectors downloadable and parseable
- Decoder output compared against references
</success_criteria>

<output>
After completion, create `.planning/phases/12-compliance-polish/12-02-SUMMARY.md`
</output>
