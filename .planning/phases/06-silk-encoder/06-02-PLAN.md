---
phase: 06-silk-encoder
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - internal/silk/lpc_analysis.go
  - internal/silk/lsf_encode.go
  - internal/silk/lpc_analysis_test.go
autonomous: true

must_haves:
  truths:
    - "LPC analysis via Burg's method produces stable coefficients"
    - "LPC coefficients convert to valid LSF values"
    - "Converted LSF values are strictly increasing"
  artifacts:
    - path: "internal/silk/lpc_analysis.go"
      provides: "LPC coefficient estimation via Burg's method"
      exports: ["burgLPC", "applyBandwidthExpansion"]
    - path: "internal/silk/lsf_encode.go"
      provides: "LPC to LSF conversion"
      exports: ["lpcToLSFEncode"]
  key_links:
    - from: "internal/silk/lsf_encode.go"
      to: "internal/silk/lpc_analysis.go"
      via: "LPC coefficients input"
      pattern: "burgLPC"
    - from: "internal/silk/lsf_encode.go"
      to: "internal/silk/lsf.go"
      via: "lsfToLPC for verification"
      pattern: "lsfToLPC"
---

<objective>
Implement LPC analysis using Burg's method and LPC-to-LSF conversion for SILK encoding.

Purpose: SILK encoding requires computing LPC coefficients from PCM audio and converting them to Line Spectral Frequencies (LSF) for quantization. Burg's method is preferred for numerical stability. The resulting LSF values must be strictly increasing to ensure stable synthesis filters.

Output:
- LPC analysis via Burg's method
- LPC-to-LSF conversion using Chebyshev polynomial method
- Bandwidth expansion for filter stability
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-silk-encoder/06-RESEARCH.md
@.planning/phases/06-silk-encoder/06-01-SUMMARY.md

# Reference decoder's LSF handling for compatibility
@internal/silk/lsf.go
@internal/silk/lpc.go
@internal/silk/bandwidth.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Burg's LPC Analysis</name>
  <files>internal/silk/lpc_analysis.go</files>
  <action>
Create LPC analysis using Burg's method per draft-vos-silk-01 Section 2.1.2.1:

```go
package silk

import "math"

// burgLPC computes LPC coefficients using Burg's method.
// Burg's method minimizes both forward and backward prediction error,
// providing better numerical stability than autocorrelation method.
//
// Per draft-vos-silk-01 Section 2.1.2.1.
//
// signal: Input PCM samples
// order: LPC order (10 for NB/MB, 16 for WB)
// Returns: LPC coefficients in Q12 format
func burgLPC(signal []float32, order int) []int16 {
    n := len(signal)
    if n < order+1 {
        // Not enough samples, return zeros
        return make([]int16, order)
    }

    // LPC coefficients (float for computation)
    a := make([]float64, order+1)
    a[0] = 1.0

    // Forward and backward prediction errors
    ef := make([]float64, n)
    eb := make([]float64, n)
    for i := 0; i < n; i++ {
        ef[i] = float64(signal[i])
        eb[i] = float64(signal[i])
    }

    // Reflection coefficients
    for i := 1; i <= order; i++ {
        // Compute reflection coefficient using Burg's formula
        var num, den float64
        for j := i; j < n; j++ {
            num += ef[j] * eb[j-1]
            den += ef[j]*ef[j] + eb[j-1]*eb[j-1]
        }

        if den < 1e-10 {
            // Numerical issue, stop iteration
            break
        }

        // Reflection coefficient
        k := -2.0 * num / den

        // Clamp reflection coefficient for stability
        if k > 0.999 {
            k = 0.999
        }
        if k < -0.999 {
            k = -0.999
        }

        // Update LPC coefficients using Levinson-Durbin recursion
        aOld := make([]float64, i)
        copy(aOld, a[1:i])
        for j := 1; j < i; j++ {
            a[j] = aOld[j-1] + k*aOld[i-1-j]
        }
        a[i] = k

        // Update prediction errors for next iteration
        for j := n - 1; j >= i; j-- {
            temp := ef[j]
            ef[j] = temp + k*eb[j-1]
            eb[j-1] = eb[j-1] + k*temp
        }
    }

    // Convert to Q12 fixed-point
    lpcQ12 := make([]int16, order)
    for i := 0; i < order; i++ {
        val := a[i+1] * 4096.0 // Q12 scaling
        if val > 32767 {
            val = 32767
        }
        if val < -32768 {
            val = -32768
        }
        lpcQ12[i] = int16(val)
    }

    return lpcQ12
}

// applyBandwidthExpansion applies chirp factor to LPC coefficients.
// This prevents filter instability by pulling poles toward origin.
// Per decision D02-03-01: chirp factor 0.96.
//
// lpcQ12: LPC coefficients in Q12 format (modified in place)
// chirp: Expansion factor (0.96 recommended per Phase 2)
func applyBandwidthExpansion(lpcQ12 []int16, chirp float64) {
    factor := chirp
    for i := 0; i < len(lpcQ12); i++ {
        lpcQ12[i] = int16(float64(lpcQ12[i]) * factor)
        factor *= chirp
    }
}

// computeLPCFromFrame computes LPC coefficients for a frame.
// Applies windowing, Burg analysis, and bandwidth expansion.
func (e *Encoder) computeLPCFromFrame(pcm []float32) []int16 {
    // Apply window (can use simple Hamming or none for now)
    windowed := make([]float32, len(pcm))
    n := float64(len(pcm))
    for i := range pcm {
        // Hamming window
        w := 0.54 - 0.46*math.Cos(2*math.Pi*float64(i)/(n-1))
        windowed[i] = pcm[i] * float32(w)
    }

    // Compute LPC via Burg's method
    lpcQ12 := burgLPC(windowed, e.lpcOrder)

    // Apply bandwidth expansion for stability (chirp = 0.96)
    applyBandwidthExpansion(lpcQ12, 0.96)

    return lpcQ12
}
```
  </action>
  <verify>
Create test in lpc_analysis_test.go:
```bash
go test -v -run TestBurgLPC ./internal/silk/...
```
  </verify>
  <done>Burg's method produces stable LPC coefficients from PCM input</done>
</task>

<task type="auto">
  <name>Task 2: Implement LPC to LSF Conversion</name>
  <files>internal/silk/lsf_encode.go</files>
  <action>
Create LPC-to-LSF conversion using Chebyshev polynomial method:

```go
package silk

import "math"

// lpcToLSFEncode converts LPC coefficients to LSF (Line Spectral Frequencies).
// Uses the Chebyshev polynomial method per Kabal & Ramachandran 1986.
//
// lpcQ12: LPC coefficients in Q12 format
// Returns: LSF values in Q15 format [0, 32767] representing [0, pi]
func lpcToLSFEncode(lpcQ12 []int16) []int16 {
    order := len(lpcQ12)
    if order == 0 {
        return nil
    }

    // Convert Q12 to float for computation
    lpc := make([]float64, order)
    for i := 0; i < order; i++ {
        lpc[i] = float64(lpcQ12[i]) / 4096.0
    }

    // Construct symmetric polynomials P(z) and Q(z)
    // P(z) = A(z) + z^(-order-1) * A(z^-1)  (sum polynomial)
    // Q(z) = A(z) - z^(-order-1) * A(z^-1)  (difference polynomial)
    halfOrder := order / 2

    // P and Q polynomial coefficients (after factoring out 1+z^-1 and 1-z^-1)
    p := make([]float64, halfOrder+1)
    q := make([]float64, halfOrder+1)

    // Build P: a[k] + a[order-1-k]
    // Build Q: a[k] - a[order-1-k]
    p[0] = 1.0
    q[0] = 1.0
    for i := 0; i < halfOrder; i++ {
        p[i+1] = lpc[i] + lpc[order-1-i]
        q[i+1] = lpc[i] - lpc[order-1-i]
    }

    // Cumulative sum for P
    for i := 1; i <= halfOrder; i++ {
        p[i] += p[i-1]
    }
    // Cumulative difference for Q
    for i := 1; i <= halfOrder; i++ {
        q[i] -= q[i-1]
    }

    // Find roots by searching for sign changes in [0, pi]
    lsfFloat := make([]float64, order)
    lsfIdx := 0

    // Search resolution
    const numPoints = 1024
    const step = math.Pi / float64(numPoints)

    prevP := evalChebyshev(p, 1.0) // cos(0) = 1
    prevQ := evalChebyshev(q, 1.0)
    prevW := 0.0

    for i := 1; i <= numPoints && lsfIdx < order; i++ {
        w := float64(i) * step
        x := math.Cos(w)

        currP := evalChebyshev(p, x)
        currQ := evalChebyshev(q, x)

        // Check for sign change in P (even-indexed LSFs)
        if lsfIdx%2 == 0 && prevP*currP < 0 {
            // Bisection to refine root
            root := bisectRoot(p, prevW, w, evalChebyshev)
            lsfFloat[lsfIdx] = root
            lsfIdx++
        }

        // Check for sign change in Q (odd-indexed LSFs)
        if lsfIdx%2 == 1 && prevQ*currQ < 0 {
            root := bisectRoot(q, prevW, w, evalChebyshev)
            lsfFloat[lsfIdx] = root
            lsfIdx++
        }

        prevP = currP
        prevQ = currQ
        prevW = w
    }

    // If we didn't find all roots, fill with evenly spaced values
    if lsfIdx < order {
        for i := lsfIdx; i < order; i++ {
            lsfFloat[i] = math.Pi * float64(i+1) / float64(order+1)
        }
    }

    // Convert to Q15 format [0, 32767]
    lsfQ15 := make([]int16, order)
    for i := 0; i < order; i++ {
        // Map [0, pi] to [0, 32767]
        val := lsfFloat[i] * 32767.0 / math.Pi
        if val < 0 {
            val = 0
        }
        if val > 32767 {
            val = 32767
        }
        lsfQ15[i] = int16(val)
    }

    // Ensure strict ordering (bubble sort if needed)
    ensureLSFOrdering(lsfQ15)

    return lsfQ15
}

// evalChebyshev evaluates polynomial at x using Chebyshev recursion.
func evalChebyshev(coef []float64, x float64) float64 {
    if len(coef) == 0 {
        return 0
    }
    if len(coef) == 1 {
        return coef[0]
    }

    // Clenshaw's recurrence for Chebyshev evaluation
    var b0, b1 float64
    for i := len(coef) - 1; i >= 0; i-- {
        b2 := b1
        b1 = b0
        b0 = 2*x*b1 - b2 + coef[i]
    }
    return b0 - x*b1
}

// bisectRoot finds root of poly in [lo, hi] using bisection.
func bisectRoot(poly []float64, lo, hi float64, evalFunc func([]float64, float64) float64) float64 {
    const maxIter = 20
    const tol = 1e-8

    flo := evalFunc(poly, math.Cos(lo))

    for iter := 0; iter < maxIter; iter++ {
        mid := (lo + hi) / 2
        if hi-lo < tol {
            return mid
        }

        fmid := evalFunc(poly, math.Cos(mid))
        if flo*fmid < 0 {
            hi = mid
        } else {
            lo = mid
            flo = fmid
        }
    }

    return (lo + hi) / 2
}

// ensureLSFOrdering ensures LSF values are strictly increasing.
func ensureLSFOrdering(lsf []int16) {
    // Minimum spacing between adjacent LSF (about 100 Hz in Q15)
    const minSpacing = 100

    for i := 1; i < len(lsf); i++ {
        if lsf[i] <= lsf[i-1]+minSpacing {
            lsf[i] = lsf[i-1] + minSpacing
        }
    }

    // Clamp to valid range
    for i := range lsf {
        if lsf[i] > 32600 {
            lsf[i] = 32600
        }
    }
}
```
  </action>
  <verify>
Add test that verifies LPC->LSF->LPC round-trip produces similar coefficients:
```bash
go test -v -run TestLPCtoLSF ./internal/silk/...
```
  </verify>
  <done>LPC-to-LSF conversion produces strictly increasing LSF values</done>
</task>

<task type="auto">
  <name>Task 3: Create LPC Analysis Tests with Round-Trip Verification</name>
  <files>internal/silk/lpc_analysis_test.go</files>
  <action>
Create comprehensive tests for LPC analysis and LPC-LSF conversion:

```go
package silk

import (
    "math"
    "testing"
)

func TestBurgLPC(t *testing.T) {
    // Generate test signal: sum of sinusoids
    n := 320 // 20ms at 16kHz
    signal := make([]float32, n)
    for i := 0; i < n; i++ {
        t := float64(i) / 16000.0
        signal[i] = float32(
            math.Sin(2*math.Pi*200*t) +
            0.5*math.Sin(2*math.Pi*400*t) +
            0.3*math.Sin(2*math.Pi*600*t),
        ) * 10000
    }

    // Compute LPC
    lpcQ12 := burgLPC(signal, 10)

    // Verify we got coefficients
    if len(lpcQ12) != 10 {
        t.Fatalf("expected 10 LPC coefficients, got %d", len(lpcQ12))
    }

    // Verify coefficients are within reasonable range (< 1.0 in magnitude, < 4096 in Q12)
    for i, c := range lpcQ12 {
        if c > 4096 || c < -4096 {
            t.Errorf("LPC[%d] = %d out of reasonable range", i, c)
        }
    }

    // Verify prediction error decreases with higher order
    // (should be able to predict periodic signals well)
    lpc16 := burgLPC(signal, 16)
    if len(lpc16) != 16 {
        t.Fatalf("expected 16 LPC coefficients, got %d", len(lpc16))
    }
}

func TestBandwidthExpansion(t *testing.T) {
    lpc := []int16{2048, 1024, 512, 256, 128}
    original := make([]int16, len(lpc))
    copy(original, lpc)

    applyBandwidthExpansion(lpc, 0.96)

    // Each coefficient should be reduced by increasing powers of chirp
    chirp := 0.96
    for i := 0; i < len(lpc); i++ {
        expected := int16(float64(original[i]) * chirp)
        // Allow small rounding differences
        if abs(int(lpc[i]-expected)) > 1 {
            t.Errorf("LPC[%d]: expected %d, got %d", i, expected, lpc[i])
        }
        chirp *= 0.96
    }
}

func TestLPCToLSFEncode(t *testing.T) {
    // Use known stable LPC coefficients (from actual speech)
    // These represent a typical vowel sound
    lpcQ12 := []int16{
        3276, -2048, 1638, -1229, 819, -614, 410, -307, 205, -102,
    }

    lsfQ15 := lpcToLSFEncode(lpcQ12)

    if len(lsfQ15) != len(lpcQ12) {
        t.Fatalf("expected %d LSF values, got %d", len(lpcQ12), len(lsfQ15))
    }

    // Verify LSF are strictly increasing
    for i := 1; i < len(lsfQ15); i++ {
        if lsfQ15[i] <= lsfQ15[i-1] {
            t.Errorf("LSF not increasing: lsf[%d]=%d <= lsf[%d]=%d",
                i, lsfQ15[i], i-1, lsfQ15[i-1])
        }
    }

    // Verify LSF are in valid range [0, 32767]
    for i, lsf := range lsfQ15 {
        if lsf < 0 || lsf > 32767 {
            t.Errorf("LSF[%d]=%d out of range [0, 32767]", i, lsf)
        }
    }
}

func TestLPCLSFRoundTrip(t *testing.T) {
    // Test that LPC -> LSF -> LPC approximately recovers original
    lpcOriginal := []int16{
        2048, -1536, 1024, -768, 512, -384, 256, -192, 128, -64,
    }

    // Convert to LSF
    lsfQ15 := lpcToLSFEncode(lpcOriginal)

    // Convert back to LPC using decoder's function
    lpcRecovered := lsfToLPC(lsfQ15)

    // Verify approximate recovery (allow 10% error due to quantization)
    for i := 0; i < len(lpcOriginal); i++ {
        diff := abs(int(lpcOriginal[i]) - int(lpcRecovered[i]))
        maxErr := abs(int(lpcOriginal[i])) / 10 // 10% of original
        if maxErr < 50 {
            maxErr = 50 // Minimum error tolerance
        }
        if diff > maxErr {
            t.Errorf("LPC[%d]: original=%d, recovered=%d, diff=%d > maxErr=%d",
                i, lpcOriginal[i], lpcRecovered[i], diff, maxErr)
        }
    }
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```
  </action>
  <verify>
```bash
go test -v ./internal/silk/... -run "TestBurg|TestLPC|TestBandwidth"
```
  </verify>
  <done>All LPC analysis tests pass, including round-trip verification</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
go test -v ./internal/silk/...

# Check for any race conditions
go test -race ./internal/silk/...
```
</verification>

<success_criteria>
1. burgLPC produces stable LPC coefficients from PCM input
2. applyBandwidthExpansion reduces coefficient magnitudes correctly
3. lpcToLSFEncode produces strictly increasing LSF values
4. LPC -> LSF -> LPC round-trip approximately recovers original coefficients
5. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-silk-encoder/06-02-SUMMARY.md`
</output>
