---
phase: 06-silk-encoder
plan: 07
type: execute
wave: 2
depends_on: ["06-06"]
files_modified:
  - internal/silk/stereo_encode.go
  - internal/silk/roundtrip_test.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Stereo encoder output decodes without panic"
    - "Mid and side channels reconstruct correctly"
    - "Stereo weights are preserved through encode-decode"
  artifacts:
    - path: "internal/silk/roundtrip_test.go"
      provides: "Stereo round-trip tests"
      exports: ["TestStereoRoundTrip"]
  key_links:
    - from: "stereo_encode.go:EncodeStereo"
      to: "decoder.DecodeStereoFrame"
      via: "Compatible packet format"
      pattern: "DecodeStereoFrame.*BandwidthWideband"
---

<objective>
Add stereo encoder-decoder round-trip tests after mono compatibility is fixed.

Purpose: Verify stereo encoding produces output decodable by Phase 2 decoder. This depends on mono round-trip working first (Plan 06-06).

Output: Working stereo round-trip with mid-side reconstruction.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-silk-encoder/06-06-SUMMARY.md
@internal/silk/stereo_encode.go
@internal/silk/decode.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify stereo packet format compatibility</name>
  <files>internal/silk/stereo_encode.go, internal/silk/silk_encode.go</files>
  <action>
Review the stereo encoding packet format in silk_encode.go (EncodeStereo function) and verify it matches what the decoder expects.

Current encoder format appears to be:
```
[weights:4][mid_len:2][mid_bytes][side_len:2][side_bytes]
```

The decoder (DecodeStereoFrame in decode.go) expects:
1. Stereo weights decoded via decodeStereoWeights()
2. Mid channel frame
3. Side channel frame

Verify the encoder writes stereo weights in the format the decoder expects (Q13 format via ICDF).

If the formats differ:
- Document the mismatch
- Fix encoder to produce decoder-compatible format
- OR note that stereo may need custom handling

Key check: Does encoder use range-coded ICDF for weights (like decoder expects) or raw bytes?
  </action>
  <verify>Read stereo_encode.go and decode.go to document format</verify>
  <done>Stereo packet format documented and any mismatches identified</done>
</task>

<task type="auto">
  <name>Task 2: Add stereo round-trip tests</name>
  <files>internal/silk/roundtrip_test.go</files>
  <action>
Add stereo round-trip tests to the existing roundtrip_test.go file:

```go
func TestStereoRoundTrip_Basic(t *testing.T) {
    config := GetBandwidthConfig(BandwidthWideband)
    frameSamples := config.SampleRate * 20 / 1000

    // Generate stereo signal (different frequencies)
    left := make([]float32, frameSamples)
    right := make([]float32, frameSamples)
    for i := range left {
        tm := float64(i) / float64(config.SampleRate)
        left[i] = float32(math.Sin(2*math.Pi*300*tm)) * 10000
        right[i] = float32(math.Sin(2*math.Pi*350*tm)) * 10000
    }

    // Encode stereo
    encoded, err := EncodeStereo(left, right, BandwidthWideband, true)
    if err != nil {
        t.Fatalf("EncodeStereo failed: %v", err)
    }

    // Decode stereo
    decoder := NewDecoder()
    rd := rangecoding.NewDecoder(encoded)
    decLeft, decRight, err := decoder.DecodeStereoFrame(rd, BandwidthWideband, Frame20ms, true)
    if err != nil {
        t.Fatalf("DecodeStereoFrame failed: %v", err)
    }

    // Verify lengths
    if len(decLeft) != frameSamples {
        t.Errorf("Left channel length %d != expected %d", len(decLeft), frameSamples)
    }
    if len(decRight) != frameSamples {
        t.Errorf("Right channel length %d != expected %d", len(decRight), frameSamples)
    }

    t.Logf("Stereo round-trip: L=%d R=%d samples -> %d bytes -> L=%d R=%d samples",
        len(left), len(right), len(encoded), len(decLeft), len(decRight))
}

func TestStereoRoundTrip_CorrelatedChannels(t *testing.T) {
    // Test with correlated channels (same signal, phase shifted)
    // This should have good mid-side compression
    config := GetBandwidthConfig(BandwidthWideband)
    frameSamples := config.SampleRate * 20 / 1000

    left := make([]float32, frameSamples)
    right := make([]float32, frameSamples)
    for i := range left {
        tm := float64(i) / float64(config.SampleRate)
        left[i] = float32(math.Sin(2*math.Pi*300*tm)) * 10000
        right[i] = float32(math.Sin(2*math.Pi*300*tm+0.5)) * 10000 // Phase shifted
    }

    encoded, err := EncodeStereo(left, right, BandwidthWideband, true)
    if err != nil {
        t.Fatalf("EncodeStereo failed: %v", err)
    }

    decoder := NewDecoder()
    rd := rangecoding.NewDecoder(encoded)
    decLeft, decRight, err := decoder.DecodeStereoFrame(rd, BandwidthWideband, Frame20ms, true)
    if err != nil {
        t.Fatalf("DecodeStereoFrame failed: %v", err)
    }

    if len(decLeft) != frameSamples || len(decRight) != frameSamples {
        t.Errorf("Length mismatch")
    }
}
```

Note: If stereo decoding fails due to format mismatch, document the failure and what needs to be fixed. The mono round-trip must work first.
  </action>
  <verify>Run `go test -v ./internal/silk/... -run TestStereoRoundTrip` - should pass or document known incompatibility</verify>
  <done>Stereo round-trip tests added, either passing or with documented incompatibility for follow-up</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Stereo packet format compatibility documented
2. `go test -v ./internal/silk/... -run TestStereoRoundTrip` - either passes or has documented failure reason
3. If stereo fails, the specific mismatch is identified for future fix
</verification>

<success_criteria>
- [ ] Stereo packet format reviewed and compared to decoder expectations
- [ ] TestStereoRoundTrip_Basic exists and either passes or has documented failure
- [ ] If stereo fails, the root cause is documented (format mismatch, weight encoding, etc.)
- [ ] No panics during stereo decode attempt
</success_criteria>

<output>
After completion, create `.planning/phases/06-silk-encoder/06-07-SUMMARY.md`
</output>
