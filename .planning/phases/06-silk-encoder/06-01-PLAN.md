---
phase: 06-silk-encoder
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/rangecoding/encoder.go
  - internal/rangecoding/encoder_test.go
  - internal/silk/encoder.go
  - internal/silk/vad.go
  - internal/silk/encoder_test.go
autonomous: true

must_haves:
  truths:
    - "Range encoder supports uint16 ICDF tables (EncodeICDF16)"
    - "SILK encoder struct mirrors decoder state for synchronization"
    - "VAD classifies frames as inactive, unvoiced, or voiced"
  artifacts:
    - path: "internal/rangecoding/encoder.go"
      provides: "EncodeICDF16 method for uint16 ICDF tables"
      contains: "func (e *Encoder) EncodeICDF16"
    - path: "internal/rangecoding/encoder_test.go"
      provides: "Tests for EncodeICDF16 round-trip verification"
      contains: "TestEncodeICDF16"
    - path: "internal/silk/encoder.go"
      provides: "Encoder struct with state matching decoder"
      exports: ["Encoder", "NewEncoder"]
    - path: "internal/silk/vad.go"
      provides: "Voice activity detection for frame classification"
      exports: ["classifyFrame"]
  key_links:
    - from: "internal/silk/encoder.go"
      to: "internal/rangecoding/encoder.go"
      via: "rangeEncoder field"
      pattern: "rangeEncoder.*rangecoding\\.Encoder"
---

<objective>
Establish SILK encoder foundation with range encoder extension and voice activity detection.

Purpose: The SILK encoder needs EncodeICDF16 for uint16 ICDF tables (256 overflows uint8), a stateful Encoder struct that mirrors the decoder for synchronized prediction, and VAD to classify frames correctly.

Output:
- Range encoder with EncodeICDF16 method
- SILK Encoder struct with proper state initialization
- VAD classifying frames as inactive/unvoiced/voiced
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-silk-encoder/06-RESEARCH.md

# Decoder patterns to mirror
@internal/silk/decoder.go
@internal/silk/decode_params.go
@internal/rangecoding/encoder.go
@internal/silk/tables.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add EncodeICDF16 to Range Encoder</name>
  <files>internal/rangecoding/encoder.go, internal/rangecoding/encoder_test.go</files>
  <action>
Add EncodeICDF16 method to the range encoder for uint16 ICDF tables:

```go
// EncodeICDF16 encodes a symbol using uint16 ICDF table.
// Required because SILK tables use uint16 (256 doesn't fit in uint8).
// Per RFC 6716 Section 4.1.
func (e *Encoder) EncodeICDF16(s int, icdf []uint16, ftb uint) {
    ft := uint32(1) << ftb
    var fl, fh uint32
    if s > 0 {
        fl = ft - uint32(icdf[s-1])
    }
    fh = ft - uint32(icdf[s])
    e.Encode(fl, fh, ft)
}
```

This mirrors DecodeICDF16 in the decoder exactly.

Add test in encoder_test.go that round-trips a symbol using EncodeICDF16/DecodeICDF16:

```go
func TestEncodeICDF16RoundTrip(t *testing.T) {
    // Test with a SILK-style ICDF table
    icdf := []uint16{256, 192, 128, 64, 0} // 4 symbols

    for sym := 0; sym < 4; sym++ {
        buf := make([]byte, 256)
        enc := &Encoder{}
        enc.Init(buf)

        enc.EncodeICDF16(sym, icdf, 8)
        encoded := enc.Done()

        // Decode and verify
        dec := &Decoder{}
        dec.Init(encoded)
        decoded := dec.DecodeICDF16(icdf, 8)

        if decoded != sym {
            t.Errorf("symbol %d: decoded %d", sym, decoded)
        }
    }
}
```
  </action>
  <verify>
```bash
go test -v -run TestEncodeICDF16 ./internal/rangecoding/...
```
  </verify>
  <done>EncodeICDF16 method exists and round-trips correctly with DecodeICDF16</done>
</task>

<task type="auto">
  <name>Task 2: Create SILK Encoder Struct</name>
  <files>internal/silk/encoder.go</files>
  <action>
Create the SILK Encoder struct that mirrors decoder state for synchronized prediction:

```go
package silk

import "gopus/internal/rangecoding"

// Encoder encodes PCM audio to SILK frames.
// It maintains state across frames that mirrors the decoder for proper
// synchronized prediction of gains, LSF, and stereo weights.
//
// Reference: RFC 6716 Section 5.2, draft-vos-silk-01
type Encoder struct {
    // Range encoder reference (set per frame)
    rangeEncoder *rangecoding.Encoder

    // Frame state (persists across frames, mirrors decoder)
    haveEncoded           bool  // True after first frame encoded
    previousLogGain       int32 // Last subframe gain (for delta coding)
    isPreviousFrameVoiced bool  // Was previous frame voiced

    // LPC state
    lpcOrder      int
    prevLSFQ15    []int16   // Previous frame LSF (Q15) for interpolation

    // Stereo state
    prevStereoWeights [2]int16 // Previous w0, w1 stereo weights (Q13)

    // Analysis buffers (encoder-specific)
    inputBuffer   []float32 // Buffered input samples
    lpcState      []float32 // LPC filter state for residual computation

    // Bandwidth configuration
    bandwidth     Bandwidth
    sampleRate    int
}

// NewEncoder creates a new SILK encoder with proper initial state.
func NewEncoder(bandwidth Bandwidth) *Encoder {
    config := GetBandwidthConfig(bandwidth)
    return &Encoder{
        prevLSFQ15:    make([]int16, config.LPCOrder),
        inputBuffer:   make([]float32, config.FrameSamples*2), // Look-ahead
        lpcState:      make([]float32, config.LPCOrder),
        bandwidth:     bandwidth,
        sampleRate:    config.SampleRate,
        lpcOrder:      config.LPCOrder,
    }
}

// Reset clears encoder state for a new stream.
func (e *Encoder) Reset() {
    e.haveEncoded = false
    e.previousLogGain = 0
    e.isPreviousFrameVoiced = false

    for i := range e.prevLSFQ15 {
        e.prevLSFQ15[i] = 0
    }
    for i := range e.lpcState {
        e.lpcState[i] = 0
    }
    for i := range e.inputBuffer {
        e.inputBuffer[i] = 0
    }
    e.prevStereoWeights = [2]int16{0, 0}
}

// SetRangeEncoder sets the range encoder for the current frame.
func (e *Encoder) SetRangeEncoder(re *rangecoding.Encoder) {
    e.rangeEncoder = re
}

// HaveEncoded returns whether at least one frame has been encoded.
func (e *Encoder) HaveEncoded() bool {
    return e.haveEncoded
}

// MarkEncoded marks that a frame has been successfully encoded.
func (e *Encoder) MarkEncoded() {
    e.haveEncoded = true
}

// Bandwidth returns the current bandwidth setting.
func (e *Encoder) Bandwidth() Bandwidth {
    return e.bandwidth
}

// LPCOrder returns the LPC order for current bandwidth.
func (e *Encoder) LPCOrder() int {
    return e.lpcOrder
}
```

State fields mirror decoder.go exactly for synchronized prediction.
  </action>
  <verify>
```bash
go build ./internal/silk/...
```
  </verify>
  <done>Encoder struct exists with state matching decoder, NewEncoder and Reset work</done>
</task>

<task type="auto">
  <name>Task 3: Implement Voice Activity Detection</name>
  <files>internal/silk/vad.go, internal/silk/encoder_test.go</files>
  <action>
Create VAD that classifies frames as inactive (0), unvoiced (1), or voiced (2):

```go
package silk

import "math"

// classifyFrame determines the signal type for a PCM frame.
// Returns signalType (0=inactive, 1=unvoiced, 2=voiced) and quantOffset (0=low, 1=high).
// Per RFC 6716 Section 4.2.7.3, draft-vos-silk-01 Section 2.1.2.2.
func (e *Encoder) classifyFrame(pcm []float32) (signalType, quantOffset int) {
    // Compute frame energy
    var energy float64
    for _, s := range pcm {
        energy += float64(s) * float64(s)
    }
    energy /= float64(len(pcm))
    rmsEnergy := math.Sqrt(energy)

    // Inactive threshold: very low energy
    const inactiveThreshold = 100.0 // Empirical, tune as needed
    if rmsEnergy < inactiveThreshold {
        return 0, 0 // Inactive
    }

    // Compute normalized autocorrelation at lag 1 (short-term correlation)
    var corr, norm float64
    for i := 1; i < len(pcm); i++ {
        corr += float64(pcm[i]) * float64(pcm[i-1])
        norm += float64(pcm[i-1]) * float64(pcm[i-1])
    }

    shortTermCorr := 0.0
    if norm > 0 {
        shortTermCorr = corr / norm
    }

    // Compute long-term periodicity (pitch-like correlation)
    // Search for peaks in autocorrelation at pitch lags
    config := GetBandwidthConfig(e.bandwidth)
    periodicity := e.computePeriodicity(pcm, config.PitchLagMin, config.PitchLagMax)

    // Classification logic per draft-vos-silk-01
    const voicedThreshold = 0.5    // Normalized periodicity threshold
    const highQuantThreshold = 0.7 // For quantization offset

    if periodicity > voicedThreshold {
        signalType = 2 // Voiced
    } else {
        signalType = 1 // Unvoiced
    }

    // Quantization offset based on energy and periodicity
    if periodicity > highQuantThreshold || shortTermCorr > 0.85 {
        quantOffset = 1 // High
    } else {
        quantOffset = 0 // Low
    }

    return signalType, quantOffset
}

// computePeriodicity computes normalized autocorrelation in pitch range.
// Returns max normalized correlation (0 to 1, higher = more periodic/voiced).
func (e *Encoder) computePeriodicity(pcm []float32, minLag, maxLag int) float64 {
    n := len(pcm)
    if maxLag >= n {
        maxLag = n - 1
    }
    if minLag < 1 {
        minLag = 1
    }

    var maxCorr float64 = 0

    for lag := minLag; lag <= maxLag; lag++ {
        var corr, energy1, energy2 float64
        for i := lag; i < n; i++ {
            corr += float64(pcm[i]) * float64(pcm[i-lag])
            energy1 += float64(pcm[i]) * float64(pcm[i])
            energy2 += float64(pcm[i-lag]) * float64(pcm[i-lag])
        }

        if energy1 > 0 && energy2 > 0 {
            normCorr := corr / math.Sqrt(energy1*energy2)
            if normCorr > maxCorr {
                maxCorr = normCorr
            }
        }
    }

    return maxCorr
}
```

Add test in encoder_test.go:

```go
package silk

import (
    "math"
    "testing"
)

func TestClassifyFrame(t *testing.T) {
    enc := NewEncoder(BandwidthWideband)

    // Test inactive (silence)
    silence := make([]float32, 320)
    sigType, _ := enc.classifyFrame(silence)
    if sigType != 0 {
        t.Errorf("silence should be inactive, got signalType=%d", sigType)
    }

    // Test unvoiced (noise-like)
    noise := make([]float32, 320)
    for i := range noise {
        noise[i] = float32(math.Sin(float64(i)*0.1) + math.Sin(float64(i)*0.37) + math.Sin(float64(i)*0.73))
        noise[i] *= 1000
    }
    sigType, _ = enc.classifyFrame(noise)
    if sigType == 0 {
        t.Errorf("noise should be active, got signalType=0")
    }

    // Test voiced (sinusoid = periodic)
    voiced := make([]float32, 320)
    freq := 200.0 // 200 Hz fundamental
    for i := range voiced {
        voiced[i] = float32(math.Sin(2*math.Pi*freq*float64(i)/16000.0)) * 10000
    }
    sigType, _ = enc.classifyFrame(voiced)
    if sigType != 2 {
        t.Errorf("periodic signal should be voiced, got signalType=%d", sigType)
    }
}
```
  </action>
  <verify>
```bash
go test -v -run TestClassifyFrame ./internal/silk/...
```
  </verify>
  <done>VAD correctly classifies silence as inactive, noise as unvoiced, periodic signals as voiced</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
go test -v ./internal/rangecoding/...
go test -v ./internal/silk/...

# Package builds
go build ./internal/rangecoding/...
go build ./internal/silk/...
```
</verification>

<success_criteria>
1. EncodeICDF16 method exists in range encoder
2. EncodeICDF16/DecodeICDF16 round-trip produces identical symbols
3. SILK Encoder struct has state fields matching decoder
4. NewEncoder initializes encoder with correct buffer sizes
5. VAD classifies frames correctly (inactive/unvoiced/voiced)
6. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-silk-encoder/06-01-SUMMARY.md`
</output>
