---
phase: 06-silk-encoder
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - internal/silk/pitch_detect.go
  - internal/silk/ltp_encode.go
  - internal/silk/pitch_detect_test.go
autonomous: true

must_haves:
  truths:
    - "Pitch detection finds fundamental frequency in voiced speech"
    - "Three-stage coarse-to-fine search prevents octave errors"
    - "LTP analysis produces valid 5-tap coefficient sets"
  artifacts:
    - path: "internal/silk/pitch_detect.go"
      provides: "Three-stage pitch detection algorithm"
      exports: ["detectPitch", "autocorrPitchSearch"]
    - path: "internal/silk/ltp_encode.go"
      provides: "LTP coefficient analysis and encoding"
      exports: ["analyzeLTP", "quantizeLTPCoeffs"]
  key_links:
    - from: "internal/silk/ltp_encode.go"
      to: "internal/silk/pitch_detect.go"
      via: "pitch lags input"
      pattern: "detectPitch"
    - from: "internal/silk/ltp_encode.go"
      to: "internal/silk/codebook.go"
      via: "LTP codebook matching"
      pattern: "LTPCodebook"
    - from: "internal/silk/pitch_detect.go"
      to: "internal/silk/tables.go"
      via: "ICDF tables for pitch encoding"
      pattern: "ICDFPitchLag|ICDFPitchContour"
---

<objective>
Implement pitch detection and LTP (Long-Term Prediction) analysis for SILK encoding.

Purpose: Voiced speech requires accurate pitch detection to enable LTP synthesis. The three-stage coarse-to-fine approach prevents octave errors. LTP coefficients are quantized using codebook matching to produce valid bitstream data.

Output:
- Three-stage pitch detection (4kHz, 8kHz, full rate)
- LTP coefficient analysis from pitch residual
- LTP codebook quantization
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-silk-encoder/06-RESEARCH.md
@.planning/phases/06-silk-encoder/06-01-SUMMARY.md

# Reference decoder's pitch handling for compatibility
@internal/silk/pitch.go
@internal/silk/ltp.go
@internal/silk/codebook.go
@internal/silk/bandwidth.go

# IMPORTANT: All ICDF tables already exist from Phase 2 decoder (decision D02-01-02)
# Reuse these tables - do NOT create new ones:
# - ICDFPitchLagNB, ICDFPitchLagMB, ICDFPitchLagWB (pitch lag MSB per bandwidth)
# - ICDFPitchLowBitsQ2/Q3/Q4 (pitch lag LSB)
# - ICDFPitchContourNB, ICDFPitchContourMB, ICDFPitchContourWB (contour ICDF)
# - PitchContourNB10ms/20ms, PitchContourMB10ms/20ms, PitchContourWB10ms/20ms (delta tables in codebook.go)
# - ICDFLTPFilterIndex*, ICDFLTPGain* (LTP periodicity/gain tables)
@internal/silk/tables.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Three-Stage Pitch Detection</name>
  <files>internal/silk/pitch_detect.go</files>
  <action>
Create three-stage pitch detection per draft-vos-silk-01 Section 2.1.2.5.

IMPORTANT: Use existing ICDF tables from tables.go:
- ICDFPitchLagNB/MB/WB for pitch lag MSB encoding (bandwidth-specific)
- ICDFPitchLowBitsQ2/Q3/Q4 for pitch lag LSB encoding
- ICDFPitchContourNB/MB/WB for contour index encoding

Use existing PitchContour tables from codebook.go:
- PitchContourNB10ms/20ms, PitchContourMB10ms/20ms, PitchContourWB10ms/20ms

```go
package silk

import "math"

// detectPitch performs three-stage coarse-to-fine pitch detection.
// Returns pitch lags for each subframe (voiced frames only).
//
// Per draft-vos-silk-01 Section 2.1.2.5:
// Stage 1: Coarse search at 4kHz (1/4 rate)
// Stage 2: Refined search at 8kHz (1/2 rate)
// Stage 3: Fine search at full rate per subframe
func (e *Encoder) detectPitch(pcm []float32, numSubframes int) []int {
    config := GetBandwidthConfig(e.bandwidth)
    subframeSamples := len(pcm) / numSubframes

    // Stage 1: Coarse search at 4kHz (downsample by 4 for WB, 2 for NB/MB)
    dsRatio := config.SampleRate / 4000
    if dsRatio < 1 {
        dsRatio = 1
    }
    ds4k := downsample(pcm, dsRatio)

    coarseLagMin := config.PitchLagMin / dsRatio
    coarseLagMax := config.PitchLagMax / dsRatio
    coarseLag := autocorrPitchSearch(ds4k, coarseLagMin, coarseLagMax)

    // Stage 2: Refined search at 8kHz
    dsRatio2 := config.SampleRate / 8000
    if dsRatio2 < 1 {
        dsRatio2 = 1
    }
    ds8k := downsample(pcm, dsRatio2)

    // Search around coarse lag (+/- 4 samples at 8kHz)
    midLagMin := max(config.PitchLagMin/dsRatio2, (coarseLag*dsRatio/dsRatio2)-4)
    midLagMax := min(config.PitchLagMax/dsRatio2, (coarseLag*dsRatio/dsRatio2)+4)
    midLag := autocorrPitchSearch(ds8k, midLagMin, midLagMax)

    // Stage 3: Fine search at full rate per subframe
    pitchLags := make([]int, numSubframes)
    for sf := 0; sf < numSubframes; sf++ {
        start := sf * subframeSamples
        end := start + subframeSamples
        subframe := pcm[start:end]

        // Search around mid lag (+/- 2 samples at full rate)
        fineLagMin := max(config.PitchLagMin, (midLag*dsRatio2)-2)
        fineLagMax := min(config.PitchLagMax, (midLag*dsRatio2)+2)

        pitchLags[sf] = autocorrPitchSearchSubframe(subframe, pcm, start, fineLagMin, fineLagMax)
    }

    return pitchLags
}

// autocorrPitchSearch finds best pitch lag using normalized autocorrelation.
// Uses bias toward shorter lags to avoid octave errors.
func autocorrPitchSearch(signal []float32, minLag, maxLag int) int {
    n := len(signal)
    if maxLag >= n {
        maxLag = n - 1
    }
    if minLag < 1 {
        minLag = 1
    }
    if minLag > maxLag {
        return minLag
    }

    bestLag := minLag
    var bestCorr float64 = -1

    for lag := minLag; lag <= maxLag; lag++ {
        var corr, energy1, energy2 float64
        for i := lag; i < n; i++ {
            corr += float64(signal[i]) * float64(signal[i-lag])
            energy1 += float64(signal[i]) * float64(signal[i])
            energy2 += float64(signal[i-lag]) * float64(signal[i-lag])
        }

        if energy1 < 1e-10 || energy2 < 1e-10 {
            continue
        }

        // Normalized correlation
        normCorr := corr / math.Sqrt(energy1*energy2)

        // Bias toward shorter lags to avoid octave errors
        // Per draft-vos-silk-01 Section 2.1.2.5
        normCorr *= 1.0 - 0.001*float64(lag-minLag)

        if normCorr > bestCorr {
            bestCorr = normCorr
            bestLag = lag
        }
    }

    return bestLag
}

// autocorrPitchSearchSubframe searches for pitch in a subframe.
// Uses preceding samples for lookback.
func autocorrPitchSearchSubframe(subframe, fullSignal []float32, subframeStart, minLag, maxLag int) int {
    n := len(subframe)
    if maxLag >= subframeStart {
        maxLag = subframeStart - 1
    }
    if minLag > maxLag {
        return minLag
    }

    bestLag := minLag
    var bestCorr float64 = -1

    for lag := minLag; lag <= maxLag; lag++ {
        var corr, energy1, energy2 float64
        for i := 0; i < n && subframeStart-lag+i >= 0; i++ {
            s := float64(subframe[i])
            past := float64(fullSignal[subframeStart-lag+i])
            corr += s * past
            energy1 += s * s
            energy2 += past * past
        }

        if energy1 < 1e-10 || energy2 < 1e-10 {
            continue
        }

        normCorr := corr / math.Sqrt(energy1*energy2)
        normCorr *= 1.0 - 0.001*float64(lag-minLag)

        if normCorr > bestCorr {
            bestCorr = normCorr
            bestLag = lag
        }
    }

    return bestLag
}

// downsample reduces sample rate by averaging factor samples.
func downsample(signal []float32, factor int) []float32 {
    if factor <= 1 {
        return signal
    }

    n := len(signal) / factor
    ds := make([]float32, n)

    for i := 0; i < n; i++ {
        var sum float32
        for j := 0; j < factor; j++ {
            sum += signal[i*factor+j]
        }
        ds[i] = sum / float32(factor)
    }

    return ds
}

// encodePitchLags encodes pitch lags to the bitstream.
// First subframe is absolute, subsequent are delta-coded via contour.
// Per RFC 6716 Section 4.2.7.6.
// Uses existing ICDF tables: ICDFPitchLagNB/MB/WB, ICDFPitchLowBitsQ*, ICDFPitchContourNB/MB/WB
func (e *Encoder) encodePitchLags(pitchLags []int, numSubframes int) {
    config := GetBandwidthConfig(e.bandwidth)

    // Select pitch contour table based on bandwidth and frame size
    var pitchContour [][4]int8
    var contourICDF []uint16

    switch e.bandwidth {
    case BandwidthNarrowband:
        if numSubframes == 4 {
            pitchContour = PitchContourNB20ms[:]
        } else {
            // Convert [16][2]int8 to [][4]int8 for 10ms frames
            pitchContour = make([][4]int8, len(PitchContourNB10ms))
            for i := range PitchContourNB10ms {
                pitchContour[i] = [4]int8{PitchContourNB10ms[i][0], PitchContourNB10ms[i][1], 0, 0}
            }
        }
        contourICDF = ICDFPitchContourNB
    case BandwidthMediumband:
        if numSubframes == 4 {
            pitchContour = PitchContourMB20ms[:]
        } else {
            pitchContour = make([][4]int8, len(PitchContourMB10ms))
            for i := range PitchContourMB10ms {
                pitchContour[i] = [4]int8{PitchContourMB10ms[i][0], PitchContourMB10ms[i][1], 0, 0}
            }
        }
        contourICDF = ICDFPitchContourMB
    default: // Wideband
        if numSubframes == 4 {
            pitchContour = PitchContourWB20ms[:]
        } else {
            pitchContour = make([][4]int8, len(PitchContourWB10ms))
            for i := range PitchContourWB10ms {
                pitchContour[i] = [4]int8{PitchContourWB10ms[i][0], PitchContourWB10ms[i][1], 0, 0}
            }
        }
        contourICDF = ICDFPitchContourWB
    }

    // Find best matching contour and base lag
    contourIdx, baseLag := e.findBestPitchContour(pitchLags, pitchContour, numSubframes)

    // Encode absolute lag for first subframe
    lagIdx := baseLag - config.PitchLagMin
    if lagIdx < 0 {
        lagIdx = 0
    }
    if lagIdx > config.PitchLagMax-config.PitchLagMin {
        lagIdx = config.PitchLagMax - config.PitchLagMin
    }

    // Encode lag high bits (MSB) - use bandwidth-specific ICDF
    var lagHighICDF []uint16
    var lagLowICDF []uint16
    var divisor int

    switch e.bandwidth {
    case BandwidthNarrowband:
        lagHighICDF = ICDFPitchLagNB
        lagLowICDF = ICDFPitchLowBitsQ2
        divisor = 4
    case BandwidthMediumband:
        lagHighICDF = ICDFPitchLagMB
        lagLowICDF = ICDFPitchLowBitsQ3
        divisor = 8
    default: // Wideband
        lagHighICDF = ICDFPitchLagWB
        lagLowICDF = ICDFPitchLowBitsQ4
        divisor = 16
    }

    lagHigh := lagIdx / divisor
    lagLow := lagIdx % divisor

    e.rangeEncoder.EncodeICDF16(lagHigh, lagHighICDF, 8)
    e.rangeEncoder.EncodeICDF16(lagLow, lagLowICDF, 8)

    // Encode contour index for delta pattern
    e.rangeEncoder.EncodeICDF16(contourIdx, contourICDF, 8)
}

// findBestPitchContour finds the contour that best matches pitch lag pattern.
// Returns contour index and base lag.
func (e *Encoder) findBestPitchContour(pitchLags []int, contours [][4]int8, numSubframes int) (int, int) {
    // Find mean lag
    var sumLag int
    for _, lag := range pitchLags {
        sumLag += lag
    }
    baseLag := sumLag / numSubframes

    // Find best matching contour
    bestContour := 0
    bestDist := math.MaxInt32

    for cIdx := 0; cIdx < len(contours); cIdx++ {
        contour := contours[cIdx]

        var dist int
        for sf := 0; sf < numSubframes; sf++ {
            predicted := baseLag + int(contour[sf])
            diff := pitchLags[sf] - predicted
            dist += diff * diff
        }

        if dist < bestDist {
            bestDist = dist
            bestContour = cIdx
        }
    }

    return bestContour, baseLag
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```
  </action>
  <verify>
```bash
go build ./internal/silk/...
```
  </verify>
  <done>Three-stage pitch detection implemented with octave error prevention</done>
</task>

<task type="auto">
  <name>Task 2: Implement LTP Analysis and Codebook Quantization</name>
  <files>internal/silk/ltp_encode.go</files>
  <action>
Create LTP analysis and codebook quantization.

IMPORTANT: Use existing ICDF tables from tables.go:
- ICDFLTPFilterIndexLowPeriod/MidPeriod/HighPeriod for periodicity encoding
- ICDFLTPGainLow/Mid/High for LTP gain index encoding

```go
package silk

import "math"

// analyzeLTP computes LTP coefficients for each subframe.
// LTP predicts current samples from pitch-delayed past samples.
//
// Per draft-vos-silk-01 Section 2.1.2.6.
// Returns 5-tap LTP coefficients per subframe in Q7 format.
func (e *Encoder) analyzeLTP(pcm []float32, pitchLags []int, numSubframes int) [][]int8 {
    config := GetBandwidthConfig(e.bandwidth)
    subframeSamples := config.SubframeSamples

    ltpCoeffs := make([][]int8, numSubframes)

    for sf := 0; sf < numSubframes; sf++ {
        start := sf * subframeSamples
        lag := pitchLags[sf]

        // Compute optimal LTP coefficients via least squares
        coeffs := computeLTPCoeffs(pcm, start, subframeSamples, lag)

        // Quantize to codebook
        ltpCoeffs[sf] = quantizeLTPCoeffs(coeffs, e.isPreviousFrameVoiced)
    }

    return ltpCoeffs
}

// computeLTPCoeffs computes 5-tap LTP coefficients for a subframe.
// Uses least-squares minimization of prediction error.
func computeLTPCoeffs(pcm []float32, start, length, lag int) []float64 {
    const numTaps = 5
    const halfTaps = 2

    // Compute autocorrelation matrix and cross-correlation vector
    // R[i][j] = sum(x[n-lag+i-2] * x[n-lag+j-2])
    // r[i] = sum(x[n] * x[n-lag+i-2])

    var R [numTaps][numTaps]float64
    var r [numTaps]float64

    for n := start; n < start+length; n++ {
        if n < lag+halfTaps {
            continue
        }

        x := float64(pcm[n])

        for i := 0; i < numTaps; i++ {
            pastI := float64(pcm[n-lag+i-halfTaps])
            r[i] += x * pastI

            for j := 0; j < numTaps; j++ {
                pastJ := float64(pcm[n-lag+j-halfTaps])
                R[i][j] += pastI * pastJ
            }
        }
    }

    // Regularization for stability
    for i := 0; i < numTaps; i++ {
        R[i][i] += 1e-6
    }

    // Solve R * coeffs = r using Cholesky decomposition (simplified)
    coeffs := solveLTPSystem(R, r)

    return coeffs[:]
}

// solveLTPSystem solves the 5x5 normal equations using Gaussian elimination.
func solveLTPSystem(R [5][5]float64, r [5]float64) [5]float64 {
    const n = 5

    // Augmented matrix
    var A [n][n + 1]float64
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            A[i][j] = R[i][j]
        }
        A[i][n] = r[i]
    }

    // Forward elimination
    for i := 0; i < n; i++ {
        // Find pivot
        maxRow := i
        for k := i + 1; k < n; k++ {
            if math.Abs(A[k][i]) > math.Abs(A[maxRow][i]) {
                maxRow = k
            }
        }
        A[i], A[maxRow] = A[maxRow], A[i]

        if math.Abs(A[i][i]) < 1e-10 {
            continue // Skip singular
        }

        // Eliminate column
        for k := i + 1; k < n; k++ {
            factor := A[k][i] / A[i][i]
            for j := i; j <= n; j++ {
                A[k][j] -= factor * A[i][j]
            }
        }
    }

    // Back substitution
    var coeffs [5]float64
    for i := n - 1; i >= 0; i-- {
        sum := A[i][n]
        for j := i + 1; j < n; j++ {
            sum -= A[i][j] * coeffs[j]
        }
        if math.Abs(A[i][i]) > 1e-10 {
            coeffs[i] = sum / A[i][i]
        }
    }

    return coeffs
}

// quantizeLTPCoeffs quantizes LTP coefficients to nearest codebook entry.
// Uses LTP codebook from codebook.go.
// Returns Q7 format coefficients.
func quantizeLTPCoeffs(coeffs []float64, isPreviousVoiced bool) []int8 {
    const numTaps = 5

    // Select codebook based on periodicity
    periodicity := 1 // Default medium periodicity
    if isPreviousVoiced {
        periodicity = 2 // High periodicity for voiced continuation
    }

    codebook := LTPCodebook[periodicity]

    // Find best matching codebook entry
    bestIdx := 0
    var bestDist float64 = math.MaxFloat64

    for idx := 0; idx < len(codebook); idx++ {
        var dist float64
        for tap := 0; tap < numTaps; tap++ {
            // Codebook values are in Q7, convert to float
            cbVal := float64(codebook[idx][tap]) / 128.0
            diff := coeffs[tap] - cbVal
            dist += diff * diff
        }

        if dist < bestDist {
            bestDist = dist
            bestIdx = idx
        }
    }

    // Return codebook entry as quantized coefficients
    result := make([]int8, numTaps)
    copy(result, codebook[bestIdx][:])
    return result
}

// encodeLTPCoeffs encodes LTP coefficients to the bitstream.
// Per RFC 6716 Section 4.2.7.6.3.
// Uses existing ICDF tables: ICDFLTPFilterIndex*, ICDFLTPGain*
func (e *Encoder) encodeLTPCoeffs(ltpCoeffs [][]int8, periodicity int, numSubframes int) {
    // Encode periodicity index (selects LTP codebook)
    // Use existing periodicity ICDF tables
    var periodicityICDF []uint16
    var gainICDF []uint16

    switch periodicity {
    case 0:
        periodicityICDF = ICDFLTPFilterIndexLowPeriod
        gainICDF = ICDFLTPGainLow
    case 1:
        periodicityICDF = ICDFLTPFilterIndexMidPeriod
        gainICDF = ICDFLTPGainMid
    default:
        periodicityICDF = ICDFLTPFilterIndexHighPeriod
        gainICDF = ICDFLTPGainHigh
    }

    e.rangeEncoder.EncodeICDF16(periodicity, periodicityICDF, 8)

    // Encode codebook index per subframe
    codebook := LTPCodebook[periodicity]
    for sf := 0; sf < numSubframes; sf++ {
        // Find codebook index for this subframe's coefficients
        cbIdx := findLTPCodebookIndex(ltpCoeffs[sf], codebook)
        e.rangeEncoder.EncodeICDF16(cbIdx, gainICDF, 8)
    }
}

// findLTPCodebookIndex finds the codebook index for given coefficients.
func findLTPCodebookIndex(coeffs []int8, codebook [][5]int8) int {
    for idx := 0; idx < len(codebook); idx++ {
        match := true
        for tap := 0; tap < 5; tap++ {
            if coeffs[tap] != codebook[idx][tap] {
                match = false
                break
            }
        }
        if match {
            return idx
        }
    }
    return 0 // Default to first entry if no match
}
```
  </action>
  <verify>
```bash
go build ./internal/silk/...
```
  </verify>
  <done>LTP analysis produces valid 5-tap coefficient sets via codebook quantization</done>
</task>

<task type="auto">
  <name>Task 3: Create Pitch Detection Tests</name>
  <files>internal/silk/pitch_detect_test.go</files>
  <action>
Create tests for pitch detection:

```go
package silk

import (
    "math"
    "testing"
)

func TestDetectPitchVoicedSignal(t *testing.T) {
    enc := NewEncoder(BandwidthWideband)
    config := GetBandwidthConfig(BandwidthWideband)

    // Generate voiced signal at 200 Hz (pitch period = 80 samples at 16kHz)
    pitchPeriod := config.SampleRate / 200 // 80 samples
    frameSamples := config.FrameSamples    // 320 samples for 20ms

    pcm := make([]float32, frameSamples)
    for i := range pcm {
        // Sawtooth-like voiced waveform
        phase := float64(i%pitchPeriod) / float64(pitchPeriod)
        pcm[i] = float32(1.0-2.0*phase) * 10000
    }

    // Detect pitch
    numSubframes := 4
    pitchLags := enc.detectPitch(pcm, numSubframes)

    if len(pitchLags) != numSubframes {
        t.Fatalf("expected %d pitch lags, got %d", numSubframes, len(pitchLags))
    }

    // All lags should be close to pitch period
    for sf, lag := range pitchLags {
        // Allow 10% error
        error := absInt(lag - pitchPeriod)
        if error > pitchPeriod/10 {
            t.Errorf("subframe %d: detected lag %d, expected ~%d", sf, lag, pitchPeriod)
        }
    }
}

func TestDownsample(t *testing.T) {
    signal := []float32{1, 2, 3, 4, 5, 6, 7, 8}

    ds := downsample(signal, 2)
    if len(ds) != 4 {
        t.Fatalf("expected 4 samples, got %d", len(ds))
    }

    // Average of pairs
    expected := []float32{1.5, 3.5, 5.5, 7.5}
    for i, v := range ds {
        if math.Abs(float64(v-expected[i])) > 0.01 {
            t.Errorf("ds[%d] = %f, expected %f", i, v, expected[i])
        }
    }
}

func TestAutocorrPitchSearch(t *testing.T) {
    // Generate periodic signal
    period := 40
    n := 320
    signal := make([]float32, n)
    for i := range signal {
        signal[i] = float32(math.Sin(2 * math.Pi * float64(i) / float64(period)))
    }

    lag := autocorrPitchSearch(signal, 20, 60)

    // Should find the period (or multiple)
    if lag != period && lag != period*2 {
        t.Errorf("detected lag %d, expected ~%d", lag, period)
    }
}

func TestQuantizeLTPCoeffs(t *testing.T) {
    // Test with known coefficients
    coeffs := []float64{0.5, 0.3, 0.1, -0.1, -0.05}

    quantized := quantizeLTPCoeffs(coeffs, true)

    if len(quantized) != 5 {
        t.Fatalf("expected 5 coefficients, got %d", len(quantized))
    }

    // Coefficients should be in reasonable range (Q7 format: -128 to 127)
    for i, c := range quantized {
        if c < -128 || c > 127 {
            t.Errorf("quantized[%d] = %d out of Q7 range", i, c)
        }
    }
}

func absInt(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```
  </action>
  <verify>
```bash
go test -v -run "TestDetectPitch|TestDownsample|TestAutocorr|TestQuantizeLTP" ./internal/silk/...
```
  </verify>
  <done>Pitch detection tests pass, verifying correct lag detection</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
go test -v ./internal/silk/...

# Package builds
go build ./internal/silk/...
```
</verification>

<success_criteria>
1. detectPitch finds pitch period within 10% for voiced signals
2. Three-stage search correctly refines coarse estimate
3. autocorrPitchSearch uses bias toward shorter lags
4. LTP analysis produces 5-tap coefficients
5. LTP codebook quantization finds matching entry
6. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-silk-encoder/06-03-SUMMARY.md`
</output>
