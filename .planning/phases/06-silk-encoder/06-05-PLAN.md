---
phase: 06-silk-encoder
plan: 05
type: execute
wave: 4
depends_on: ["06-03", "06-04"]
files_modified:
  - internal/silk/excitation_encode.go
  - internal/silk/stereo_encode.go
  - internal/silk/encode_frame.go
  - internal/silk/silk_encode.go
  - internal/silk/encode_test.go
autonomous: true

must_haves:
  truths:
    - "Excitation encoding uses shell coding matching decoder"
    - "Stereo encoding produces mid-side coefficients and encodes weights"
    - "Complete frame encoding produces decodable bitstream"
    - "Round-trip through decoder recovers intelligible audio"
    - "Stereo round-trip test verifies left/right channel correlation"
  artifacts:
    - path: "internal/silk/excitation_encode.go"
      provides: "Shell coding excitation encoder"
      exports: ["encodeExcitation"]
    - path: "internal/silk/stereo_encode.go"
      provides: "Full stereo prediction encoding"
      exports: ["encodeStereo", "encodeStereoWeights"]
    - path: "internal/silk/encode_frame.go"
      provides: "Frame encoding pipeline"
      exports: ["EncodeFrame"]
    - path: "internal/silk/silk_encode.go"
      provides: "Public SILK encoding API"
      exports: ["Encode", "EncodeStereo"]
    - path: "internal/silk/encode_test.go"
      provides: "Round-trip verification tests including stereo"
      contains: ["TestEncodeDecodeRoundTrip", "TestEncodeStereoRoundTrip"]
  key_links:
    - from: "internal/silk/encode_frame.go"
      to: "internal/silk/excitation_encode.go"
      via: "excitation encoding call"
      pattern: "encodeExcitation"
    - from: "internal/silk/silk_encode.go"
      to: "internal/silk/encode_frame.go"
      via: "frame encoding"
      pattern: "EncodeFrame"
    - from: "internal/silk/encode_test.go"
      to: "internal/silk/silk.go"
      via: "round-trip verification imports silk.Decode"
      pattern: "import.*silk.*Decode"
---

<objective>
Complete SILK encoder with excitation encoding, stereo support, and full frame pipeline.

Purpose: This plan completes the SILK encoder by implementing shell-coded excitation encoding (mirroring the decoder exactly), full stereo prediction encoding with weight coding, and the complete frame encoding pipeline. The final tests verify round-trip through the Phase 2 decoder for both mono and stereo.

Output:
- Shell coding excitation encoder
- Full stereo mid-side encoding with weight coding
- Complete frame encoding pipeline
- Public Encode/EncodeStereo API
- Round-trip verification tests (mono and stereo)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-silk-encoder/06-RESEARCH.md
@.planning/phases/06-silk-encoder/06-03-SUMMARY.md
@.planning/phases/06-silk-encoder/06-04-SUMMARY.md

# Reference decoder for compatibility
@internal/silk/excitation.go
@internal/silk/stereo.go
@internal/silk/decode.go
@internal/silk/silk.go

# IMPORTANT: All ICDF tables already exist from Phase 2 decoder (decision D02-01-02)
# Reuse these tables - do NOT create new ones:
# Excitation tables:
#   - ICDFRateLevelVoiced, ICDFRateLevelUnvoiced (rate level per signal type)
#   - ICDFExcitationPulseCount (pulse count per shell)
#   - ICDFExcitationSplit (binary split tables indexed by count)
#   - ICDFExcitationLSB (LSB for large pulses)
#   - ICDFExcitationSign (sign tables indexed by [signalType][quantOffset][pulseIdx])
#   - ICDFLCGSeed (comfort noise seed)
# Stereo tables:
#   - ICDFStereoPredWeight (stereo prediction weight)
#   - ICDFStereoPredWeightDelta (weight delta coding)
# Frame type:
#   - ICDFFrameTypeVADActive (signal type + quant offset)
@internal/silk/tables.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Shell Coding Excitation Encoder</name>
  <files>internal/silk/excitation_encode.go</files>
  <action>
Create excitation encoder that mirrors the decoder's shell coding.

IMPORTANT: Use existing ICDF tables from tables.go:
- ICDFRateLevelVoiced, ICDFRateLevelUnvoiced for rate level
- ICDFExcitationPulseCount for pulse count per shell
- ICDFExcitationSplit for binary split (indexed by total pulses)
- ICDFExcitationLSB for LSB of large pulses
- ICDFExcitationSign for pulse signs
- ICDFLCGSeed for comfort noise seed

```go
package silk

// encodeExcitation encodes the excitation signal for one subframe.
// Uses shell coding with binary splits, mirroring decoder exactly.
// Per RFC 6716 Section 4.2.7.8.
// Uses existing ICDF tables from tables.go
func (e *Encoder) encodeExcitation(excitation []int32, signalType, quantOffset int) {
    shellSize := 16
    numShells := len(excitation) / shellSize

    // Compute pulse counts per shell
    pulseCounts := make([]int, numShells)
    for shell := 0; shell < numShells; shell++ {
        offset := shell * shellSize
        for i := 0; i < shellSize; i++ {
            pulseCounts[shell] += absInt(int(excitation[offset+i]))
        }
    }

    // Determine rate level (minimize total bits)
    rateLevel := e.selectRateLevel(pulseCounts, signalType)

    // Encode rate level using existing ICDF tables
    if signalType == 2 { // Voiced
        e.rangeEncoder.EncodeICDF16(rateLevel, ICDFRateLevelVoiced, 8)
    } else {
        e.rangeEncoder.EncodeICDF16(rateLevel, ICDFRateLevelUnvoiced, 8)
    }

    // Encode pulse counts per shell
    for shell := 0; shell < numShells; shell++ {
        count := pulseCounts[shell]
        if count > 18 {
            count = 18 // Clamp to max encodable
        }
        e.rangeEncoder.EncodeICDF16(count, ICDFExcitationPulseCount, 8)
    }

    // Encode LSBs for large pulse counts (> 10)
    lsbCounts := make([]int, numShells)
    for shell := 0; shell < numShells; shell++ {
        if pulseCounts[shell] > 10 {
            // Compute how many LSB bits needed
            lsbCounts[shell] = (pulseCounts[shell] - 10 + 1) / 2
            if lsbCounts[shell] > 10 {
                lsbCounts[shell] = 10
            }
            e.rangeEncoder.EncodeICDF16(lsbCounts[shell], ICDFExcitationLSB, 8)
        }
    }

    // Encode shell structure using binary splits
    for shell := 0; shell < numShells; shell++ {
        if pulseCounts[shell] == 0 {
            continue
        }

        offset := shell * shellSize
        shellPulses := make([]int, shellSize)
        for i := 0; i < shellSize; i++ {
            shellPulses[i] = absInt(int(excitation[offset+i]))
        }

        e.encodePulseDistribution(shellPulses, pulseCounts[shell])
    }

    // Encode signs for non-zero pulses using ICDFExcitationSign
    for shell := 0; shell < numShells; shell++ {
        offset := shell * shellSize
        for i := 0; i < shellSize; i++ {
            if excitation[offset+i] != 0 {
                sign := 0
                if excitation[offset+i] < 0 {
                    sign = 1
                }

                // Sign ICDF indexed by [signalType][quantOffset][min(|pulse|-1, 5)]
                signIdx := absInt(int(excitation[offset+i])) - 1
                if signIdx > 5 {
                    signIdx = 5
                }
                if signIdx < 0 {
                    signIdx = 0
                }

                signICDF := ICDFExcitationSign[signalType][quantOffset][signIdx]
                e.rangeEncoder.EncodeICDF16(sign, signICDF, 8)
            }
        }

        // Encode LSB values if present
        if lsbCounts[shell] > 0 {
            for i := 0; i < shellSize; i++ {
                if excitation[offset+i] != 0 {
                    // Extract LSB from magnitude
                    mag := absInt(int(excitation[offset+i]))
                    lsb := mag & 1
                    e.rangeEncoder.EncodeICDF16(lsb, ICDFExcitationLSB, 8)
                }
            }
        }
    }

    // Encode LCG seed for comfort noise
    seed := e.computeLCGSeed(excitation)
    e.rangeEncoder.EncodeICDF16(seed, ICDFLCGSeed, 8)
}

// encodePulseDistribution encodes the binary split tree.
// Mirrors decoder's decodePulseDistribution exactly in reverse.
// Uses ICDFExcitationSplit tables indexed by pulse count
func (e *Encoder) encodePulseDistribution(pulses []int, totalPulses int) {
    if totalPulses == 0 || len(pulses) <= 1 {
        return
    }

    // Compute left count
    mid := len(pulses) / 2
    var leftCount int
    for i := 0; i < mid; i++ {
        leftCount += pulses[i]
    }

    // Encode left count using split ICDF
    splitIdx := totalPulses
    if splitIdx >= len(ICDFExcitationSplit) {
        splitIdx = len(ICDFExcitationSplit) - 1
    }
    icdf := ICDFExcitationSplit[splitIdx]

    // Clamp leftCount to valid range
    if leftCount > totalPulses {
        leftCount = totalPulses
    }
    e.rangeEncoder.EncodeICDF16(leftCount, icdf, 8)

    // Recurse
    rightCount := totalPulses - leftCount
    e.encodePulseDistribution(pulses[:mid], leftCount)
    e.encodePulseDistribution(pulses[mid:], rightCount)
}

// selectRateLevel selects the rate level that minimizes bits.
func (e *Encoder) selectRateLevel(pulseCounts []int, signalType int) int {
    // Simple heuristic: higher rate for higher pulse counts
    var totalPulses int
    for _, c := range pulseCounts {
        totalPulses += c
    }

    avgPulses := totalPulses / len(pulseCounts)

    if avgPulses < 2 {
        return 0
    } else if avgPulses < 4 {
        return 1
    } else if avgPulses < 6 {
        return 2
    }
    return 3
}

// computeLCGSeed computes seed for comfort noise generation.
func (e *Encoder) computeLCGSeed(excitation []int32) int {
    // Use hash of excitation as seed
    var hash int32
    for _, v := range excitation {
        hash ^= v
        hash = (hash << 5) | (hash >> 27)
    }
    return int(hash & 0x3) // 2-bit seed
}

// computeExcitation computes the LPC residual (excitation signal).
// excitation[n] = input[n] - sum(lpc[k] * input[n-k-1])
func (e *Encoder) computeExcitation(pcm []float32, lpcQ12 []int16, gain float32) []int32 {
    n := len(pcm)
    order := len(lpcQ12)
    excitation := make([]int32, n)

    for i := 0; i < n; i++ {
        // Compute LPC prediction
        var prediction float64
        for k := 0; k < order && i-k-1 >= 0; k++ {
            prediction += float64(lpcQ12[k]) * float64(pcm[i-k-1]) / 4096.0
        }

        // Residual = input - prediction, scaled by gain
        residual := float64(pcm[i]) - prediction
        if gain > 0 {
            residual /= float64(gain)
        }

        // Quantize to integer
        excitation[i] = int32(residual)
    }

    return excitation
}
```
  </action>
  <verify>
```bash
go build ./internal/silk/...
```
  </verify>
  <done>Shell coding excitation encoder implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement Full Stereo Encoding and Frame Pipeline</name>
  <files>internal/silk/stereo_encode.go, internal/silk/encode_frame.go</files>
  <action>
Create full stereo encoding (not simplified) and the complete frame encoding pipeline.

IMPORTANT: Use existing ICDF tables from tables.go:
- ICDFStereoPredWeight for absolute stereo weight encoding
- ICDFStereoPredWeightDelta for delta weight encoding
- ICDFFrameTypeVADActive for frame type encoding

**stereo_encode.go:**
```go
package silk

import "math"

// encodeStereo converts stereo to mid-side and computes prediction weights.
// Returns mid channel, side channel, and Q13 stereo weights.
// Per RFC 6716 Section 4.2.8.
func (e *Encoder) encodeStereo(left, right []float32) (mid []float32, side []float32, weights [2]int16) {
    n := len(left)
    mid = make([]float32, n)
    side = make([]float32, n)

    // Compute mid and side channels
    for i := 0; i < n; i++ {
        mid[i] = (left[i] + right[i]) / 2
        side[i] = (left[i] - right[i]) / 2
    }

    // Compute stereo prediction weights using linear regression
    // side[n] ~= w0 * mid[n] + w1 * mid[n-1]
    // Minimize sum((side[n] - w0*mid[n] - w1*mid[n-1])^2)
    var sumMM, sumMS, sumM1M1, sumM1S, sumMM1 float64

    for i := 1; i < n; i++ {
        m := float64(mid[i])
        m1 := float64(mid[i-1])
        s := float64(side[i])

        sumMM += m * m
        sumMS += m * s
        sumM1M1 += m1 * m1
        sumM1S += m1 * s
        sumMM1 += m * m1
    }

    // Solve 2x2 system for w0, w1
    // [sumMM   sumMM1] [w0]   [sumMS]
    // [sumMM1 sumM1M1] [w1] = [sumM1S]
    det := sumMM*sumM1M1 - sumMM1*sumMM1
    var w0, w1 float64
    if math.Abs(det) > 1e-10 {
        w0 = (sumMS*sumM1M1 - sumM1S*sumMM1) / det
        w1 = (sumMM*sumM1S - sumMM1*sumMS) / det
    }

    // Clamp to valid range [-1, 1]
    if w0 > 1.0 {
        w0 = 1.0
    }
    if w0 < -1.0 {
        w0 = -1.0
    }
    if w1 > 1.0 {
        w1 = 1.0
    }
    if w1 < -1.0 {
        w1 = -1.0
    }

    // Convert to Q13
    weights[0] = int16(w0 * 8192)
    weights[1] = int16(w1 * 8192)

    return mid, side, weights
}

// encodeStereoWeights encodes stereo prediction weights to bitstream.
// Per RFC 6716 Section 4.2.8.3.
// Uses existing ICDF tables: ICDFStereoPredWeight, ICDFStereoPredWeightDelta
func (e *Encoder) encodeStereoWeights(weights [2]int16) {
    if e.haveEncoded {
        // Delta coding from previous weights
        delta0 := weights[0] - e.prevStereoWeights[0]
        delta1 := weights[1] - e.prevStereoWeights[1]

        // Quantize delta to index [0, 8)
        idx0 := e.quantizeStereoWeightDelta(delta0)
        idx1 := e.quantizeStereoWeightDelta(delta1)

        e.rangeEncoder.EncodeICDF16(idx0, ICDFStereoPredWeightDelta, 8)
        e.rangeEncoder.EncodeICDF16(idx1, ICDFStereoPredWeightDelta, 8)
    } else {
        // First frame: encode absolute weights
        idx0 := e.quantizeStereoWeight(weights[0])
        idx1 := e.quantizeStereoWeight(weights[1])

        e.rangeEncoder.EncodeICDF16(idx0, ICDFStereoPredWeight, 8)
        e.rangeEncoder.EncodeICDF16(idx1, ICDFStereoPredWeight, 8)
    }

    e.prevStereoWeights = weights
}

// quantizeStereoWeight quantizes absolute weight to index [0, 8).
func (e *Encoder) quantizeStereoWeight(weight int16) int {
    // Map Q13 weight [-8192, 8192] to index [0, 8)
    // Linear mapping: idx = (weight + 8192) * 8 / 16384
    idx := int(weight+8192) * 8 / 16384
    if idx < 0 {
        idx = 0
    }
    if idx > 7 {
        idx = 7
    }
    return idx
}

// quantizeStereoWeightDelta quantizes weight delta to index [0, 8).
func (e *Encoder) quantizeStereoWeightDelta(delta int16) int {
    // Map delta to index centered at 4
    // Each step is ~1024 Q13 units
    idx := int(delta)/1024 + 4
    if idx < 0 {
        idx = 0
    }
    if idx > 7 {
        idx = 7
    }
    return idx
}

// reconstructSide reconstructs side channel from mid using weights.
// For verification that encoding matches decoding.
func reconstructSide(mid []float32, weights [2]int16) []float32 {
    n := len(mid)
    side := make([]float32, n)

    w0 := float32(weights[0]) / 8192.0
    w1 := float32(weights[1]) / 8192.0

    for i := 0; i < n; i++ {
        var m1 float32
        if i > 0 {
            m1 = mid[i-1]
        }
        side[i] = w0*mid[i] + w1*m1
    }

    return side
}
```

**encode_frame.go:**
```go
package silk

import "gopus/internal/rangecoding"

// EncodeFrame encodes a complete SILK frame to bitstream.
// Returns encoded bytes.
func (e *Encoder) EncodeFrame(pcm []float32, vadFlag bool) []byte {
    config := GetBandwidthConfig(e.bandwidth)
    numSubframes := 4 // 20ms frame = 4 subframes

    // Allocate output buffer
    output := make([]byte, 256) // Max frame size
    e.rangeEncoder = &rangecoding.Encoder{}
    e.rangeEncoder.Init(output)

    // Step 1: Classify frame (VAD)
    var signalType, quantOffset int
    if vadFlag {
        signalType, quantOffset = e.classifyFrame(pcm)
    } else {
        signalType, quantOffset = 0, 0
    }

    // Step 2: Encode frame type using ICDFFrameTypeVADActive
    e.encodeFrameType(vadFlag, signalType, quantOffset)

    // Step 3: Compute and encode gains
    gains := e.computeSubframeGains(pcm, numSubframes)
    e.encodeSubframeGains(gains, signalType, numSubframes)

    // Step 4: Compute LPC coefficients
    lpcQ12 := e.computeLPCFromFrame(pcm)

    // Step 5: Convert to LSF and quantize
    lsfQ15 := lpcToLSFEncode(lpcQ12)
    stage1Idx, residuals, interpIdx := e.quantizeLSF(lsfQ15, e.bandwidth, signalType)
    e.encodeLSF(stage1Idx, residuals, interpIdx, e.bandwidth, signalType)

    // Step 6: Pitch detection and LTP (voiced only)
    if signalType == 2 {
        pitchLags := e.detectPitch(pcm, numSubframes)
        e.encodePitchLags(pitchLags, numSubframes)

        ltpCoeffs := e.analyzeLTP(pcm, pitchLags, numSubframes)
        periodicity := 1
        if e.isPreviousFrameVoiced {
            periodicity = 2
        }
        e.encodeLTPCoeffs(ltpCoeffs, periodicity, numSubframes)
    }

    // Step 7: Compute and encode excitation per subframe
    subframeSamples := config.SubframeSamples
    for sf := 0; sf < numSubframes; sf++ {
        start := sf * subframeSamples
        end := start + subframeSamples
        subframe := pcm[start:end]

        // Compute excitation (LPC residual)
        excitation := e.computeExcitation(subframe, lpcQ12, gains[sf]/65536.0)
        e.encodeExcitation(excitation, signalType, quantOffset)
    }

    // Update state for next frame
    e.isPreviousFrameVoiced = (signalType == 2)
    copy(e.prevLSFQ15, lsfQ15)
    e.MarkEncoded()

    // Finalize encoding
    return e.rangeEncoder.Done()
}

// encodeFrameType encodes VAD flag, signal type, and quantization offset.
// Uses ICDFFrameTypeVADActive from tables.go
func (e *Encoder) encodeFrameType(vadFlag bool, signalType, quantOffset int) {
    if !vadFlag {
        // Inactive frame - encoded via VAD flag in packet header
        return
    }

    // Active frame: encode signal type and quant offset
    // idx = (signalType-1)*2 + quantOffset
    idx := (signalType-1)*2 + quantOffset
    e.rangeEncoder.EncodeICDF16(idx, ICDFFrameTypeVADActive, 8)
}
```
  </action>
  <verify>
```bash
go build ./internal/silk/...
```
  </verify>
  <done>Full stereo encoding and frame encoding pipeline complete</done>
</task>

<task type="auto">
  <name>Task 3: Create Public API and Round-Trip Tests (Mono and Stereo)</name>
  <files>internal/silk/silk_encode.go, internal/silk/encode_test.go</files>
  <action>
Create public encoding API and round-trip verification tests including stereo.

**silk_encode.go:**
```go
package silk

// Encode encodes mono PCM audio to SILK frame.
// pcm: Input samples at encoder's configured sample rate
// vadFlag: True if frame contains voice activity
// Returns: Encoded SILK frame bytes
func Encode(pcm []float32, bandwidth Bandwidth, vadFlag bool) ([]byte, error) {
    enc := NewEncoder(bandwidth)
    return enc.EncodeFrame(pcm, vadFlag), nil
}

// EncodeStereo encodes stereo PCM audio to SILK frame.
// left, right: Input samples for each channel
// bandwidth: Target bandwidth
// vadFlag: True if frame contains voice activity
// Returns: Encoded SILK frame bytes for combined mid/side channels
func EncodeStereo(left, right []float32, bandwidth Bandwidth, vadFlag bool) ([]byte, error) {
    enc := NewEncoder(bandwidth)

    // Convert to mid-side and compute stereo weights
    mid, side, weights := enc.encodeStereo(left, right)

    // Encode stereo weights to bitstream
    enc.encodeStereoWeights(weights)

    // Encode mid channel (primary)
    midBytes := enc.EncodeFrame(mid, vadFlag)

    // Encode side channel (secondary, typically lower bitrate)
    sideEnc := NewEncoder(bandwidth)
    sideBytes := sideEnc.EncodeFrame(side, vadFlag)

    // Combine mid and side into single output
    // Format: [mid_len:2][mid_bytes][side_len:2][side_bytes][weights:4]
    result := make([]byte, 2+len(midBytes)+2+len(sideBytes)+4)

    // Write mid length and data
    result[0] = byte(len(midBytes) >> 8)
    result[1] = byte(len(midBytes))
    copy(result[2:], midBytes)

    // Write side length and data
    offset := 2 + len(midBytes)
    result[offset] = byte(len(sideBytes) >> 8)
    result[offset+1] = byte(len(sideBytes))
    copy(result[offset+2:], sideBytes)

    // Write stereo weights (Q13 format)
    wOffset := offset + 2 + len(sideBytes)
    result[wOffset] = byte(weights[0] >> 8)
    result[wOffset+1] = byte(weights[0])
    result[wOffset+2] = byte(weights[1] >> 8)
    result[wOffset+3] = byte(weights[1])

    return result, nil
}

// DecodeStereo decodes stereo SILK frame back to left/right channels.
// Uses Phase 2 decoder for mid/side, then reconstructs stereo.
func DecodeStereo(encoded []byte, bandwidth Bandwidth) (left, right []float32, err error) {
    if len(encoded) < 8 {
        return nil, nil, ErrInvalidPacket
    }

    // Parse mid length and data
    midLen := int(encoded[0])<<8 | int(encoded[1])
    if 2+midLen > len(encoded) {
        return nil, nil, ErrInvalidPacket
    }
    midBytes := encoded[2 : 2+midLen]

    // Parse side length and data
    offset := 2 + midLen
    if offset+2 > len(encoded) {
        return nil, nil, ErrInvalidPacket
    }
    sideLen := int(encoded[offset])<<8 | int(encoded[offset+1])
    if offset+2+sideLen+4 > len(encoded) {
        return nil, nil, ErrInvalidPacket
    }
    sideBytes := encoded[offset+2 : offset+2+sideLen]

    // Parse stereo weights
    wOffset := offset + 2 + sideLen
    weights := [2]int16{
        int16(encoded[wOffset])<<8 | int16(encoded[wOffset+1]),
        int16(encoded[wOffset+2])<<8 | int16(encoded[wOffset+3]),
    }

    // Decode mid and side channels using Phase 2 decoder
    mid, err := Decode(midBytes, bandwidth)
    if err != nil {
        return nil, nil, err
    }
    side, err := Decode(sideBytes, bandwidth)
    if err != nil {
        return nil, nil, err
    }

    // Reconstruct left/right from mid/side
    n := len(mid)
    if len(side) < n {
        n = len(side)
    }

    left = make([]float32, n)
    right = make([]float32, n)

    // Apply stereo weights to reconstruct
    // Prediction: side_pred = w0*mid + w1*mid_prev
    // Residual side is encoded separately
    w0 := float32(weights[0]) / 8192.0
    w1 := float32(weights[1]) / 8192.0

    for i := 0; i < n; i++ {
        var midPrev float32
        if i > 0 {
            midPrev = mid[i-1]
        }
        sidePred := w0*mid[i] + w1*midPrev
        sideActual := side[i] + sidePred

        // Convert back to left/right
        left[i] = mid[i] + sideActual
        right[i] = mid[i] - sideActual
    }

    return left, right, nil
}

// EncoderState holds encoder state for streaming encoding.
type EncoderState struct {
    enc *Encoder
}

// NewEncoderState creates a new streaming encoder.
func NewEncoderState(bandwidth Bandwidth) *EncoderState {
    return &EncoderState{
        enc: NewEncoder(bandwidth),
    }
}

// EncodeFrame encodes a frame maintaining state across calls.
func (es *EncoderState) EncodeFrame(pcm []float32, vadFlag bool) ([]byte, error) {
    return es.enc.EncodeFrame(pcm, vadFlag), nil
}

// Reset resets encoder state for a new stream.
func (es *EncoderState) Reset() {
    es.enc.Reset()
}
```

**encode_test.go:**
```go
package silk

import (
    "math"
    "testing"
)

func TestEncodeFrameBasic(t *testing.T) {
    // Generate test signal
    config := GetBandwidthConfig(BandwidthWideband)
    pcm := make([]float32, config.FrameSamples)
    for i := range pcm {
        // 300 Hz sine wave
        pcm[i] = float32(math.Sin(2*math.Pi*300*float64(i)/float64(config.SampleRate))) * 10000
    }

    // Encode
    encoded, err := Encode(pcm, BandwidthWideband, true)
    if err != nil {
        t.Fatalf("Encode failed: %v", err)
    }

    // Verify we got output
    if len(encoded) == 0 {
        t.Error("Encode produced empty output")
    }

    // Verify output is not too large (reasonable for 20ms SILK frame)
    if len(encoded) > 250 {
        t.Errorf("Encoded frame too large: %d bytes", len(encoded))
    }
}

func TestEncodeDecodeRoundTrip(t *testing.T) {
    // Generate voiced test signal (300 Hz fundamental)
    config := GetBandwidthConfig(BandwidthWideband)
    original := make([]float32, config.FrameSamples)
    for i := range original {
        tm := float64(i) / float64(config.SampleRate)
        // Voiced-like signal with harmonics
        original[i] = float32(
            math.Sin(2*math.Pi*300*tm) +
                0.5*math.Sin(2*math.Pi*600*tm) +
                0.3*math.Sin(2*math.Pi*900*tm),
        ) * 10000
    }

    // Encode
    encoded, err := Encode(original, BandwidthWideband, true)
    if err != nil {
        t.Fatalf("Encode failed: %v", err)
    }

    // Decode using Phase 2 decoder (imported via silk.Decode)
    decoded, err := Decode(encoded, BandwidthWideband)
    if err != nil {
        t.Fatalf("Decode failed: %v", err)
    }

    // Verify output length matches
    if len(decoded) != len(original) {
        t.Errorf("Decoded length %d != original length %d", len(decoded), len(original))
    }

    // Verify signals are correlated (not necessarily identical due to lossy compression)
    correlation := computeCorrelation(original, decoded)
    const minCorrelation = 0.5 // Expect at least 50% correlation

    if correlation < minCorrelation {
        t.Errorf("Poor round-trip quality: correlation = %.3f < %.3f", correlation, minCorrelation)
    }

    t.Logf("Round-trip correlation: %.3f", correlation)
}

func TestEncodeStereoRoundTrip(t *testing.T) {
    // Generate stereo test signal (different frequencies per channel)
    config := GetBandwidthConfig(BandwidthWideband)
    left := make([]float32, config.FrameSamples)
    right := make([]float32, config.FrameSamples)

    for i := range left {
        tm := float64(i) / float64(config.SampleRate)
        // Left: 300 Hz
        left[i] = float32(math.Sin(2*math.Pi*300*tm)) * 10000
        // Right: 350 Hz (slightly different)
        right[i] = float32(math.Sin(2*math.Pi*350*tm)) * 10000
    }

    // Encode stereo
    encoded, err := EncodeStereo(left, right, BandwidthWideband, true)
    if err != nil {
        t.Fatalf("EncodeStereo failed: %v", err)
    }

    if len(encoded) == 0 {
        t.Fatal("EncodeStereo produced empty output")
    }

    // Decode stereo using DecodeStereo
    decodedLeft, decodedRight, err := DecodeStereo(encoded, BandwidthWideband)
    if err != nil {
        t.Fatalf("DecodeStereo failed: %v", err)
    }

    // Verify output lengths
    if len(decodedLeft) != len(left) {
        t.Errorf("Decoded left length %d != original %d", len(decodedLeft), len(left))
    }
    if len(decodedRight) != len(right) {
        t.Errorf("Decoded right length %d != original %d", len(decodedRight), len(right))
    }

    // Verify left channel correlation
    leftCorr := computeCorrelation(left, decodedLeft)
    if leftCorr < 0.4 {
        t.Errorf("Poor left channel round-trip: correlation = %.3f", leftCorr)
    }
    t.Logf("Left channel correlation: %.3f", leftCorr)

    // Verify right channel correlation
    rightCorr := computeCorrelation(right, decodedRight)
    if rightCorr < 0.4 {
        t.Errorf("Poor right channel round-trip: correlation = %.3f", rightCorr)
    }
    t.Logf("Right channel correlation: %.3f", rightCorr)
}

func TestEncodeSilence(t *testing.T) {
    config := GetBandwidthConfig(BandwidthWideband)
    pcm := make([]float32, config.FrameSamples) // All zeros

    encoded, err := Encode(pcm, BandwidthWideband, false) // vadFlag=false for silence
    if err != nil {
        t.Fatalf("Encode silence failed: %v", err)
    }

    // Silence should encode to small frame
    if len(encoded) > 50 {
        t.Errorf("Silence frame too large: %d bytes", len(encoded))
    }
}

func TestEncodeStreaming(t *testing.T) {
    config := GetBandwidthConfig(BandwidthWideband)
    es := NewEncoderState(BandwidthWideband)

    // Encode multiple frames
    for frame := 0; frame < 5; frame++ {
        pcm := make([]float32, config.FrameSamples)
        for i := range pcm {
            tm := float64(i+frame*config.FrameSamples) / float64(config.SampleRate)
            pcm[i] = float32(math.Sin(2*math.Pi*400*tm)) * 10000
        }

        encoded, err := es.EncodeFrame(pcm, true)
        if err != nil {
            t.Fatalf("Frame %d encode failed: %v", frame, err)
        }

        if len(encoded) == 0 {
            t.Errorf("Frame %d produced empty output", frame)
        }
    }
}

func computeCorrelation(a, b []float32) float64 {
    n := len(a)
    if len(b) < n {
        n = len(b)
    }

    var sumAB, sumA2, sumB2 float64
    for i := 0; i < n; i++ {
        sumAB += float64(a[i]) * float64(b[i])
        sumA2 += float64(a[i]) * float64(a[i])
        sumB2 += float64(b[i]) * float64(b[i])
    }

    if sumA2 < 1e-10 || sumB2 < 1e-10 {
        return 0
    }

    return sumAB / math.Sqrt(sumA2*sumB2)
}
```
  </action>
  <verify>
```bash
go test -v -run "TestEncode" ./internal/silk/...
```
  </verify>
  <done>Public API complete, round-trip tests pass for both mono and stereo with reasonable correlation</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
go test -v ./internal/silk/...

# Full test suite including round-trip
go test -v -run "Test" ./internal/silk/...

# Package builds
go build ./internal/silk/...
go build ./...
```
</verification>

<success_criteria>
1. Shell coding excitation encoder produces decodable output
2. Full stereo encoding computes valid mid-side weights with linear regression
3. Stereo weights encoded using ICDFStereoPredWeight/Delta tables
4. Frame encoding pipeline produces valid SILK bitstream
5. Encode/EncodeStereo public API works
6. Mono round-trip through decoder produces correlated output (>50% correlation)
7. Stereo round-trip through decoder produces correlated left/right (>40% correlation)
8. Multiple frames can be encoded in sequence (streaming)
9. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-silk-encoder/06-05-SUMMARY.md`
</output>
