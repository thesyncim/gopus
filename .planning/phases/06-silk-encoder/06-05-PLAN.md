---
phase: 06-silk-encoder
plan: 05
type: execute
wave: 4
depends_on: ["06-03", "06-04"]
files_modified:
  - internal/silk/excitation_encode.go
  - internal/silk/stereo_encode.go
  - internal/silk/encode_frame.go
  - internal/silk/silk_encode.go
  - internal/silk/encode_test.go
autonomous: true

must_haves:
  truths:
    - "Excitation encoding uses shell coding matching decoder"
    - "Stereo encoding produces mid-side coefficients"
    - "Complete frame encoding produces decodable bitstream"
    - "Round-trip through decoder recovers intelligible audio"
  artifacts:
    - path: "internal/silk/excitation_encode.go"
      provides: "Shell coding excitation encoder"
      exports: ["encodeExcitation"]
    - path: "internal/silk/stereo_encode.go"
      provides: "Stereo prediction encoding"
      exports: ["encodeStereo"]
    - path: "internal/silk/encode_frame.go"
      provides: "Frame encoding pipeline"
      exports: ["EncodeFrame"]
    - path: "internal/silk/silk_encode.go"
      provides: "Public SILK encoding API"
      exports: ["Encode", "EncodeStereo"]
  key_links:
    - from: "internal/silk/encode_frame.go"
      to: "internal/silk/excitation_encode.go"
      via: "excitation encoding call"
      pattern: "encodeExcitation"
    - from: "internal/silk/silk_encode.go"
      to: "internal/silk/encode_frame.go"
      via: "frame encoding"
      pattern: "EncodeFrame"
    - from: "internal/silk/encode_test.go"
      to: "internal/silk/silk.go"
      via: "round-trip verification"
      pattern: "Decode"
---

<objective>
Complete SILK encoder with excitation encoding, stereo support, and full frame pipeline.

Purpose: This plan completes the SILK encoder by implementing shell-coded excitation encoding (mirroring the decoder exactly), stereo prediction encoding, and the complete frame encoding pipeline. The final test verifies round-trip through the Phase 2 decoder.

Output:
- Shell coding excitation encoder
- Stereo mid-side encoding
- Complete frame encoding pipeline
- Public Encode/EncodeStereo API
- Round-trip verification tests
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-silk-encoder/06-RESEARCH.md
@.planning/phases/06-silk-encoder/06-03-SUMMARY.md
@.planning/phases/06-silk-encoder/06-04-SUMMARY.md

# Reference decoder for compatibility
@internal/silk/excitation.go
@internal/silk/stereo.go
@internal/silk/decode.go
@internal/silk/silk.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Shell Coding Excitation Encoder</name>
  <files>internal/silk/excitation_encode.go</files>
  <action>
Create excitation encoder that mirrors the decoder's shell coding:

```go
package silk

// encodeExcitation encodes the excitation signal for one subframe.
// Uses shell coding with binary splits, mirroring decoder exactly.
// Per RFC 6716 Section 4.2.7.8.
func (e *Encoder) encodeExcitation(excitation []int32, signalType, quantOffset int) {
    shellSize := 16
    numShells := len(excitation) / shellSize

    // Compute pulse counts per shell
    pulseCounts := make([]int, numShells)
    for shell := 0; shell < numShells; shell++ {
        offset := shell * shellSize
        for i := 0; i < shellSize; i++ {
            pulseCounts[shell] += absInt(int(excitation[offset+i]))
        }
    }

    // Determine rate level (minimize total bits)
    rateLevel := e.selectRateLevel(pulseCounts, signalType)

    // Encode rate level
    if signalType == 2 { // Voiced
        e.rangeEncoder.EncodeICDF16(rateLevel, ICDFRateLevelVoiced, 8)
    } else {
        e.rangeEncoder.EncodeICDF16(rateLevel, ICDFRateLevelUnvoiced, 8)
    }

    // Encode pulse counts per shell
    for shell := 0; shell < numShells; shell++ {
        count := pulseCounts[shell]
        if count > 18 {
            count = 18 // Clamp to max encodable
        }
        e.rangeEncoder.EncodeICDF16(count, ICDFExcitationPulseCount, 8)
    }

    // Encode LSBs for large pulse counts (> 10)
    lsbCounts := make([]int, numShells)
    for shell := 0; shell < numShells; shell++ {
        if pulseCounts[shell] > 10 {
            // Compute how many LSB bits needed
            lsbCounts[shell] = (pulseCounts[shell] - 10 + 1) / 2
            if lsbCounts[shell] > 10 {
                lsbCounts[shell] = 10
            }
            e.rangeEncoder.EncodeICDF16(lsbCounts[shell], ICDFExcitationLSB, 8)
        }
    }

    // Encode shell structure using binary splits
    for shell := 0; shell < numShells; shell++ {
        if pulseCounts[shell] == 0 {
            continue
        }

        offset := shell * shellSize
        shellPulses := make([]int, shellSize)
        for i := 0; i < shellSize; i++ {
            shellPulses[i] = absInt(int(excitation[offset+i]))
        }

        e.encodePulseDistribution(shellPulses, pulseCounts[shell])
    }

    // Encode signs for non-zero pulses
    for shell := 0; shell < numShells; shell++ {
        offset := shell * shellSize
        for i := 0; i < shellSize; i++ {
            if excitation[offset+i] != 0 {
                sign := 0
                if excitation[offset+i] < 0 {
                    sign = 1
                }

                // Sign ICDF indexed by [signalType][quantOffset][min(|pulse|-1, 5)]
                signIdx := absInt(int(excitation[offset+i])) - 1
                if signIdx > 5 {
                    signIdx = 5
                }
                if signIdx < 0 {
                    signIdx = 0
                }

                signICDF := ICDFExcitationSign[signalType][quantOffset][signIdx]
                e.rangeEncoder.EncodeICDF16(sign, signICDF, 8)
            }
        }

        // Encode LSB values if present
        if lsbCounts[shell] > 0 {
            for i := 0; i < shellSize; i++ {
                if excitation[offset+i] != 0 {
                    // Extract LSB from magnitude
                    mag := absInt(int(excitation[offset+i]))
                    lsb := mag & 1
                    e.rangeEncoder.EncodeICDF16(lsb, ICDFExcitationLSB, 8)
                }
            }
        }
    }

    // Encode LCG seed
    seed := e.computeLCGSeed(excitation)
    e.rangeEncoder.EncodeICDF16(seed, ICDFLCGSeed, 8)
}

// encodePulseDistribution encodes the binary split tree.
// Mirrors decoder's decodePulseDistribution exactly in reverse.
func (e *Encoder) encodePulseDistribution(pulses []int, totalPulses int) {
    if totalPulses == 0 || len(pulses) <= 1 {
        return
    }

    // Compute left count
    mid := len(pulses) / 2
    var leftCount int
    for i := 0; i < mid; i++ {
        leftCount += pulses[i]
    }

    // Encode left count using split ICDF
    splitIdx := totalPulses
    if splitIdx >= len(ICDFExcitationSplit) {
        splitIdx = len(ICDFExcitationSplit) - 1
    }
    icdf := ICDFExcitationSplit[splitIdx]

    // Clamp leftCount to valid range
    if leftCount > totalPulses {
        leftCount = totalPulses
    }
    e.rangeEncoder.EncodeICDF16(leftCount, icdf, 8)

    // Recurse
    rightCount := totalPulses - leftCount
    e.encodePulseDistribution(pulses[:mid], leftCount)
    e.encodePulseDistribution(pulses[mid:], rightCount)
}

// selectRateLevel selects the rate level that minimizes bits.
func (e *Encoder) selectRateLevel(pulseCounts []int, signalType int) int {
    // Simple heuristic: higher rate for higher pulse counts
    var totalPulses int
    for _, c := range pulseCounts {
        totalPulses += c
    }

    avgPulses := totalPulses / len(pulseCounts)

    if avgPulses < 2 {
        return 0
    } else if avgPulses < 4 {
        return 1
    } else if avgPulses < 6 {
        return 2
    }
    return 3
}

// computeLCGSeed computes seed for comfort noise generation.
func (e *Encoder) computeLCGSeed(excitation []int32) int {
    // Use hash of excitation as seed
    var hash int32
    for _, v := range excitation {
        hash ^= v
        hash = (hash << 5) | (hash >> 27)
    }
    return int(hash & 0x3) // 2-bit seed
}

// computeExcitation computes the LPC residual (excitation signal).
// excitation[n] = input[n] - sum(lpc[k] * input[n-k-1])
func (e *Encoder) computeExcitation(pcm []float32, lpcQ12 []int16, gain float32) []int32 {
    n := len(pcm)
    order := len(lpcQ12)
    excitation := make([]int32, n)

    for i := 0; i < n; i++ {
        // Compute LPC prediction
        var prediction float64
        for k := 0; k < order && i-k-1 >= 0; k++ {
            prediction += float64(lpcQ12[k]) * float64(pcm[i-k-1]) / 4096.0
        }

        // Residual = input - prediction, scaled by gain
        residual := float64(pcm[i]) - prediction
        if gain > 0 {
            residual /= float64(gain)
        }

        // Quantize to integer
        excitation[i] = int32(residual)
    }

    return excitation
}
```
  </action>
  <verify>
```bash
go build ./internal/silk/...
```
  </verify>
  <done>Shell coding excitation encoder implemented</done>
</task>

<task type="auto">
  <name>Task 2: Implement Stereo Encoding and Frame Pipeline</name>
  <files>internal/silk/stereo_encode.go, internal/silk/encode_frame.go</files>
  <action>
Create stereo encoding and the complete frame encoding pipeline:

**stereo_encode.go:**
```go
package silk

import "math"

// encodeStereo encodes stereo prediction weights.
// Per RFC 6716 Section 4.2.8.
func (e *Encoder) encodeStereo(left, right []float32) (mid []float32, side []float32, weights [2]int16) {
    n := len(left)
    mid = make([]float32, n)
    side = make([]float32, n)

    // Compute mid and side channels
    for i := 0; i < n; i++ {
        mid[i] = (left[i] + right[i]) / 2
        side[i] = (left[i] - right[i]) / 2
    }

    // Compute stereo prediction weights
    // side = w0 * mid + w1 * (mid_prev)
    // Simplified: just compute ratio
    var w0, w1 float64
    var midEnergy, crossEnergy float64

    for i := 0; i < n; i++ {
        midEnergy += float64(mid[i]) * float64(mid[i])
        crossEnergy += float64(side[i]) * float64(mid[i])
    }

    if midEnergy > 1e-10 {
        w0 = crossEnergy / midEnergy
    }
    w1 = 0 // Simplified: no inter-frame prediction

    // Clamp and quantize to Q13
    if w0 > 1.0 {
        w0 = 1.0
    }
    if w0 < -1.0 {
        w0 = -1.0
    }

    weights[0] = int16(w0 * 8192) // Q13
    weights[1] = int16(w1 * 8192)

    return mid, side, weights
}

// encodeStereoWeights encodes stereo prediction weights to bitstream.
// Per RFC 6716 Section 4.2.8.3.
func (e *Encoder) encodeStereoWeights(weights [2]int16) {
    // Delta coding from previous weights
    if e.haveEncoded {
        // Encode delta from previous
        delta0 := weights[0] - e.prevStereoWeights[0]
        delta1 := weights[1] - e.prevStereoWeights[1]

        // Quantize delta
        idx0 := e.quantizeStereoWeightDelta(delta0)
        idx1 := e.quantizeStereoWeightDelta(delta1)

        e.rangeEncoder.EncodeICDF16(idx0, ICDFStereoWeight, 8)
        e.rangeEncoder.EncodeICDF16(idx1, ICDFStereoWeight, 8)
    } else {
        // First frame: encode absolute
        idx0 := e.quantizeStereoWeight(weights[0])
        idx1 := e.quantizeStereoWeight(weights[1])

        e.rangeEncoder.EncodeICDF16(idx0, ICDFStereoWeight, 8)
        e.rangeEncoder.EncodeICDF16(idx1, ICDFStereoWeight, 8)
    }

    e.prevStereoWeights = weights
}

// quantizeStereoWeight quantizes absolute weight to index.
func (e *Encoder) quantizeStereoWeight(weight int16) int {
    // Map Q13 weight to index [0, N)
    // Simple linear quantization
    idx := int(weight+8192) * 15 / 16384
    if idx < 0 {
        idx = 0
    }
    if idx > 15 {
        idx = 15
    }
    return idx
}

// quantizeStereoWeightDelta quantizes weight delta to index.
func (e *Encoder) quantizeStereoWeightDelta(delta int16) int {
    // Map delta to index centered at 8
    idx := int(delta)/512 + 8
    if idx < 0 {
        idx = 0
    }
    if idx > 15 {
        idx = 15
    }
    return idx
}
```

**encode_frame.go:**
```go
package silk

import "gopus/internal/rangecoding"

// EncodeFrame encodes a complete SILK frame to bitstream.
// Returns encoded bytes.
func (e *Encoder) EncodeFrame(pcm []float32, vadFlag bool) []byte {
    config := GetBandwidthConfig(e.bandwidth)
    numSubframes := 4 // 20ms frame = 4 subframes

    // Allocate output buffer
    output := make([]byte, 256) // Max frame size
    e.rangeEncoder = &rangecoding.Encoder{}
    e.rangeEncoder.Init(output)

    // Step 1: Classify frame (VAD)
    var signalType, quantOffset int
    if vadFlag {
        signalType, quantOffset = e.classifyFrame(pcm)
    } else {
        signalType, quantOffset = 0, 0
    }

    // Step 2: Encode frame type
    e.encodeFrameType(vadFlag, signalType, quantOffset)

    // Step 3: Compute and encode gains
    gains := e.computeSubframeGains(pcm, numSubframes)
    e.encodeSubframeGains(gains, signalType, numSubframes)

    // Step 4: Compute LPC coefficients
    lpcQ12 := e.computeLPCFromFrame(pcm)

    // Step 5: Convert to LSF and quantize
    lsfQ15 := lpcToLSFEncode(lpcQ12)
    stage1Idx, residuals, interpIdx := e.quantizeLSF(lsfQ15, e.bandwidth, signalType)
    e.encodeLSF(stage1Idx, residuals, interpIdx, e.bandwidth, signalType)

    // Step 6: Pitch detection and LTP (voiced only)
    if signalType == 2 {
        pitchLags := e.detectPitch(pcm, numSubframes)
        e.encodePitchLags(pitchLags, numSubframes)

        ltpCoeffs := e.analyzeLTP(pcm, pitchLags, numSubframes)
        periodicity := 1
        if e.isPreviousFrameVoiced {
            periodicity = 2
        }
        e.encodeLTPCoeffs(ltpCoeffs, periodicity, numSubframes)
    }

    // Step 7: Compute and encode excitation per subframe
    subframeSamples := config.SubframeSamples
    for sf := 0; sf < numSubframes; sf++ {
        start := sf * subframeSamples
        end := start + subframeSamples
        subframe := pcm[start:end]

        // Compute excitation (LPC residual)
        excitation := e.computeExcitation(subframe, lpcQ12, gains[sf]/65536.0)
        e.encodeExcitation(excitation, signalType, quantOffset)
    }

    // Update state for next frame
    e.isPreviousFrameVoiced = (signalType == 2)
    copy(e.prevLSFQ15, lsfQ15)
    e.MarkEncoded()

    // Finalize encoding
    return e.rangeEncoder.Done()
}

// encodeFrameType encodes VAD flag, signal type, and quantization offset.
func (e *Encoder) encodeFrameType(vadFlag bool, signalType, quantOffset int) {
    if !vadFlag {
        // Inactive frame - encoded via VAD flag in packet header
        return
    }

    // Active frame: encode signal type and quant offset
    // idx = (signalType-1)*2 + quantOffset
    idx := (signalType-1)*2 + quantOffset
    e.rangeEncoder.EncodeICDF16(idx, ICDFFrameTypeVADActive, 8)
}
```
  </action>
  <verify>
```bash
go build ./internal/silk/...
```
  </verify>
  <done>Stereo encoding and frame encoding pipeline complete</done>
</task>

<task type="auto">
  <name>Task 3: Create Public API and Round-Trip Tests</name>
  <files>internal/silk/silk_encode.go, internal/silk/encode_test.go</files>
  <action>
Create public encoding API and round-trip verification tests:

**silk_encode.go:**
```go
package silk

// Encode encodes mono PCM audio to SILK frame.
// pcm: Input samples at encoder's configured sample rate
// vadFlag: True if frame contains voice activity
// Returns: Encoded SILK frame bytes
func Encode(pcm []float32, bandwidth Bandwidth, vadFlag bool) ([]byte, error) {
    enc := NewEncoder(bandwidth)
    return enc.EncodeFrame(pcm, vadFlag), nil
}

// EncodeStereo encodes stereo PCM audio to SILK frame.
// left, right: Input samples for each channel
// bandwidth: Target bandwidth
// vadFlag: True if frame contains voice activity
// Returns: Encoded SILK frame bytes for mid and side channels
func EncodeStereo(left, right []float32, bandwidth Bandwidth, vadFlag bool) ([]byte, error) {
    enc := NewEncoder(bandwidth)

    // Convert to mid-side
    mid, side, weights := enc.encodeStereo(left, right)

    // Encode stereo weights first
    enc.encodeStereoWeights(weights)

    // Encode mid channel
    midBytes := enc.EncodeFrame(mid, vadFlag)

    // Encode side channel (lower bit allocation)
    sideEnc := NewEncoder(bandwidth)
    sideBytes := sideEnc.EncodeFrame(side, vadFlag)

    // Combine (simplified - real implementation would interleave properly)
    result := make([]byte, len(midBytes)+len(sideBytes))
    copy(result, midBytes)
    copy(result[len(midBytes):], sideBytes)

    return result, nil
}

// EncoderState holds encoder state for streaming encoding.
type EncoderState struct {
    enc *Encoder
}

// NewEncoderState creates a new streaming encoder.
func NewEncoderState(bandwidth Bandwidth) *EncoderState {
    return &EncoderState{
        enc: NewEncoder(bandwidth),
    }
}

// EncodeFrame encodes a frame maintaining state across calls.
func (es *EncoderState) EncodeFrame(pcm []float32, vadFlag bool) ([]byte, error) {
    return es.enc.EncodeFrame(pcm, vadFlag), nil
}

// Reset resets encoder state for a new stream.
func (es *EncoderState) Reset() {
    es.enc.Reset()
}
```

**encode_test.go:**
```go
package silk

import (
    "math"
    "testing"
)

func TestEncodeFrameBasic(t *testing.T) {
    // Generate test signal
    config := GetBandwidthConfig(BandwidthWideband)
    pcm := make([]float32, config.FrameSamples)
    for i := range pcm {
        // 300 Hz sine wave
        pcm[i] = float32(math.Sin(2*math.Pi*300*float64(i)/float64(config.SampleRate))) * 10000
    }

    // Encode
    encoded, err := Encode(pcm, BandwidthWideband, true)
    if err != nil {
        t.Fatalf("Encode failed: %v", err)
    }

    // Verify we got output
    if len(encoded) == 0 {
        t.Error("Encode produced empty output")
    }

    // Verify output is not too large (reasonable for 20ms SILK frame)
    if len(encoded) > 250 {
        t.Errorf("Encoded frame too large: %d bytes", len(encoded))
    }
}

func TestEncodeDecodeRoundTrip(t *testing.T) {
    // Generate voiced test signal (300 Hz fundamental)
    config := GetBandwidthConfig(BandwidthWideband)
    original := make([]float32, config.FrameSamples)
    for i := range original {
        t := float64(i) / float64(config.SampleRate)
        // Voiced-like signal with harmonics
        original[i] = float32(
            math.Sin(2*math.Pi*300*t) +
            0.5*math.Sin(2*math.Pi*600*t) +
            0.3*math.Sin(2*math.Pi*900*t),
        ) * 10000
    }

    // Encode
    encoded, err := Encode(original, BandwidthWideband, true)
    if err != nil {
        t.Fatalf("Encode failed: %v", err)
    }

    // Decode using Phase 2 decoder
    decoded, err := Decode(encoded, BandwidthWideband)
    if err != nil {
        t.Fatalf("Decode failed: %v", err)
    }

    // Verify output length matches
    if len(decoded) != len(original) {
        t.Errorf("Decoded length %d != original length %d", len(decoded), len(original))
    }

    // Verify signals are correlated (not necessarily identical due to lossy compression)
    correlation := computeCorrelation(original, decoded)
    const minCorrelation = 0.5 // Expect at least 50% correlation

    if correlation < minCorrelation {
        t.Errorf("Poor round-trip quality: correlation = %.3f < %.3f", correlation, minCorrelation)
    }

    t.Logf("Round-trip correlation: %.3f", correlation)
}

func TestEncodeSilence(t *testing.T) {
    config := GetBandwidthConfig(BandwidthWideband)
    pcm := make([]float32, config.FrameSamples) // All zeros

    encoded, err := Encode(pcm, BandwidthWideband, false) // vadFlag=false for silence
    if err != nil {
        t.Fatalf("Encode silence failed: %v", err)
    }

    // Silence should encode to small frame
    if len(encoded) > 50 {
        t.Errorf("Silence frame too large: %d bytes", len(encoded))
    }
}

func TestEncodeStreaming(t *testing.T) {
    config := GetBandwidthConfig(BandwidthWideband)
    es := NewEncoderState(BandwidthWideband)

    // Encode multiple frames
    for frame := 0; frame < 5; frame++ {
        pcm := make([]float32, config.FrameSamples)
        for i := range pcm {
            t := float64(i+frame*config.FrameSamples) / float64(config.SampleRate)
            pcm[i] = float32(math.Sin(2*math.Pi*400*t)) * 10000
        }

        encoded, err := es.EncodeFrame(pcm, true)
        if err != nil {
            t.Fatalf("Frame %d encode failed: %v", frame, err)
        }

        if len(encoded) == 0 {
            t.Errorf("Frame %d produced empty output", frame)
        }
    }
}

func computeCorrelation(a, b []float32) float64 {
    n := len(a)
    if len(b) < n {
        n = len(b)
    }

    var sumAB, sumA2, sumB2 float64
    for i := 0; i < n; i++ {
        sumAB += float64(a[i]) * float64(b[i])
        sumA2 += float64(a[i]) * float64(a[i])
        sumB2 += float64(b[i]) * float64(b[i])
    }

    if sumA2 < 1e-10 || sumB2 < 1e-10 {
        return 0
    }

    return sumAB / math.Sqrt(sumA2*sumB2)
}
```
  </action>
  <verify>
```bash
go test -v -run "TestEncode" ./internal/silk/...
```
  </verify>
  <done>Public API complete, round-trip tests pass with reasonable correlation</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
go test -v ./internal/silk/...

# Full test suite including round-trip
go test -v -run "Test" ./internal/silk/...

# Package builds
go build ./internal/silk/...
go build ./...
```
</verification>

<success_criteria>
1. Shell coding excitation encoder produces decodable output
2. Stereo encoding computes valid mid-side weights
3. Frame encoding pipeline produces valid SILK bitstream
4. Encode/EncodeStereo public API works
5. Round-trip through decoder produces correlated output (>50% correlation)
6. Multiple frames can be encoded in sequence (streaming)
7. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-silk-encoder/06-05-SUMMARY.md`
</output>
