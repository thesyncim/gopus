---
phase: 06-silk-encoder
plan: 04
type: execute
wave: 3
depends_on: ["06-02"]
files_modified:
  - internal/silk/gain_encode.go
  - internal/silk/lsf_quantize.go
  - internal/silk/gain_encode_test.go
autonomous: true

must_haves:
  truths:
    - "Gain quantization produces valid indices decodable by decoder"
    - "LSF quantization uses two-stage VQ with rate-distortion optimization"
    - "Quantized LSF values produce stable LPC coefficients"
  artifacts:
    - path: "internal/silk/gain_encode.go"
      provides: "Gain quantization with first-frame and delta coding"
      exports: ["encodeSubframeGains", "computeGainIndex"]
    - path: "internal/silk/lsf_quantize.go"
      provides: "Two-stage LSF quantization with codebook search"
      exports: ["quantizeLSF", "encodeLSF"]
  key_links:
    - from: "internal/silk/gain_encode.go"
      to: "internal/silk/tables.go"
      via: "GainDequantTable for validation"
      pattern: "GainDequantTable"
    - from: "internal/silk/lsf_quantize.go"
      to: "internal/silk/codebook.go"
      via: "LSF codebook search"
      pattern: "LSFCodebook"
---

<objective>
Implement gain quantization and LSF quantization for SILK encoding.

Purpose: Gain quantization converts computed subframe gains to indices using the same scheme as the decoder. LSF quantization uses two-stage vector quantization with rate-distortion optimization to encode LPC coefficients efficiently.

Output:
- Gain quantization with first-frame limiting and delta coding
- Two-stage LSF quantization with codebook search
- Rate-distortion optimized codebook selection
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-silk-encoder/06-RESEARCH.md
@.planning/phases/06-silk-encoder/06-02-SUMMARY.md

# Reference decoder's gain and LSF handling for compatibility
@internal/silk/gain.go
@internal/silk/lsf.go
@internal/silk/codebook.go
@internal/silk/tables.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Gain Quantization</name>
  <files>internal/silk/gain_encode.go</files>
  <action>
Create gain quantization that mirrors decoder's gain decoding:

```go
package silk

import "math"

// encodeSubframeGains quantizes and encodes gains for all subframes.
// First subframe is absolute (MSB + LSB), subsequent are delta-coded.
// Per RFC 6716 Section 4.2.7.4.
func (e *Encoder) encodeSubframeGains(gains []float32, signalType, numSubframes int) {
    // Convert gains to log domain and quantize
    logGains := make([]int, numSubframes)
    for i := 0; i < numSubframes; i++ {
        logGains[i] = computeLogGainIndex(gains[i])
    }

    // First subframe: encode absolute gain
    firstLogGain := logGains[0]

    // Apply first-frame gain limiter if this is first frame
    if !e.haveEncoded {
        // Per RFC 6716 Section 4.2.7.4.1:
        // gainIndex = logGain + 2*max(0, logGain - 16) for first frame
        // So we need to reverse: given logGain, find gainIndex
        gainIndex := e.computeFirstFrameGainIndex(firstLogGain)
        e.encodeFirstGainIndex(gainIndex, signalType)
    } else {
        // Delta from previous frame's log gain
        // gainIndex = logGain - prevLogGain + 16
        gainIndex := firstLogGain - int(e.previousLogGain) + 16
        if gainIndex < 0 {
            gainIndex = 0
        }
        if gainIndex > 31 {
            gainIndex = 31
        }
        e.encodeFirstGainIndex(gainIndex, signalType)
    }

    // Subsequent subframes: delta-coded
    prevLogGain := firstLogGain
    for i := 1; i < numSubframes; i++ {
        // Delta = logGain - prevLogGain + 4
        delta := logGains[i] - prevLogGain + 4
        if delta < 0 {
            delta = 0
        }
        if delta > 15 {
            delta = 15
        }

        e.rangeEncoder.EncodeICDF16(delta, ICDFDeltaGain, 8)
        prevLogGain += delta - 4 // Update for next iteration
    }

    // Update state for next frame
    e.previousLogGain = int32(prevLogGain)
}

// computeLogGainIndex converts linear gain to log gain index [0, 63].
// Inverse of GainDequantTable lookup.
func computeLogGainIndex(gain float32) int {
    // GainDequantTable maps [0, 63] to Q16 gain values
    // We need to find the closest index

    gainQ16 := int32(gain * 65536)

    bestIdx := 0
    bestDist := int32(math.MaxInt32)

    for idx := 0; idx < 64; idx++ {
        dist := absInt32(GainDequantTable[idx] - gainQ16)
        if dist < bestDist {
            bestDist = dist
            bestIdx = idx
        }
    }

    return bestIdx
}

// computeFirstFrameGainIndex computes gain index for first frame encoding.
// Reverses the limiter: logGain = max(0, gainIndex - 2*max(0, gainIndex - 16))
func (e *Encoder) computeFirstFrameGainIndex(targetLogGain int) int {
    // Search for gainIndex that produces targetLogGain after limiter
    for gainIndex := 0; gainIndex <= 63; gainIndex++ {
        var logGain int
        if gainIndex > 16 {
            logGain = gainIndex - 2*(gainIndex-16)
        } else {
            logGain = gainIndex
        }
        if logGain < 0 {
            logGain = 0
        }

        if logGain == targetLogGain {
            return gainIndex
        }
    }
    return targetLogGain // Fallback
}

// encodeFirstGainIndex encodes the absolute gain index for first subframe.
func (e *Encoder) encodeFirstGainIndex(gainIndex, signalType int) {
    // Split into MSB (0-7) and LSB (0-7)
    msb := gainIndex / 8
    lsb := gainIndex % 8

    // Select MSB table based on signal type
    switch signalType {
    case 0: // Inactive
        e.rangeEncoder.EncodeICDF16(msb, ICDFGainMSBInactive, 8)
    case 1: // Unvoiced
        e.rangeEncoder.EncodeICDF16(msb, ICDFGainMSBUnvoiced, 8)
    case 2: // Voiced
        e.rangeEncoder.EncodeICDF16(msb, ICDFGainMSBVoiced, 8)
    }

    // Encode LSB
    e.rangeEncoder.EncodeICDF16(lsb, ICDFGainLSB, 8)
}

// computeSubframeGains computes gains for each subframe from PCM.
// Returns gains in linear domain.
func (e *Encoder) computeSubframeGains(pcm []float32, numSubframes int) []float32 {
    subframeSamples := len(pcm) / numSubframes
    gains := make([]float32, numSubframes)

    for sf := 0; sf < numSubframes; sf++ {
        start := sf * subframeSamples
        end := start + subframeSamples

        // Compute RMS energy
        var energy float64
        for i := start; i < end; i++ {
            energy += float64(pcm[i]) * float64(pcm[i])
        }
        energy /= float64(subframeSamples)

        // Convert to gain (scale factor for unit energy)
        if energy > 0 {
            gains[sf] = float32(math.Sqrt(energy))
        } else {
            gains[sf] = 1.0 // Minimum gain
        }
    }

    return gains
}

func absInt32(x int32) int32 {
    if x < 0 {
        return -x
    }
    return x
}
```
  </action>
  <verify>
```bash
go build ./internal/silk/...
```
  </verify>
  <done>Gain quantization produces valid indices with first-frame limiting and delta coding</done>
</task>

<task type="auto">
  <name>Task 2: Implement Two-Stage LSF Quantization</name>
  <files>internal/silk/lsf_quantize.go</files>
  <action>
Create two-stage LSF quantization with rate-distortion optimization:

```go
package silk

import "math"

// quantizeLSF quantizes LSF coefficients using two-stage VQ.
// Returns stage1 index, stage2 residuals, and interpolation index.
// Per RFC 6716 Section 4.2.7.5.
func (e *Encoder) quantizeLSF(lsfQ15 []int16, bandwidth Bandwidth, signalType int) (int, []int, int) {
    isWideband := bandwidth == BandwidthWideband
    isVoiced := signalType == 2
    lpcOrder := len(lsfQ15)

    // Select codebook based on bandwidth
    var codebook [][16]uint8
    if isWideband {
        codebook = LSFCodebookWB[:]
    } else {
        codebook = LSFCodebookNBMB[:]
    }

    // Stage 1: Find best codebook entry with rate-distortion optimization
    bestStage1, bestDist := e.searchStage1Codebook(lsfQ15, codebook, isWideband, isVoiced, lpcOrder)

    // Stage 2: Compute and quantize residuals
    residuals := e.computeStage2Residuals(lsfQ15, codebook[bestStage1][:lpcOrder], bestStage1, isWideband, lpcOrder)

    // Compute interpolation index (blend with previous frame)
    interpIdx := e.computeInterpolationIndex(lsfQ15, lpcOrder)

    return bestStage1, residuals, interpIdx
}

// searchStage1Codebook finds the best stage 1 codebook entry.
// Uses weighted distortion with rate cost.
func (e *Encoder) searchStage1Codebook(lsfQ15 []int16, codebook [][16]uint8, isWideband, isVoiced bool, lpcOrder int) (int, int64) {
    // Lambda for rate-distortion tradeoff
    const lambda = 1.0

    // Select ICDF for rate calculation
    var icdf []uint16
    if isWideband {
        if isVoiced {
            icdf = ICDFLSFStage1WBVoiced
        } else {
            icdf = ICDFLSFStage1WBUnvoiced
        }
    } else {
        if isVoiced {
            icdf = ICDFLSFStage1NBMBVoiced
        } else {
            icdf = ICDFLSFStage1NBMBUnvoiced
        }
    }

    bestIdx := 0
    var bestCost int64 = math.MaxInt64

    for idx := 0; idx < len(codebook); idx++ {
        // Compute weighted distortion
        var dist int64
        for i := 0; i < lpcOrder; i++ {
            target := int64(lsfQ15[i])
            cbVal := int64(codebook[idx][i]) << 7 // Scale to Q15

            diff := target - cbVal
            // Perceptual weighting (higher weight at formant frequencies)
            weight := e.computeLSFWeight(i, lpcOrder)
            dist += (diff * diff * int64(weight)) >> 8
        }

        // Add rate cost from ICDF
        rate := e.computeSymbolRate(idx, icdf)

        totalCost := dist + int64(lambda*float64(rate))

        if totalCost < bestCost {
            bestCost = totalCost
            bestIdx = idx
        }
    }

    return bestIdx, bestCost
}

// computeStage2Residuals computes stage 2 residual indices.
func (e *Encoder) computeStage2Residuals(lsfQ15 []int16, stage1 []uint8, stage1Idx int, isWideband bool, lpcOrder int) []int {
    residuals := make([]int, lpcOrder)
    mapIdx := stage1Idx >> 2 // Maps 0-31 to 0-7

    // Select residual codebook
    var resCodebook [][][]int8
    if isWideband {
        resCodebook = LSFStage2ResWB
    } else {
        resCodebook = LSFStage2ResNBMB
    }

    for i := 0; i < lpcOrder; i++ {
        target := int(lsfQ15[i]) - int(stage1[i])<<7

        // Find best residual quantizer
        bestRes := 0
        bestDist := int(math.MaxInt32)

        for resIdx := 0; resIdx < len(resCodebook[mapIdx]); resIdx++ {
            if i >= len(resCodebook[mapIdx][resIdx]) {
                continue
            }
            resVal := int(resCodebook[mapIdx][resIdx][i]) << 7
            dist := absInt(target - resVal)
            if dist < bestDist {
                bestDist = dist
                bestRes = resIdx
            }
        }

        residuals[i] = bestRes
    }

    return residuals
}

// computeLSFWeight computes perceptual weight for LSF coefficient.
// Higher weight near formant frequencies.
func (e *Encoder) computeLSFWeight(idx, order int) int {
    // Simple weighting: higher in mid-range (formant region)
    midIdx := order / 2
    dist := absInt(idx - midIdx)
    weight := 256 - dist*16
    if weight < 64 {
        weight = 64
    }
    return weight
}

// computeSymbolRate estimates bit cost from ICDF probabilities.
func (e *Encoder) computeSymbolRate(symbol int, icdf []uint16) int {
    if symbol >= len(icdf) {
        return 256 // Max cost
    }

    // Rate ~ -log2(probability)
    var prob uint16
    if symbol == 0 {
        prob = 256 - icdf[0]
    } else if symbol < len(icdf) {
        prob = icdf[symbol-1] - icdf[symbol]
    } else {
        prob = 1
    }

    if prob == 0 {
        return 256
    }

    // Approximate -log2(prob/256) * 8 (in 1/8 bits)
    // log2(256/prob) = 8 - log2(prob)
    rate := 8*8 - int(math.Log2(float64(prob))*8)
    return rate
}

// computeInterpolationIndex determines blend with previous frame LSF.
// Per RFC 6716 Section 4.2.7.5.3.
func (e *Encoder) computeInterpolationIndex(lsfQ15 []int16, order int) int {
    // Compare current LSF with previous frame
    if !e.haveEncoded {
        return 4 // No interpolation for first frame
    }

    var diff int64
    for i := 0; i < order && i < len(e.prevLSFQ15); i++ {
        d := int64(lsfQ15[i]) - int64(e.prevLSFQ15[i])
        diff += d * d
    }

    // Thresholds for interpolation levels
    rms := math.Sqrt(float64(diff) / float64(order))

    // More interpolation (smaller index) for smoother transitions
    if rms < 500 {
        return 0 // Heavy interpolation
    } else if rms < 1000 {
        return 1
    } else if rms < 2000 {
        return 2
    } else if rms < 4000 {
        return 3
    }
    return 4 // No interpolation
}

// encodeLSF encodes quantized LSF to bitstream.
func (e *Encoder) encodeLSF(stage1Idx int, residuals []int, interpIdx int, bandwidth Bandwidth, signalType int) {
    isWideband := bandwidth == BandwidthWideband
    isVoiced := signalType == 2
    lpcOrder := len(residuals)

    // Encode stage 1 index
    if isWideband {
        if isVoiced {
            e.rangeEncoder.EncodeICDF16(stage1Idx, ICDFLSFStage1WBVoiced, 8)
        } else {
            e.rangeEncoder.EncodeICDF16(stage1Idx, ICDFLSFStage1WBUnvoiced, 8)
        }
    } else {
        if isVoiced {
            e.rangeEncoder.EncodeICDF16(stage1Idx, ICDFLSFStage1NBMBVoiced, 8)
        } else {
            e.rangeEncoder.EncodeICDF16(stage1Idx, ICDFLSFStage1NBMBUnvoiced, 8)
        }
    }

    // Encode stage 2 residuals
    mapIdx := stage1Idx >> 2
    for i := 0; i < lpcOrder; i++ {
        var icdf []uint16
        if isWideband {
            icdf = ICDFLSFStage2WB[mapIdx]
        } else {
            icdf = ICDFLSFStage2NBMB[mapIdx]
        }
        e.rangeEncoder.EncodeICDF16(residuals[i], icdf, 8)
    }

    // Encode interpolation index
    e.rangeEncoder.EncodeICDF16(interpIdx, ICDFLSFInterpolation, 8)
}
```
  </action>
  <verify>
```bash
go build ./internal/silk/...
```
  </verify>
  <done>Two-stage LSF quantization with rate-distortion optimization</done>
</task>

<task type="auto">
  <name>Task 3: Create Gain and LSF Quantization Tests</name>
  <files>internal/silk/gain_encode_test.go</files>
  <action>
Create tests verifying encoder-decoder compatibility:

```go
package silk

import (
    "testing"
)

func TestComputeLogGainIndex(t *testing.T) {
    // Test that computeLogGainIndex is inverse of GainDequantTable
    for idx := 0; idx < 64; idx++ {
        gainQ16 := GainDequantTable[idx]
        gainFloat := float32(gainQ16) / 65536.0

        computedIdx := computeLogGainIndex(gainFloat)

        // Allow +/- 1 for rounding
        if absInt(computedIdx-idx) > 1 {
            t.Errorf("idx=%d: gainQ16=%d, computed idx=%d", idx, gainQ16, computedIdx)
        }
    }
}

func TestGainEncodeDecode(t *testing.T) {
    // Test that encoded gains produce same decoded values
    enc := NewEncoder(BandwidthWideband)
    dec := NewDecoder()

    // Test gains for various signal types
    testCases := []struct {
        gains      []float32
        signalType int
    }{
        {[]float32{1000, 1200, 1100, 1150}, 2}, // Voiced
        {[]float32{500, 600, 550, 580}, 1},     // Unvoiced
        {[]float32{100, 100, 100, 100}, 0},     // Inactive
    }

    for _, tc := range testCases {
        // Convert to Q16 for comparison
        expectedQ16 := make([]int32, len(tc.gains))
        for i, g := range tc.gains {
            expectedQ16[i] = int32(g * 65536)
        }

        // Quantize gains
        logGains := make([]int, len(tc.gains))
        for i, g := range tc.gains {
            logGains[i] = computeLogGainIndex(g)
        }

        // Dequantize using decoder's table
        for i, logGain := range logGains {
            decodedQ16 := GainDequantTable[logGain]
            // Allow 20% error due to quantization
            ratio := float64(decodedQ16) / float64(expectedQ16[i])
            if ratio < 0.5 || ratio > 2.0 {
                t.Errorf("signalType=%d, sf=%d: expected ~%d, got %d",
                    tc.signalType, i, expectedQ16[i], decodedQ16)
            }
        }
    }

    _ = dec // Avoid unused variable warning
}

func TestQuantizeLSF(t *testing.T) {
    enc := NewEncoder(BandwidthWideband)
    config := GetBandwidthConfig(BandwidthWideband)

    // Create test LSF (evenly spaced)
    lsfQ15 := make([]int16, config.LPCOrder)
    for i := 0; i < config.LPCOrder; i++ {
        lsfQ15[i] = int16((i + 1) * 32767 / (config.LPCOrder + 1))
    }

    stage1Idx, residuals, interpIdx := enc.quantizeLSF(lsfQ15, BandwidthWideband, 2)

    // Verify stage1 index is valid
    if stage1Idx < 0 || stage1Idx >= 32 {
        t.Errorf("invalid stage1Idx: %d", stage1Idx)
    }

    // Verify residuals count
    if len(residuals) != config.LPCOrder {
        t.Errorf("expected %d residuals, got %d", config.LPCOrder, len(residuals))
    }

    // Verify interpolation index
    if interpIdx < 0 || interpIdx > 4 {
        t.Errorf("invalid interpIdx: %d", interpIdx)
    }
}

func TestLSFEncodeDecode(t *testing.T) {
    // This test would require full encode-decode round trip
    // For now, verify the quantization produces valid indices

    enc := NewEncoder(BandwidthNarrowband)
    config := GetBandwidthConfig(BandwidthNarrowband)

    // Test LSF
    lsfQ15 := make([]int16, config.LPCOrder)
    for i := 0; i < config.LPCOrder; i++ {
        lsfQ15[i] = int16(3000 + i*2500) // Spaced LSF values
    }

    stage1Idx, residuals, _ := enc.quantizeLSF(lsfQ15, BandwidthNarrowband, 1)

    // Reconstruct LSF from quantized values
    reconstructed := make([]int16, config.LPCOrder)
    mapIdx := stage1Idx >> 2

    for i := 0; i < config.LPCOrder; i++ {
        base := int32(LSFCodebookNBMB[stage1Idx][i]) << 7
        res := int32(LSFStage2ResNBMB[mapIdx][residuals[i]][i]) << 7
        reconstructed[i] = int16(base + res)
    }

    // Verify reconstruction is close to original
    for i := 0; i < config.LPCOrder; i++ {
        diff := absInt(int(lsfQ15[i]) - int(reconstructed[i]))
        // Allow 10% of range error
        if diff > 3000 {
            t.Errorf("LSF[%d]: original=%d, reconstructed=%d, diff=%d",
                i, lsfQ15[i], reconstructed[i], diff)
        }
    }
}
```
  </action>
  <verify>
```bash
go test -v -run "TestComputeLogGain|TestGainEncode|TestQuantizeLSF|TestLSFEncode" ./internal/silk/...
```
  </verify>
  <done>All gain and LSF quantization tests pass</done>
</task>

</tasks>

<verification>
```bash
# All tests pass
go test -v ./internal/silk/...

# Package builds
go build ./internal/silk/...
```
</verification>

<success_criteria>
1. Gain quantization finds correct index from GainDequantTable
2. First-frame gain limiting applied correctly
3. Delta gain coding produces valid indices [0, 15]
4. LSF stage 1 search finds best codebook entry
5. LSF stage 2 quantizes residuals correctly
6. Rate-distortion optimization considers bit cost
7. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-silk-encoder/06-04-SUMMARY.md`
</output>
