//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"flag"
	"fmt"
	"math/bits"
	"os"
)

const bitexactThetaMax = 16384

func fracMul16(a, b int) int {
	return int((16384 + int32(int16(a))*int32(int16(b))) >> 15)
}

func bitexactCosCalc(x int) int {
	tmp := (4096 + int32(x)*int32(x)) >> 13
	x2 := int(tmp)
	x2 = (32767 - x2) + fracMul16(x2, (-7651+fracMul16(x2, (8277+fracMul16(-626, x2)))))
	return 1 + x2
}

func ilog32(x uint32) int {
	return bits.Len32(x)
}

func bitexactLog2tanCalc(isin, icos int) int {
	lc := ilog32(uint32(icos))
	ls := ilog32(uint32(isin))
	if lc > 15 {
		lc = 15
	}
	if ls > 15 {
		ls = 15
	}
	icos <<= 15 - lc
	isin <<= 15 - ls
	return (ls-lc)*(1<<11) + fracMul16(isin, fracMul16(isin, -2597)+7932) - fracMul16(icos, fracMul16(icos, -2597)+7932)
}

func emitIntArray(w *bufio.Writer, name string, vals []int) {
	fmt.Fprintf(w, "var %s = [bitexactThetaMax + 1]int{\n", name)
	for i, v := range vals {
		if i%8 == 0 {
			fmt.Fprint(w, "\t")
		}
		fmt.Fprintf(w, "%d,", v)
		if i%8 == 7 || i == len(vals)-1 {
			fmt.Fprint(w, "\n")
		} else {
			fmt.Fprint(w, " ")
		}
	}
	fmt.Fprint(w, "}\n\n")
}

func main() {
	out := flag.String("out", "celt/math_utils_tables_static.go", "output file path")
	flag.Parse()

	cos := make([]int, bitexactThetaMax+1)
	log2tan := make([]int, bitexactThetaMax+1)

	for i := 0; i <= bitexactThetaMax; i++ {
		cos[i] = bitexactCosCalc(i)
	}
	for i := 1; i < bitexactThetaMax; i++ {
		isin := cos[bitexactThetaMax-i]
		icos := cos[i]
		log2tan[i] = bitexactLog2tanCalc(isin, icos)
	}

	f, err := os.Create(*out)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to create %s: %v\n", *out, err)
		os.Exit(1)
	}
	defer f.Close()

	w := bufio.NewWriter(f)
	defer w.Flush()

	fmt.Fprintln(w, "// Code generated by tools/gen_math_utils_tables.go; DO NOT EDIT.")
	fmt.Fprintln(w, "package celt")
	fmt.Fprintln(w)
	emitIntArray(w, "bitexactCosTable", cos)
	emitIntArray(w, "bitexactLog2tanThetaTable", log2tan)
}
