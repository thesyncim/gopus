// Package celt provides tests to validate energy decoding against libopus.
// This file validates coarse energy, fine energy, and energy finalise functions.
package celt

/*
#cgo CFLAGS: -I${SRCDIR}/../../tmp_check/opus-1.6.1/include -I${SRCDIR}/../../tmp_check/opus-1.6.1/celt -I${SRCDIR}/../../tmp_check/opus-1.6.1 -DHAVE_CONFIG_H
#cgo LDFLAGS: -L${SRCDIR}/../../tmp_check/opus-1.6.1/.libs -lopus -lm

#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "opus.h"
#include "celt.h"
#include "entdec.h"
#include "laplace.h"

// Expose the probability model (copied from quant_bands.c)
static const unsigned char e_prob_model_local[4][2][42] = {
   // 120 sample frames (LM=0)
   {
      // Inter
      {
          72, 127,  65, 129,  66, 128,  65, 128,  64, 128,  62, 128,  64, 128,
          64, 128,  92,  78,  92,  79,  92,  78,  90,  79, 116,  41, 115,  40,
         114,  40, 132,  26, 132,  26, 145,  17, 161,  12, 176,  10, 177,  11
      },
      // Intra
      {
          24, 179,  48, 138,  54, 135,  54, 132,  53, 134,  56, 133,  55, 132,
          55, 132,  61, 114,  70,  96,  74,  88,  75,  88,  87,  74,  89,  66,
          91,  67, 100,  59, 108,  50, 120,  40, 122,  37,  97,  43,  78,  50
      }
   },
   // 240 sample frames (LM=1)
   {
      // Inter
      {
          83,  78,  84,  81,  88,  75,  86,  74,  87,  71,  90,  73,  93,  74,
          93,  74, 109,  40, 114,  36, 117,  34, 117,  34, 143,  17, 145,  18,
         146,  19, 162,  12, 165,  10, 178,   7, 189,   6, 190,   8, 177,   9
      },
      // Intra
      {
          23, 178,  54, 115,  63, 102,  66,  98,  69,  99,  74,  89,  71,  91,
          73,  91,  78,  89,  86,  80,  92,  66,  93,  64, 102,  59, 103,  60,
         104,  60, 117,  52, 123,  44, 138,  35, 133,  31,  97,  38,  77,  45
      }
   },
   // 480 sample frames (LM=2)
   {
      // Inter
      {
          61,  90,  93,  60, 105,  42, 107,  41, 110,  45, 116,  38, 113,  38,
         112,  38, 124,  26, 132,  27, 136,  19, 140,  20, 155,  14, 159,  16,
         158,  18, 170,  13, 177,  10, 187,   8, 192,   6, 175,   9, 159,  10
      },
      // Intra
      {
          21, 178,  59, 110,  71,  86,  75,  85,  84,  83,  91,  66,  88,  73,
          87,  72,  92,  75,  98,  72, 105,  58, 107,  54, 115,  52, 114,  55,
         112,  56, 129,  51, 132,  40, 150,  33, 140,  29,  98,  35,  77,  42
      }
   },
   // 960 sample frames (LM=3)
   {
      // Inter
      {
          42, 121,  96,  66, 108,  43, 111,  40, 117,  44, 123,  32, 120,  36,
         119,  33, 127,  33, 134,  34, 139,  21, 147,  23, 152,  20, 158,  25,
         154,  26, 166,  21, 173,  16, 184,  13, 184,  10, 150,  13, 139,  15
      },
      // Intra
      {
          22, 178,  63, 114,  74,  82,  84,  83,  92,  82, 103,  62,  96,  72,
          96,  67, 101,  73, 107,  72, 113,  55, 118,  52, 125,  52, 118,  52,
         117,  55, 135,  49, 137,  39, 157,  32, 145,  29,  97,  33,  77,  40
      }
   }
};

// Prediction coefficients for float build
static const float pred_coef_float[4] = {29440.f/32768.f, 26112.f/32768.f, 21248.f/32768.f, 16384.f/32768.f};
static const float beta_coef_float[4] = {30147.f/32768.f, 22282.f/32768.f, 12124.f/32768.f, 6554.f/32768.f};
static const float beta_intra_float = 4915.f/32768.f;

// Small energy ICDF
static const unsigned char small_energy_icdf_local[3] = {2, 1, 0};

// Test harness for coarse energy decoding
// Returns 0 on success, -1 on error
int test_unquant_coarse_energy(
    const unsigned char *data, int data_len,
    int start, int end, int intra, int C, int LM,
    float *prev_energy,  // [end * C] input/output
    float *out_energy,   // [end * C] output
    int *out_qi          // [end * C] output quantizer indices
) {
    ec_dec dec;
    ec_dec_init(&dec, (unsigned char*)data, data_len);

    const unsigned char *prob_model = e_prob_model_local[LM][intra];
    float prev[2] = {0, 0};
    float coef, beta;

    if (intra) {
        coef = 0;
        beta = beta_intra_float;
    } else {
        coef = pred_coef_float[LM];
        beta = beta_coef_float[LM];
    }

    int budget = data_len * 8;

    for (int i = start; i < end; i++) {
        for (int c = 0; c < C; c++) {
            int qi;
            float q;
            int tell = ec_tell(&dec);

            if (budget - tell >= 15) {
                int pi = 2 * (i < 20 ? i : 20);
                qi = ec_laplace_decode(&dec, prob_model[pi] << 7, prob_model[pi+1] << 6);
            } else if (budget - tell >= 2) {
                qi = ec_dec_icdf(&dec, small_energy_icdf_local, 2);
                qi = (qi >> 1) ^ -(qi & 1);
            } else if (budget - tell >= 1) {
                qi = -ec_dec_bit_logp(&dec, 1);
            } else {
                qi = -1;
            }

            // Store quantizer index
            if (out_qi != NULL) {
                out_qi[i + c * end] = qi;
            }

            // Clamp previous energy to -9
            float oldE = prev_energy[i + c * end];
            if (oldE < -9.0f) oldE = -9.0f;

            // Compute energy
            q = (float)qi;  // In float mode, q = qi (DB_SHIFT = 0 effectively)
            float tmp = coef * oldE + prev[c] + q;

            // Store output
            out_energy[i + c * end] = tmp;

            // Update prev for next band
            prev[c] = prev[c] + q - beta * q;

            // Update prev_energy for next frame (in-place)
            prev_energy[i + c * end] = tmp;
        }
    }

    return 0;
}

// Test harness for fine energy decoding
int test_unquant_fine_energy(
    const unsigned char *data, int data_len, int tell_offset,
    int start, int end, int C,
    int *extra_quant,   // [end] fine bits per band
    int *prev_quant,    // [end] previous quant bits (can be NULL)
    float *energy       // [end * C] input/output
) {
    ec_dec dec;
    ec_dec_init(&dec, (unsigned char*)data, data_len);

    // Skip to tell_offset
    // Note: In a real scenario, we'd need to actually decode to this point
    // For testing, we assume the decoder is at the right position

    for (int i = start; i < end; i++) {
        int extra = extra_quant[i];
        if (extra <= 0) continue;
        if (ec_tell(&dec) + C * extra > data_len * 8) continue;

        int prev = (prev_quant != NULL) ? prev_quant[i] : 0;

        for (int c = 0; c < C; c++) {
            int q2 = ec_dec_bits(&dec, extra);
            float offset = (q2 + 0.5f) * (1 << (14 - extra)) * (1.f / 16384) - 0.5f;
            offset *= (1 << (14 - prev)) * (1.f / 16384);
            energy[i + c * end] += offset;
        }
    }

    return 0;
}

// Test harness for energy finalise
int test_unquant_energy_finalise(
    const unsigned char *data, int data_len, int tell_offset,
    int start, int end, int C,
    int *fine_quant,     // [end] fine bits allocated
    int *fine_priority,  // [end] priority (0 or 1)
    int bits_left,
    float *energy        // [end * C] input/output
) {
    ec_dec dec;
    ec_dec_init(&dec, (unsigned char*)data, data_len);

    // Skip to tell_offset (simplified - in reality need proper seek)

    for (int prio = 0; prio < 2; prio++) {
        for (int i = start; i < end && bits_left >= C; i++) {
            if (fine_quant[i] >= 8 || fine_priority[i] != prio)
                continue;

            for (int c = 0; c < C; c++) {
                int q2 = ec_dec_bits(&dec, 1);
                float offset = (q2 - 0.5f) * (1 << (14 - fine_quant[i] - 1)) * (1.f / 16384);
                energy[i + c * end] += offset;
                bits_left--;
            }
        }
    }

    return 0;
}

// Decode a single Laplace symbol for validation
int test_laplace_decode(const unsigned char *data, int data_len, int fs, int decay, int *out_val) {
    ec_dec dec;
    ec_dec_init(&dec, (unsigned char*)data, data_len);
    *out_val = ec_laplace_decode(&dec, fs, decay);
    return 0;
}

// Get range coder state after init
void test_get_range_state(const unsigned char *data, int data_len, unsigned int *out_rng, unsigned int *out_val) {
    ec_dec dec;
    ec_dec_init(&dec, (unsigned char*)data, data_len);
    *out_rng = dec.rng;
    *out_val = dec.val;
}

*/
import "C"

import (
	"math"
	"testing"
	"unsafe"

	"github.com/thesyncim/gopus/internal/rangecoding"
)

// TestLaplaceDecodeVsLibopus validates Laplace decoding against libopus
func TestLaplaceDecodeVsLibopus(t *testing.T) {
	testCases := []struct {
		name  string
		data  []byte
		fs    int
		decay int
	}{
		{"typical_1", []byte{0xCF, 0xC5, 0x88, 0x30, 0x00, 0x00, 0x00, 0x00}, 72 << 7, 127 << 6},
		{"typical_2", []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0}, 72 << 7, 127 << 6},
		{"zeros", []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 72 << 7, 127 << 6},
		{"ones", []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, 72 << 7, 127 << 6},
		{"lm0_inter", []byte{0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89}, 72 << 7, 127 << 6},
		{"lm3_intra", []byte{0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA}, 22 << 7, 178 << 6},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Decode with libopus
			var libopusVal C.int
			cData := (*C.uchar)(unsafe.Pointer(&tc.data[0]))
			C.test_laplace_decode(cData, C.int(len(tc.data)), C.int(tc.fs), C.int(tc.decay), &libopusVal)

			// Decode with gopus
			d := NewDecoder(1)
			rd := &rangecoding.Decoder{}
			rd.Init(tc.data)
			d.SetRangeDecoder(rd)
			gopusVal := d.decodeLaplace(tc.fs, tc.decay)

			if gopusVal != int(libopusVal) {
				t.Errorf("Laplace mismatch: gopus=%d, libopus=%d (fs=%d, decay=%d)",
					gopusVal, int(libopusVal), tc.fs, tc.decay)
			} else {
				t.Logf("Laplace match: val=%d (fs=%d, decay=%d)", gopusVal, tc.fs, tc.decay)
			}
		})
	}
}

// TestRangeStateVsLibopus validates range coder initialization
func TestRangeStateVsLibopus(t *testing.T) {
	testData := []byte{0xCF, 0xC5, 0x88, 0x30, 0x00, 0x00, 0x00, 0x00}

	// Get libopus state
	var libRng, libVal C.uint
	cData := (*C.uchar)(unsafe.Pointer(&testData[0]))
	C.test_get_range_state(cData, C.int(len(testData)), &libRng, &libVal)

	// Get gopus state
	rd := &rangecoding.Decoder{}
	rd.Init(testData)
	goRng := rd.Range()
	goVal := rd.Val()

	t.Logf("Range state: libopus(rng=0x%08X, val=0x%08X), gopus(rng=0x%08X, val=0x%08X)",
		uint32(libRng), uint32(libVal), goRng, goVal)

	if goRng != uint32(libRng) {
		t.Errorf("Range mismatch: gopus=0x%08X, libopus=0x%08X", goRng, uint32(libRng))
	}
	if goVal != uint32(libVal) {
		t.Errorf("Val mismatch: gopus=0x%08X, libopus=0x%08X", goVal, uint32(libVal))
	}
}

// TestCoarseEnergyDecodeVsLibopus validates coarse energy decode
func TestCoarseEnergyDecodeVsLibopus(t *testing.T) {
	testCases := []struct {
		name     string
		data     []byte
		end      int
		intra    bool
		lm       int
		channels int
	}{
		{"mono_inter_lm3", make64Bytes(0xCF), 21, false, 3, 1},
		{"mono_intra_lm3", make64Bytes(0x12), 21, true, 3, 1},
		{"stereo_inter_lm3", make64Bytes(0xAB), 21, false, 3, 2},
		{"mono_inter_lm0", make64Bytes(0x55), 17, false, 0, 1},
		{"mono_intra_lm2", make64Bytes(0x99), 19, true, 2, 1},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Initialize previous energies to zero (matching libopus init)
			prevEnergy := make([]float32, tc.end*tc.channels)
			outEnergy := make([]float32, tc.end*tc.channels)
			outQi := make([]int32, tc.end*tc.channels)

			// Call libopus
			cData := (*C.uchar)(unsafe.Pointer(&tc.data[0]))
			cPrevEnergy := (*C.float)(unsafe.Pointer(&prevEnergy[0]))
			cOutEnergy := (*C.float)(unsafe.Pointer(&outEnergy[0]))
			cOutQi := (*C.int)(unsafe.Pointer(&outQi[0]))
			intraInt := 0
			if tc.intra {
				intraInt = 1
			}

			ret := C.test_unquant_coarse_energy(
				cData, C.int(len(tc.data)),
				0, C.int(tc.end), C.int(intraInt), C.int(tc.channels), C.int(tc.lm),
				cPrevEnergy, cOutEnergy, cOutQi,
			)
			if ret != 0 {
				t.Fatalf("libopus coarse energy decode failed")
			}

			// Call gopus
			d := NewDecoder(tc.channels)
			rd := &rangecoding.Decoder{}
			rd.Init(tc.data)
			d.SetRangeDecoder(rd)
			goEnergies := d.DecodeCoarseEnergy(tc.end, tc.intra, tc.lm)

			// Compare
			maxDiff := 0.0
			for band := 0; band < tc.end; band++ {
				for c := 0; c < tc.channels; c++ {
					libE := float64(outEnergy[band+c*tc.end])
					goE := goEnergies[c*tc.end+band]
					diff := math.Abs(libE - goE)
					if diff > maxDiff {
						maxDiff = diff
					}
					if diff > 1e-5 {
						t.Errorf("Band %d ch %d: libopus=%.6f, gopus=%.6f, diff=%.6e, qi=%d",
							band, c, libE, goE, diff, outQi[band+c*tc.end])
					}
				}
			}
			t.Logf("Max diff: %.6e", maxDiff)

			if maxDiff > 1e-5 {
				t.Errorf("Coarse energy max diff %.6e exceeds tolerance 1e-5", maxDiff)
			}
		})
	}
}

// TestFineEnergyFormulaVsLibopus validates the fine energy offset formula
func TestFineEnergyFormulaVsLibopus(t *testing.T) {
	// Test the formula: offset = (q2+.5f)*(1<<(14-extra))*(1.f/16384) - .5f
	// Then: offset *= (1<<(14-prev))*(1.f/16384)

	for extra := 1; extra <= 8; extra++ {
		for q2 := 0; q2 < (1 << extra); q2++ {
			for prev := 0; prev <= extra; prev++ {
				// libopus formula (float)
				libOffset := (float64(q2) + 0.5) * float64(uint(1)<<(14-extra)) * (1.0 / 16384.0) - 0.5
				if prev > 0 {
					libOffset *= float64(uint(1)<<(14-prev)) * (1.0 / 16384.0)
				}

				// gopus formula
				scale := float64(uint(1) << extra)
				goOffset := (float64(q2)+0.5)/scale - 0.5
				if prev > 0 {
					goOffset /= float64(uint(1) << prev)
				}

				diff := math.Abs(libOffset - goOffset)
				if diff > 1e-10 {
					t.Errorf("Fine offset mismatch: extra=%d, q2=%d, prev=%d: lib=%.10f, go=%.10f, diff=%.10e",
						extra, q2, prev, libOffset, goOffset, diff)
				}
			}
		}
	}
	t.Log("Fine energy formula validated")
}

// TestEnergyFinaliseFormulaVsLibopus validates the finalise offset formula
func TestEnergyFinaliseFormulaVsLibopus(t *testing.T) {
	// Test the formula: offset = (q2-.5f)*(1<<(14-fine_quant[i]-1))*(1.f/16384)

	for fineQuant := 0; fineQuant < 8; fineQuant++ {
		for q2 := 0; q2 <= 1; q2++ {
			// libopus formula (float)
			libOffset := (float64(q2) - 0.5) * float64(uint(1)<<(14-fineQuant-1)) * (1.0 / 16384.0)

			// gopus formula
			goOffset := (float64(q2) - 0.5) / float64(uint(1)<<(fineQuant+1))

			diff := math.Abs(libOffset - goOffset)
			if diff > 1e-10 {
				t.Errorf("Finalise offset mismatch: fineQuant=%d, q2=%d: lib=%.10f, go=%.10f, diff=%.10e",
					fineQuant, q2, libOffset, goOffset, diff)
			}
		}
	}
	t.Log("Energy finalise formula validated")
}

// TestAmplitudeComputationVsLibopus validates amplitude (gain) computation
func TestAmplitudeComputationVsLibopus(t *testing.T) {
	// The amplitude computation in CELT: g = 2^(logE/2) where logE is in log2 units (1.0 = 6dB)
	// In libopus float: bandE[i] = exp2f(bandLogE[i]) after adding eMeans

	// Test various log energy values
	logEnergies := []float64{-10.0, -5.0, 0.0, 5.0, 10.0, 15.0, 20.0}

	for _, logE := range logEnergies {
		// Add eMean for band 0
		totalLogE := logE + eMeans[0]

		// libopus amplitude: exp2(logE)
		libAmp := math.Pow(2.0, totalLogE)

		// gopus amplitude: same formula
		goAmp := math.Pow(2.0, totalLogE)

		diff := math.Abs(libAmp - goAmp)
		if diff > 1e-10 {
			t.Errorf("Amplitude mismatch: logE=%.1f: lib=%.10f, go=%.10f, diff=%.10e",
				logE, libAmp, goAmp, diff)
		}
	}
	t.Log("Amplitude computation validated")
}

// TestEMeansTableMatch validates eMeans table matches libopus
func TestEMeansTableMatch(t *testing.T) {
	// libopus eMeans (from quant_bands.c float build):
	libEMeans := []float64{
		6.437500, 6.250000, 5.750000, 5.312500, 5.062500,
		4.812500, 4.500000, 4.375000, 4.875000, 4.687500,
		4.562500, 4.437500, 4.875000, 4.625000, 4.312500,
		4.500000, 4.375000, 4.625000, 4.750000, 4.437500,
		3.750000, 3.750000, 3.750000, 3.750000, 3.750000,
	}

	for i, lib := range libEMeans {
		if i >= len(eMeans) {
			t.Errorf("eMeans too short: need index %d", i)
			continue
		}
		if eMeans[i] != lib {
			t.Errorf("eMeans[%d] mismatch: gopus=%.6f, libopus=%.6f", i, eMeans[i], lib)
		}
	}
	t.Log("eMeans table validated")
}

// TestPredictionCoefficientsMatch validates prediction coefficients
func TestPredictionCoefficientsMatch(t *testing.T) {
	// libopus pred_coef (float): 29440/32768., 26112/32768., 21248/32768., 16384/32768.
	libAlpha := []float64{29440.0 / 32768.0, 26112.0 / 32768.0, 21248.0 / 32768.0, 16384.0 / 32768.0}

	for lm, lib := range libAlpha {
		if AlphaCoef[lm] != lib {
			t.Errorf("AlphaCoef[%d] mismatch: gopus=%.10f, libopus=%.10f", lm, AlphaCoef[lm], lib)
		}
	}

	// libopus beta_coef (float): 30147/32768., 22282/32768., 12124/32768., 6554/32768.
	libBeta := []float64{30147.0 / 32768.0, 22282.0 / 32768.0, 12124.0 / 32768.0, 6554.0 / 32768.0}

	for lm, lib := range libBeta {
		if BetaCoefInter[lm] != lib {
			t.Errorf("BetaCoefInter[%d] mismatch: gopus=%.10f, libopus=%.10f", lm, BetaCoefInter[lm], lib)
		}
	}

	// libopus beta_intra (float): 4915/32768.
	libBetaIntra := 4915.0 / 32768.0
	if BetaIntra != libBetaIntra {
		t.Errorf("BetaIntra mismatch: gopus=%.10f, libopus=%.10f", BetaIntra, libBetaIntra)
	}

	t.Log("Prediction coefficients validated")
}

// TestProbabilityModelMatch validates e_prob_model table
func TestProbabilityModelMatch(t *testing.T) {
	// Verify our eProbModel matches libopus e_prob_model
	for lm := 0; lm < 4; lm++ {
		for intra := 0; intra < 2; intra++ {
			for i := 0; i < 42; i++ {
				if eProbModel[lm][intra][i] != uint8(C.e_prob_model_local[lm][intra][i]) {
					t.Errorf("eProbModel[%d][%d][%d] mismatch: gopus=%d, libopus=%d",
						lm, intra, i, eProbModel[lm][intra][i], C.e_prob_model_local[lm][intra][i])
				}
			}
		}
	}
	t.Log("Probability model table validated")
}

// Helper to create a 64-byte test buffer with repeating pattern
func make64Bytes(seed byte) []byte {
	data := make([]byte, 64)
	for i := range data {
		data[i] = byte((int(seed) + i*17) % 256)
	}
	return data
}
