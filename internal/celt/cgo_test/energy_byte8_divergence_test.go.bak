// Package cgo provides CGO tests for energy encoding divergence analysis.
package cgo

/*
#cgo CFLAGS: -I${SRCDIR}/../../../tmp_check/opus-1.6.1/include -I${SRCDIR}/../../../tmp_check/opus-1.6.1/celt -I${SRCDIR}/../../../tmp_check/opus-1.6.1 -I${SRCDIR}/../../../tmp_check/opus-1.6.1/silk -DHAVE_CONFIG_H -DVAR_ARRAYS
#cgo LDFLAGS: -L${SRCDIR}/../../../tmp_check/opus-1.6.1/.libs -lopus -lm

#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <stdio.h>
#include "opus.h"

// Enable range debug output
extern int opus_debug_range;

// Encode a frame and return the raw CELT payload
int encode_celt_frame(const float *pcm, int frame_size, int channels, int bitrate, unsigned char *output, int max_bytes) {
    int error;
    OpusEncoder *enc = opus_encoder_create(48000, channels, OPUS_APPLICATION_AUDIO, &error);
    if (error != OPUS_OK) return -1;

    opus_encoder_ctl(enc, OPUS_SET_BITRATE(bitrate));
    opus_encoder_ctl(enc, OPUS_SET_SIGNAL(OPUS_SIGNAL_MUSIC));
    opus_encoder_ctl(enc, OPUS_SET_COMPLEXITY(5));
    // Force CELT-only mode
    opus_encoder_ctl(enc, OPUS_SET_FORCE_MODE(2));  // MODE_CELT_ONLY

    // Enable range debug
    opus_debug_range = 1;

    int len = opus_encode_float(enc, pcm, frame_size, output, max_bytes);

    opus_debug_range = 0;
    opus_encoder_destroy(enc);
    return len;
}

// Encode with detailed tracing
int encode_celt_frame_detailed(const float *pcm, int frame_size, int channels, int bitrate,
                               unsigned char *output, int max_bytes,
                               unsigned int *final_range) {
    int error;
    OpusEncoder *enc = opus_encoder_create(48000, channels, OPUS_APPLICATION_AUDIO, &error);
    if (error != OPUS_OK) return -1;

    opus_encoder_ctl(enc, OPUS_SET_BITRATE(bitrate));
    opus_encoder_ctl(enc, OPUS_SET_SIGNAL(OPUS_SIGNAL_MUSIC));
    opus_encoder_ctl(enc, OPUS_SET_COMPLEXITY(5));
    opus_encoder_ctl(enc, OPUS_SET_FORCE_MODE(2));

    opus_debug_range = 1;
    int len = opus_encode_float(enc, pcm, frame_size, output, max_bytes);
    opus_debug_range = 0;

    // Get final range
    opus_uint32 range;
    opus_encoder_ctl(enc, OPUS_GET_FINAL_RANGE(&range));
    *final_range = range;

    opus_encoder_destroy(enc);
    return len;
}

// Decode a CELT packet and return energy debug info
int decode_celt_frame_with_debug(const unsigned char *packet, int len, int frame_size, int channels, float *output) {
    int error;
    OpusDecoder *dec = opus_decoder_create(48000, channels, &error);
    if (error != OPUS_OK) return -1;

    opus_debug_range = 1;
    int samples = opus_decode_float(dec, packet, len, output, frame_size, 0);
    opus_debug_range = 0;

    opus_decoder_destroy(dec);
    return samples;
}

// Compare two packets byte-by-byte and return first diff position
int find_first_diff(const unsigned char *a, const unsigned char *b, int len) {
    for (int i = 0; i < len; i++) {
        if (a[i] != b[i]) return i;
    }
    return -1;
}

*/
import "C"

import (
	"fmt"
	"math"
	"testing"
	"unsafe"

	"github.com/thesyncim/gopus/internal/celt"
)

// TestByte8DivergenceAnalysis analyzes the byte-by-byte divergence between gopus and libopus.
func TestByte8DivergenceAnalysis(t *testing.T) {
	frameSize := 960
	channels := 1
	bitrate := 64000

	// Generate test signal - 440 Hz sine
	pcm := make([]float32, frameSize)
	for i := 0; i < frameSize; i++ {
		pcm[i] = 0.5 * float32(math.Sin(2*math.Pi*440*float64(i)/48000))
	}

	// Encode with libopus
	libOutput := make([]byte, 1275)
	var finalRange C.uint
	libLen := C.encode_celt_frame_detailed(
		(*C.float)(unsafe.Pointer(&pcm[0])),
		C.int(frameSize),
		C.int(channels),
		C.int(bitrate),
		(*C.uchar)(unsafe.Pointer(&libOutput[0])),
		C.int(1275),
		&finalRange,
	)
	if libLen < 0 {
		t.Fatalf("libopus encode failed")
	}

	// Extract CELT payload (skip TOC byte)
	libPayload := libOutput[1:libLen]
	t.Logf("libopus CELT payload (%d bytes):", libLen-1)
	t.Logf("  Bytes 0-15: %02X", libPayload[:16])
	t.Logf("  Final range: 0x%08X", uint32(finalRange))

	// Encode with gopus
	pcm64 := make([]float64, frameSize)
	for i := range pcm {
		pcm64[i] = float64(pcm[i])
	}

	encoder := celt.NewEncoder(channels)
	encoder.Reset()
	encoder.SetBitrate(bitrate)

	gopusPayload, err := encoder.EncodeFrame(pcm64, frameSize)
	if err != nil {
		t.Fatalf("gopus encode failed: %v", err)
	}

	t.Logf("\ngopus CELT payload (%d bytes):", len(gopusPayload))
	t.Logf("  Bytes 0-15: %02X", gopusPayload[:min(16, len(gopusPayload))])
	t.Logf("  Final range: 0x%08X", encoder.FinalRange())

	// Find first divergence
	minLen := len(gopusPayload)
	if int(libLen)-1 < minLen {
		minLen = int(libLen) - 1
	}

	firstDiff := -1
	for i := 0; i < minLen; i++ {
		if libPayload[i] != gopusPayload[i] {
			firstDiff = i
			break
		}
	}

	if firstDiff >= 0 {
		t.Logf("\n=== DIVERGENCE at byte %d ===", firstDiff)
		t.Logf("  libopus: 0x%02X", libPayload[firstDiff])
		t.Logf("  gopus:   0x%02X", gopusPayload[firstDiff])

		// Show context
		start := firstDiff - 2
		if start < 0 {
			start = 0
		}
		end := firstDiff + 5
		if end > minLen {
			end = minLen
		}
		t.Logf("  Context libopus: %02X", libPayload[start:end])
		t.Logf("  Context gopus:   %02X", gopusPayload[start:end])
	} else {
		t.Log("\n=== PACKETS MATCH ===")
	}

	// Analyze packet structure
	t.Log("\n=== Packet Structure Analysis ===")
	t.Log("Byte 0-7: silence(1bit), postfilter(1bit), transient(3bit?), intra(3bit?), coarse energy")
	t.Log("Byte 8+: TF decisions, spread, fine energy, PVQ bands")

	// Decode both packets to verify
	t.Log("\n=== Decode Verification ===")

	// Decode gopus payload with libopus decoder
	toc := byte(0xF8) // CELT-only mono 20ms
	fullPacket := append([]byte{toc}, gopusPayload...)

	libDecoded := make([]float32, frameSize)
	C.opus_debug_range = 1
	decSamples := C.decode_celt_frame_with_debug(
		(*C.uchar)(unsafe.Pointer(&fullPacket[0])),
		C.int(len(fullPacket)),
		C.int(frameSize),
		C.int(channels),
		(*C.float)(unsafe.Pointer(&libDecoded[0])),
	)
	C.opus_debug_range = 0

	if decSamples < 0 {
		t.Logf("libopus decode of gopus packet failed: %d", decSamples)
	} else {
		// Compute SNR
		var signalPower, noisePower float64
		for i := 0; i < frameSize; i++ {
			signalPower += float64(pcm[i]) * float64(pcm[i])
			diff := float64(pcm[i]) - float64(libDecoded[i])
			noisePower += diff * diff
		}
		if noisePower > 0 {
			snr := 10 * math.Log10(signalPower/noisePower)
			t.Logf("Self-decode SNR (gopus->libopus): %.2f dB", snr)
		}

		// Compute correlation
		var sumXY, sumX2, sumY2 float64
		for i := 0; i < frameSize; i++ {
			x := float64(pcm[i])
			y := float64(libDecoded[i])
			sumXY += x * y
			sumX2 += x * x
			sumY2 += y * y
		}
		correlation := sumXY / math.Sqrt(sumX2*sumY2)
		t.Logf("Correlation: %.4f", correlation)

		// Energy ratio
		energyRatio := sumY2 / sumX2
		t.Logf("Energy ratio (decoded/input): %.4f", energyRatio)
	}
}

// TestCoarseEnergyComparison compares coarse energy encoding between gopus and libopus.
func TestCoarseEnergyComparison(t *testing.T) {
	frameSize := 960
	channels := 1

	// Generate test signal
	pcm := make([]float32, frameSize)
	for i := 0; i < frameSize; i++ {
		pcm[i] = 0.5 * float32(math.Sin(2*math.Pi*440*float64(i)/48000))
	}
	pcm64 := make([]float64, frameSize)
	for i := range pcm {
		pcm64[i] = float64(pcm[i])
	}

	// Get mode config
	mode := celt.GetModeConfig(frameSize)
	nbBands := mode.EffBands
	lm := mode.LM

	t.Logf("Frame size: %d, LM: %d, nbBands: %d", frameSize, lm, nbBands)

	// Compute gopus energies
	encoder := celt.NewEncoder(channels)
	encoder.Reset()

	preemph := encoder.ApplyPreemphasisWithScaling(pcm64)
	mdct := celt.ComputeMDCTWithHistory(preemph, make([]float64, 120), 1)
	energies := encoder.ComputeBandEnergies(mdct, nbBands, frameSize)

	t.Log("\n=== Band Energies (gopus, mean-relative) ===")
	for i := 0; i < nbBands && i < 10; i++ {
		t.Logf("  Band %2d: %.6f", i, energies[i])
	}

	// Compute libopus-style energies
	mdctF32 := make([]float32, len(mdct))
	for i := range mdct {
		mdctF32[i] = float32(mdct[i])
	}
	libEnergies := ComputeLibopusBandEnergies(mdctF32, nbBands, frameSize, lm)

	t.Log("\n=== Band Energies (libopus-style, mean-relative) ===")
	for i := 0; i < nbBands && i < 10; i++ {
		diff := float64(libEnergies[i]) - energies[i]
		t.Logf("  Band %2d: %.6f (diff: %+.6f)", i, libEnergies[i], diff)
	}

	// Also show raw energies for verification
	libRawEnergies := ComputeLibopusBandEnergiesRaw(mdctF32, nbBands, frameSize, lm)
	t.Log("\n=== Band Energies (libopus raw, absolute log2) ===")
	for i := 0; i < 5; i++ {
		emeans := GetLibopusEMeans(i)
		t.Logf("  Band %2d: raw=%.6f, eMeans=%.6f, diff=%.6f", i, libRawEnergies[i], emeans, float64(libRawEnergies[i])-float64(emeans))
	}
}

// TestTFDecisionComparison analyzes TF decisions that might cause byte 8 divergence.
func TestTFDecisionComparison(t *testing.T) {
	frameSize := 960
	channels := 1
	bitrate := 64000

	// Generate test signal
	pcm := make([]float32, frameSize)
	for i := 0; i < frameSize; i++ {
		pcm[i] = 0.5 * float32(math.Sin(2*math.Pi*440*float64(i)/48000))
	}

	// Encode with libopus to get the reference
	libOutput := make([]byte, 1275)
	var finalRange C.uint
	libLen := C.encode_celt_frame_detailed(
		(*C.float)(unsafe.Pointer(&pcm[0])),
		C.int(frameSize),
		C.int(channels),
		C.int(bitrate),
		(*C.uchar)(unsafe.Pointer(&libOutput[0])),
		C.int(1275),
		&finalRange,
	)
	if libLen < 0 {
		t.Fatalf("libopus encode failed")
	}

	libPayload := libOutput[1:libLen]

	t.Logf("libopus payload bytes 6-12: %02X", libPayload[6:13])

	// Analyze bit structure
	// At byte 7-8 boundary, we have the end of coarse energy and start of TF/spread/etc
	t.Log("\n=== Bit Analysis around byte 8 ===")
	if len(libPayload) > 8 {
		t.Logf("Byte 7: 0x%02X = %08b", libPayload[7], libPayload[7])
		t.Logf("Byte 8: 0x%02X = %08b", libPayload[8], libPayload[8])
	}
}

// TestFullEncoderPipelineComparison does a step-by-step comparison.
func TestFullEncoderPipelineComparison(t *testing.T) {
	frameSize := 960
	channels := 1
	bitrate := 64000

	// Generate test signal
	pcm := make([]float64, frameSize)
	for i := 0; i < frameSize; i++ {
		pcm[i] = 0.5 * math.Sin(2*math.Pi*440*float64(i)/48000)
	}

	encoder := celt.NewEncoder(channels)
	encoder.Reset()
	encoder.SetBitrate(bitrate)

	// Step through pipeline
	mode := celt.GetModeConfig(frameSize)
	nbBands := mode.EffBands
	lm := mode.LM

	t.Logf("=== Encoder Pipeline Analysis ===")
	t.Logf("Frame: %d samples, LM=%d, nbBands=%d", frameSize, lm, nbBands)

	// 1. Pre-emphasis
	dcRejected := encoder.ApplyDCReject(pcm)
	preemph := encoder.ApplyPreemphasisWithScaling(dcRejected)
	t.Logf("Pre-emphasis applied, first 5 values: [%.4f, %.4f, %.4f, %.4f, %.4f]",
		preemph[0], preemph[1], preemph[2], preemph[3], preemph[4])

	// 2. MDCT
	mdct := celt.ComputeMDCTWithHistory(preemph, make([]float64, 120), 1)
	t.Logf("MDCT computed, %d coefficients", len(mdct))
	t.Logf("First 5 MDCT: [%.4f, %.4f, %.4f, %.4f, %.4f]",
		mdct[0], mdct[1], mdct[2], mdct[3], mdct[4])

	// 3. Band energies
	energies := encoder.ComputeBandEnergies(mdct, nbBands, frameSize)
	t.Logf("Band energies (first 5): [%.4f, %.4f, %.4f, %.4f, %.4f]",
		energies[0], energies[1], energies[2], energies[3], energies[4])

	// 4. Full encoding
	encoded, err := encoder.EncodeFrame(pcm, frameSize)
	if err != nil {
		t.Fatalf("Encoding failed: %v", err)
	}

	t.Logf("\nEncoded: %d bytes", len(encoded))
	t.Logf("Bytes 0-15: %02X", encoded[:min(16, len(encoded))])

	// Compare with libopus
	pcmF32 := make([]float32, frameSize)
	for i := range pcm {
		pcmF32[i] = float32(pcm[i])
	}
	libOutput := make([]byte, 1275)
	var finalRange C.uint
	libLen := C.encode_celt_frame_detailed(
		(*C.float)(unsafe.Pointer(&pcmF32[0])),
		C.int(frameSize),
		C.int(channels),
		C.int(bitrate),
		(*C.uchar)(unsafe.Pointer(&libOutput[0])),
		C.int(1275),
		&finalRange,
	)
	libPayload := libOutput[1:libLen]

	t.Logf("\nlibopus bytes 0-15: %02X", libPayload[:min(16, len(libPayload))])

	// Show difference summary
	matches := 0
	for i := 0; i < min(len(encoded), len(libPayload)); i++ {
		if encoded[i] == libPayload[i] {
			matches++
		}
	}
	t.Logf("\nMatching bytes: %d/%d", matches, min(len(encoded), len(libPayload)))
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// TestEncodeFineEnergyComparison specifically tests fine energy encoding.
func TestEncodeFineEnergyComparison(t *testing.T) {
	t.Log("=== Fine Energy Encoding Analysis ===")

	// Fine energy encodes residual after coarse quantization
	// Each band gets a number of extra bits (0-8) for fractional precision

	// Key formula from quant_bands.c:
	// q2 = (int)floor((error[i]*(1<<prev)+.5f)*extra)
	// offset = (q2+.5f)*(1<<(14-extra_quant[i]))*(1.f/16384) - .5f
	// offset *= (1<<(14-prev))*(1.f/16384)

	// Test that our formula matches
	testCases := []struct {
		errorVal  float64
		extraBits int
		prev      int
	}{
		{0.3, 3, 0},
		{-0.2, 4, 0},
		{0.5, 2, 0},
	}

	for _, tc := range testCases {
		// gopus formula (from energy_encode.go)
		ft := 1 << tc.extraBits
		scale := float64(ft)
		q := int(math.Floor((tc.errorVal + 0.5) * scale))
		if q < 0 {
			q = 0
		}
		if q >= ft {
			q = ft - 1
		}
		offset := (float64(q)+0.5)/scale - 0.5

		// libopus formula
		extra := 1 << tc.extraBits
		q2 := int(math.Floor((tc.errorVal + 0.5) * float64(extra)))
		if q2 > extra-1 {
			q2 = extra - 1
		}
		if q2 < 0 {
			q2 = 0
		}
		offsetLib := (float64(q2)+0.5)*(float64(uint(1)<<(14-tc.extraBits)))*(1.0/16384) - 0.5

		t.Logf("error=%.2f, bits=%d: gopus q=%d offset=%.6f, libopus q2=%d offset=%.6f",
			tc.errorVal, tc.extraBits, q, offset, q2, offsetLib)
	}
}

// TestEncodeWithSameInputAsLibopus ensures we're encoding with identical inputs.
func TestEncodeWithSameInputAsLibopus(t *testing.T) {
	frameSize := 960
	channels := 1

	// Use a very simple test signal that's easy to verify
	pcm := make([]float64, frameSize)
	for i := 0; i < frameSize; i++ {
		// DC offset test
		pcm[i] = 0.1
	}

	encoder := celt.NewEncoder(channels)
	encoder.Reset()
	encoder.SetBitrate(64000)

	encoded, _ := encoder.EncodeFrame(pcm, frameSize)
	t.Logf("DC signal encoded: %02X...", encoded[:min(10, len(encoded))])

	// Now test with zero input
	for i := range pcm {
		pcm[i] = 0.0
	}
	encoder.Reset()
	encoded, _ = encoder.EncodeFrame(pcm, frameSize)
	t.Logf("Zero signal encoded: %02X...", encoded[:min(10, len(encoded))])

	// Test with impulse
	for i := range pcm {
		pcm[i] = 0.0
	}
	pcm[0] = 1.0
	encoder.Reset()
	encoded, _ = encoder.EncodeFrame(pcm, frameSize)
	t.Logf("Impulse signal encoded: %02X...", encoded[:min(10, len(encoded))])
}

func init() {
	// Ensure opus_debug_range is accessible
	fmt.Sprintf("%d", C.opus_debug_range)
}
