// Package cgo provides CGO comparison tests for the range encoder.
// This file tests detailed encoder state alignment between Go and libopus.
package cgo

/*
#cgo CFLAGS: -I${SRCDIR}/../../../tmp_check/opus-1.6.1/include -I${SRCDIR}/../../../tmp_check/opus-1.6.1/celt -I${SRCDIR}/../../../tmp_check/opus-1.6.1 -DHAVE_CONFIG_H
#cgo LDFLAGS: -L${SRCDIR}/../../../tmp_check/opus-1.6.1/.libs -lopus -lm

#include <stdlib.h>
#include <string.h>
#include "entenc.h"
#include "entcode.h"
#include "mfrngcod.h"

// EncoderState holds encoder state for comparison
typedef struct {
    opus_uint32 rng;
    opus_uint32 val;
    int rem;
    opus_uint32 ext;
    opus_uint32 offs;
    int nbits_total;
    int tell;
} EncoderStateSnapshot;

// Initialize encoder and return initial state
void trace_enc_init_state(unsigned char *buf, int size, EncoderStateSnapshot *out) {
    ec_enc enc;
    ec_enc_init(&enc, buf, size);
    out->rng = enc.rng;
    out->val = enc.val;
    out->rem = enc.rem;
    out->ext = enc.ext;
    out->offs = enc.offs;
    out->nbits_total = enc.nbits_total;
    out->tell = ec_tell(&enc);
}

// Encode a sequence of bits with logp and trace state after each
// states array should have count+1 elements (init + after each bit)
void trace_enc_bit_sequence(unsigned char *buf, int size, int *bits, int *logps, int count, EncoderStateSnapshot *states, unsigned char *out_bytes, int *out_len) {
    ec_enc enc;
    ec_enc_init(&enc, buf, size);

    // Record initial state
    states[0].rng = enc.rng;
    states[0].val = enc.val;
    states[0].rem = enc.rem;
    states[0].ext = enc.ext;
    states[0].offs = enc.offs;
    states[0].nbits_total = enc.nbits_total;
    states[0].tell = ec_tell(&enc);

    for (int i = 0; i < count; i++) {
        ec_enc_bit_logp(&enc, bits[i], logps[i]);
        states[i+1].rng = enc.rng;
        states[i+1].val = enc.val;
        states[i+1].rem = enc.rem;
        states[i+1].ext = enc.ext;
        states[i+1].offs = enc.offs;
        states[i+1].nbits_total = enc.nbits_total;
        states[i+1].tell = ec_tell(&enc);
    }

    ec_enc_done(&enc);
    *out_len = enc.offs + enc.end_offs;
    memcpy(out_bytes, buf, *out_len);
}

// Encode using ec_encode (fl, fh, ft) and trace
void trace_enc_encode_sequence(unsigned char *buf, int size,
                               unsigned int *fls, unsigned int *fhs, unsigned int *fts,
                               int count, EncoderStateSnapshot *states,
                               unsigned char *out_bytes, int *out_len) {
    ec_enc enc;
    ec_enc_init(&enc, buf, size);

    states[0].rng = enc.rng;
    states[0].val = enc.val;
    states[0].rem = enc.rem;
    states[0].ext = enc.ext;
    states[0].offs = enc.offs;
    states[0].nbits_total = enc.nbits_total;
    states[0].tell = ec_tell(&enc);

    for (int i = 0; i < count; i++) {
        ec_encode(&enc, fls[i], fhs[i], fts[i]);
        states[i+1].rng = enc.rng;
        states[i+1].val = enc.val;
        states[i+1].rem = enc.rem;
        states[i+1].ext = enc.ext;
        states[i+1].offs = enc.offs;
        states[i+1].nbits_total = enc.nbits_total;
        states[i+1].tell = ec_tell(&enc);
    }

    ec_enc_done(&enc);
    *out_len = enc.offs + enc.end_offs;
    memcpy(out_bytes, buf, *out_len);
}

// Encode ICDF sequence and trace
void trace_enc_icdf_sequence(unsigned char *buf, int size,
                             int *symbols, const unsigned char *icdf, int ftb,
                             int count, EncoderStateSnapshot *states,
                             unsigned char *out_bytes, int *out_len) {
    ec_enc enc;
    ec_enc_init(&enc, buf, size);

    states[0].rng = enc.rng;
    states[0].val = enc.val;
    states[0].rem = enc.rem;
    states[0].ext = enc.ext;
    states[0].offs = enc.offs;
    states[0].nbits_total = enc.nbits_total;
    states[0].tell = ec_tell(&enc);

    for (int i = 0; i < count; i++) {
        ec_enc_icdf(&enc, symbols[i], icdf, ftb);
        states[i+1].rng = enc.rng;
        states[i+1].val = enc.val;
        states[i+1].rem = enc.rem;
        states[i+1].ext = enc.ext;
        states[i+1].offs = enc.offs;
        states[i+1].nbits_total = enc.nbits_total;
        states[i+1].tell = ec_tell(&enc);
    }

    ec_enc_done(&enc);
    *out_len = enc.offs + enc.end_offs;
    memcpy(out_bytes, buf, *out_len);
}

*/
import "C"

import (
	"testing"
	"unsafe"

	"github.com/thesyncim/gopus/internal/rangecoding"
)

// EncoderStateSnapshot holds encoder state for comparison
type EncoderStateSnapshot struct {
	Rng        uint32
	Val        uint32
	Rem        int
	Ext        uint32
	Offs       uint32
	NbitsTotal int
	Tell       int
}

// statesMatch compares two encoder states
func statesMatch(go_, lib EncoderStateSnapshot) bool {
	return go_.Rng == lib.Rng &&
		go_.Val == lib.Val &&
		go_.Rem == lib.Rem &&
		go_.Ext == lib.Ext &&
		go_.Offs == lib.Offs &&
		go_.NbitsTotal == lib.NbitsTotal &&
		go_.Tell == lib.Tell
}

// captureGoState captures the current Go encoder state
func captureGoState(enc *rangecoding.Encoder) EncoderStateSnapshot {
	return EncoderStateSnapshot{
		Rng:        enc.Range(),
		Val:        enc.Val(),
		Rem:        enc.Rem(),
		Ext:        enc.Ext(),
		Offs:       uint32(enc.RangeBytes()),
		NbitsTotal: enc.Tell() + ilog(enc.Range()), // Approximate nbitsTotal
		Tell:       enc.Tell(),
	}
}

// ilog computes integer log base 2 (position of highest set bit + 1)
func ilog(x uint32) int {
	if x == 0 {
		return 0
	}
	n := 0
	if x >= (1 << 16) {
		n += 16
		x >>= 16
	}
	if x >= (1 << 8) {
		n += 8
		x >>= 8
	}
	if x >= (1 << 4) {
		n += 4
		x >>= 4
	}
	if x >= (1 << 2) {
		n += 2
		x >>= 2
	}
	if x >= (1 << 1) {
		n += 1
		x >>= 1
	}
	return n + int(x)
}

// TestEncoderInitStateMatches verifies initial state matches libopus
func TestEncoderInitStateMatches(t *testing.T) {
	bufSize := 256
	goBuf := make([]byte, bufSize)
	libBuf := make([]byte, bufSize)

	// Initialize Go encoder
	goEnc := &rangecoding.Encoder{}
	goEnc.Init(goBuf)

	// Get libopus initial state
	var libState C.EncoderStateSnapshot
	C.trace_enc_init_state((*C.uchar)(unsafe.Pointer(&libBuf[0])), C.int(bufSize), &libState)

	// Compare
	t.Logf("Go:     rng=%#x val=%#x rem=%d ext=%d offs=%d tell=%d",
		goEnc.Range(), goEnc.Val(), goEnc.Rem(), goEnc.Ext(), goEnc.RangeBytes(), goEnc.Tell())
	t.Logf("libopus: rng=%#x val=%#x rem=%d ext=%d offs=%d tell=%d",
		uint32(libState.rng), uint32(libState.val), int(libState.rem), uint32(libState.ext), uint32(libState.offs), int(libState.tell))

	if goEnc.Range() != uint32(libState.rng) {
		t.Errorf("rng mismatch: go=%#x lib=%#x", goEnc.Range(), uint32(libState.rng))
	}
	if goEnc.Val() != uint32(libState.val) {
		t.Errorf("val mismatch: go=%#x lib=%#x", goEnc.Val(), uint32(libState.val))
	}
	if goEnc.Rem() != int(libState.rem) {
		t.Errorf("rem mismatch: go=%d lib=%d", goEnc.Rem(), int(libState.rem))
	}
	if goEnc.Ext() != uint32(libState.ext) {
		t.Errorf("ext mismatch: go=%d lib=%d", goEnc.Ext(), uint32(libState.ext))
	}
	if goEnc.Tell() != int(libState.tell) {
		t.Errorf("tell mismatch: go=%d lib=%d", goEnc.Tell(), int(libState.tell))
	}
}

// TestEncodeBitStateTrace traces state after each bit and compares
func TestEncodeBitStateTrace(t *testing.T) {
	testCases := []struct {
		name  string
		bits  []int
		logps []int
	}{
		{"single_0_logp1", []int{0}, []int{1}},
		{"single_1_logp1", []int{1}, []int{1}},
		{"single_0_logp15", []int{0}, []int{15}},
		{"single_1_logp15", []int{1}, []int{15}},
		{"sequence_01_logp1", []int{0, 1}, []int{1, 1}},
		{"sequence_10_logp1", []int{1, 0}, []int{1, 1}},
		{"mixed_logp", []int{0, 1, 0, 1}, []int{1, 2, 4, 8}},
		{"all_zeros", []int{0, 0, 0, 0, 0, 0, 0, 0}, []int{1, 1, 1, 1, 1, 1, 1, 1}},
		{"all_ones", []int{1, 1, 1, 1, 1, 1, 1, 1}, []int{1, 1, 1, 1, 1, 1, 1, 1}},
		{"silence_flag", []int{0}, []int{15}}, // Silence flag uses logp=15
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			count := len(tc.bits)
			bufSize := 256

			// Go encoder
			goBuf := make([]byte, bufSize)
			goEnc := &rangecoding.Encoder{}
			goEnc.Init(goBuf)

			// Libopus arrays
			libBuf := make([]byte, bufSize)
			cBits := make([]C.int, count)
			cLogps := make([]C.int, count)
			for i := range tc.bits {
				cBits[i] = C.int(tc.bits[i])
				cLogps[i] = C.int(tc.logps[i])
			}
			libStates := make([]C.EncoderStateSnapshot, count+1)
			libOutBytes := make([]byte, bufSize)
			var libOutLen C.int

			// Trace libopus
			C.trace_enc_bit_sequence(
				(*C.uchar)(unsafe.Pointer(&libBuf[0])), C.int(bufSize),
				(*C.int)(unsafe.Pointer(&cBits[0])), (*C.int)(unsafe.Pointer(&cLogps[0])), C.int(count),
				(*C.EncoderStateSnapshot)(unsafe.Pointer(&libStates[0])),
				(*C.uchar)(unsafe.Pointer(&libOutBytes[0])), &libOutLen,
			)

			// Compare initial state
			goState := captureGoState(goEnc)
			libInitState := EncoderStateSnapshot{
				Rng:        uint32(libStates[0].rng),
				Val:        uint32(libStates[0].val),
				Rem:        int(libStates[0].rem),
				Ext:        uint32(libStates[0].ext),
				Offs:       uint32(libStates[0].offs),
				NbitsTotal: int(libStates[0].nbits_total),
				Tell:       int(libStates[0].tell),
			}
			t.Logf("Initial: Go rng=%#x val=%#x rem=%d ext=%d tell=%d", goState.Rng, goState.Val, goState.Rem, goState.Ext, goState.Tell)
			t.Logf("Initial: Lib rng=%#x val=%#x rem=%d ext=%d tell=%d", libInitState.Rng, libInitState.Val, libInitState.Rem, libInitState.Ext, libInitState.Tell)

			// Encode each bit and compare state after
			diverged := false
			for i := 0; i < count; i++ {
				goEnc.EncodeBit(tc.bits[i], uint(tc.logps[i]))

				goState = captureGoState(goEnc)
				libState := EncoderStateSnapshot{
					Rng:        uint32(libStates[i+1].rng),
					Val:        uint32(libStates[i+1].val),
					Rem:        int(libStates[i+1].rem),
					Ext:        uint32(libStates[i+1].ext),
					Offs:       uint32(libStates[i+1].offs),
					NbitsTotal: int(libStates[i+1].nbits_total),
					Tell:       int(libStates[i+1].tell),
				}

				if goState.Rng != libState.Rng || goState.Val != libState.Val ||
					goState.Rem != libState.Rem || goState.Ext != libState.Ext {
					t.Errorf("State mismatch after bit %d (val=%d logp=%d):", i, tc.bits[i], tc.logps[i])
					t.Errorf("  Go:  rng=%#x val=%#x rem=%d ext=%d offs=%d tell=%d",
						goState.Rng, goState.Val, goState.Rem, goState.Ext, goState.Offs, goState.Tell)
					t.Errorf("  Lib: rng=%#x val=%#x rem=%d ext=%d offs=%d tell=%d",
						libState.Rng, libState.Val, libState.Rem, libState.Ext, libState.Offs, libState.Tell)
					diverged = true
					break
				}
			}

			if diverged {
				return
			}

			// Compare final output bytes
			goBytes := goEnc.Done()
			libBytes := libOutBytes[:int(libOutLen)]

			if len(goBytes) != len(libBytes) {
				t.Errorf("Output length mismatch: go=%d lib=%d", len(goBytes), len(libBytes))
				t.Logf("Go bytes:  %x", goBytes)
				t.Logf("Lib bytes: %x", libBytes)
			} else {
				match := true
				for i := range goBytes {
					if goBytes[i] != libBytes[i] {
						match = false
						break
					}
				}
				if !match {
					t.Errorf("Output bytes mismatch:")
					t.Logf("Go bytes:  %x", goBytes)
					t.Logf("Lib bytes: %x", libBytes)
				} else {
					t.Logf("Output matches: %x", goBytes)
				}
			}
		})
	}
}

// TestEncodeSequenceMatchesLibopus tests that Encode() matches libopus ec_encode()
func TestEncodeSequenceMatchesLibopus(t *testing.T) {
	testCases := []struct {
		name string
		fls  []uint32
		fhs  []uint32
		fts  []uint32
	}{
		{"single_first", []uint32{0}, []uint32{64}, []uint32{256}},
		{"single_last", []uint32{192}, []uint32{256}, []uint32{256}},
		{"two_symbols", []uint32{0, 64}, []uint32{64, 128}, []uint32{256, 256}},
		{"narrow_range", []uint32{100}, []uint32{101}, []uint32{256}},
		{"laplace_like", []uint32{0}, []uint32{15000}, []uint32{32768}}, // Similar to Laplace center
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			count := len(tc.fls)
			bufSize := 256

			// Go encoder
			goBuf := make([]byte, bufSize)
			goEnc := &rangecoding.Encoder{}
			goEnc.Init(goBuf)

			// Libopus arrays
			libBuf := make([]byte, bufSize)
			cFls := make([]C.uint, count)
			cFhs := make([]C.uint, count)
			cFts := make([]C.uint, count)
			for i := range tc.fls {
				cFls[i] = C.uint(tc.fls[i])
				cFhs[i] = C.uint(tc.fhs[i])
				cFts[i] = C.uint(tc.fts[i])
			}
			libStates := make([]C.EncoderStateSnapshot, count+1)
			libOutBytes := make([]byte, bufSize)
			var libOutLen C.int

			// Trace libopus
			C.trace_enc_encode_sequence(
				(*C.uchar)(unsafe.Pointer(&libBuf[0])), C.int(bufSize),
				(*C.uint)(unsafe.Pointer(&cFls[0])), (*C.uint)(unsafe.Pointer(&cFhs[0])), (*C.uint)(unsafe.Pointer(&cFts[0])),
				C.int(count),
				(*C.EncoderStateSnapshot)(unsafe.Pointer(&libStates[0])),
				(*C.uchar)(unsafe.Pointer(&libOutBytes[0])), &libOutLen,
			)

			// Encode each symbol and compare
			for i := 0; i < count; i++ {
				goEnc.Encode(tc.fls[i], tc.fhs[i], tc.fts[i])

				goState := captureGoState(goEnc)
				libState := EncoderStateSnapshot{
					Rng:  uint32(libStates[i+1].rng),
					Val:  uint32(libStates[i+1].val),
					Rem:  int(libStates[i+1].rem),
					Ext:  uint32(libStates[i+1].ext),
					Offs: uint32(libStates[i+1].offs),
					Tell: int(libStates[i+1].tell),
				}

				if goState.Rng != libState.Rng || goState.Val != libState.Val {
					t.Errorf("State mismatch after symbol %d (fl=%d fh=%d ft=%d):", i, tc.fls[i], tc.fhs[i], tc.fts[i])
					t.Errorf("  Go:  rng=%#x val=%#x rem=%d ext=%d tell=%d",
						goState.Rng, goState.Val, goState.Rem, goState.Ext, goState.Tell)
					t.Errorf("  Lib: rng=%#x val=%#x rem=%d ext=%d tell=%d",
						libState.Rng, libState.Val, libState.Rem, libState.Ext, libState.Tell)
				}
			}

			// Compare final bytes
			goBytes := goEnc.Done()
			libBytes := libOutBytes[:int(libOutLen)]

			if len(goBytes) != len(libBytes) {
				t.Errorf("Output length mismatch: go=%d lib=%d", len(goBytes), len(libBytes))
			}
			match := true
			for i := range goBytes {
				if i >= len(libBytes) || goBytes[i] != libBytes[i] {
					match = false
					break
				}
			}
			if !match {
				t.Errorf("Output mismatch: go=%x lib=%x", goBytes, libBytes)
			} else {
				t.Logf("Match: %x", goBytes)
			}
		})
	}
}

// TestEncodeICDFMatchesLibopus tests that EncodeICDF matches libopus ec_enc_icdf
func TestEncodeICDFMatchesLibopus(t *testing.T) {
	// Uniform distribution ICDF: 4 symbols with equal probability
	uniformICDF := []byte{192, 128, 64, 0}

	testCases := []struct {
		name    string
		symbols []int
		icdf    []byte
		ftb     uint
	}{
		{"symbol_0", []int{0}, uniformICDF, 8},
		{"symbol_1", []int{1}, uniformICDF, 8},
		{"symbol_2", []int{2}, uniformICDF, 8},
		{"symbol_3", []int{3}, uniformICDF, 8},
		{"sequence", []int{0, 1, 2, 3, 0, 1, 2, 3}, uniformICDF, 8},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			count := len(tc.symbols)
			bufSize := 256

			// Go encoder
			goBuf := make([]byte, bufSize)
			goEnc := &rangecoding.Encoder{}
			goEnc.Init(goBuf)

			// Libopus arrays
			libBuf := make([]byte, bufSize)
			cSymbols := make([]C.int, count)
			for i := range tc.symbols {
				cSymbols[i] = C.int(tc.symbols[i])
			}
			libStates := make([]C.EncoderStateSnapshot, count+1)
			libOutBytes := make([]byte, bufSize)
			var libOutLen C.int

			// Trace libopus
			C.trace_enc_icdf_sequence(
				(*C.uchar)(unsafe.Pointer(&libBuf[0])), C.int(bufSize),
				(*C.int)(unsafe.Pointer(&cSymbols[0])),
				(*C.uchar)(unsafe.Pointer(&tc.icdf[0])), C.int(tc.ftb),
				C.int(count),
				(*C.EncoderStateSnapshot)(unsafe.Pointer(&libStates[0])),
				(*C.uchar)(unsafe.Pointer(&libOutBytes[0])), &libOutLen,
			)

			// Encode each symbol and compare
			for i := 0; i < count; i++ {
				goEnc.EncodeICDF(tc.symbols[i], tc.icdf, tc.ftb)

				goState := captureGoState(goEnc)
				libState := EncoderStateSnapshot{
					Rng:  uint32(libStates[i+1].rng),
					Val:  uint32(libStates[i+1].val),
					Rem:  int(libStates[i+1].rem),
					Ext:  uint32(libStates[i+1].ext),
					Offs: uint32(libStates[i+1].offs),
					Tell: int(libStates[i+1].tell),
				}

				if goState.Rng != libState.Rng || goState.Val != libState.Val {
					t.Errorf("State mismatch after symbol %d (s=%d):", i, tc.symbols[i])
					t.Errorf("  Go:  rng=%#x val=%#x rem=%d ext=%d tell=%d",
						goState.Rng, goState.Val, goState.Rem, goState.Ext, goState.Tell)
					t.Errorf("  Lib: rng=%#x val=%#x rem=%d ext=%d tell=%d",
						libState.Rng, libState.Val, libState.Rem, libState.Ext, libState.Tell)
				}
			}

			// Compare final bytes
			goBytes := goEnc.Done()
			libBytes := libOutBytes[:int(libOutLen)]

			match := len(goBytes) == len(libBytes)
			if match {
				for i := range goBytes {
					if goBytes[i] != libBytes[i] {
						match = false
						break
					}
				}
			}
			if !match {
				t.Errorf("Output mismatch: go=%x lib=%x", goBytes, libBytes)
			} else {
				t.Logf("Match: %x", goBytes)
			}
		})
	}
}
