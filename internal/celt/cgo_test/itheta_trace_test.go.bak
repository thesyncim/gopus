// Package cgo traces itheta decoding to find the source of M/S split error
package cgo

import (
	"encoding/binary"
	"math"
	"os"
	"testing"

	"github.com/thesyncim/gopus"
	"github.com/thesyncim/gopus/internal/celt"
	"github.com/thesyncim/gopus/internal/rangecoding"
)

// TestTraceThetaDecode traces the theta/imid/iside values during decoding
func TestTraceThetaDecode(t *testing.T) {
	bitFile := "../../../internal/testvectors/testdata/opus_testvectors/testvector08.bit"
	data, err := os.ReadFile(bitFile)
	if err != nil {
		t.Skipf("Cannot read %s: %v", bitFile, err)
		return
	}

	var packets [][]byte
	offset := 0
	for offset < len(data)-8 {
		pktLen := binary.BigEndian.Uint32(data[offset:])
		offset += 4
		offset += 4
		if int(pktLen) <= 0 || offset+int(pktLen) > len(data) {
			break
		}
		packets = append(packets, data[offset:offset+int(pktLen)])
		offset += int(pktLen)
	}

	// Decode packet 14 with both decoders
	pkt := packets[14]
	t.Logf("Packet 14: len=%d, TOC=0x%02X", len(pkt), pkt[0])

	// The packet 14 has TOC=0x8C which is:
	// config = 0x8C >> 3 = 17 (CELT-only, 20ms)
	// stereo = (0x8C >> 2) & 1 = 1
	// frame_count = 0x8C & 3 = 0 (one frame)

	// For CELT stereo packets, we need to trace the band quantization

	// First, let's just decode and compare outputs
	goDec, _ := gopus.NewDecoder(48000, 2)
	goSamplesF32, _ := goDec.DecodeFloat32(pkt)

	libDec, _ := NewLibopusDecoder(48000, 2)
	libPcm, libSamples := libDec.DecodeFloat(pkt, 5760)
	libDec.Destroy()

	t.Logf("Go samples: %d stereo pairs, Lib samples: %d", len(goSamplesF32)/2, libSamples)

	// Compute M/S energy distribution
	var libMEnergy, libSEnergy float64
	var goMEnergy, goSEnergy float64

	for i := 0; i < libSamples && i*2+1 < len(goSamplesF32); i++ {
		libL := float64(libPcm[i*2])
		libR := float64(libPcm[i*2+1])
		goL := float64(goSamplesF32[i*2])
		goR := float64(goSamplesF32[i*2+1])

		libM := (libL + libR) / 2
		libS := (libL - libR) / 2
		goM := (goL + goR) / 2
		goS := (goL - goR) / 2

		libMEnergy += libM * libM
		libSEnergy += libS * libS
		goMEnergy += goM * goM
		goSEnergy += goS * goS
	}

	t.Logf("Lib M energy: %.6f, S energy: %.6f, ratio: %.4f",
		libMEnergy, libSEnergy, libMEnergy/(libSEnergy+1e-10))
	t.Logf("Go  M energy: %.6f, S energy: %.6f, ratio: %.4f",
		goMEnergy, goSEnergy, goMEnergy/(goSEnergy+1e-10))

	// The M/S energy ratio tells us if the theta angle is decoded correctly
	libTheta := math.Atan2(math.Sqrt(libSEnergy), math.Sqrt(libMEnergy)) * 180 / math.Pi
	goTheta := math.Atan2(math.Sqrt(goSEnergy), math.Sqrt(goMEnergy)) * 180 / math.Pi
	t.Logf("Lib effective theta: %.2f°, Go effective theta: %.2f°", libTheta, goTheta)
}

// TestManualPacket14Decode manually decodes packet 14's CELT data
func TestManualPacket14Decode(t *testing.T) {
	bitFile := "../../../internal/testvectors/testdata/opus_testvectors/testvector08.bit"
	data, err := os.ReadFile(bitFile)
	if err != nil {
		t.Skipf("Cannot read %s: %v", bitFile, err)
		return
	}

	var packets [][]byte
	offset := 0
	for offset < len(data)-8 {
		pktLen := binary.BigEndian.Uint32(data[offset:])
		offset += 4
		offset += 4
		if int(pktLen) <= 0 || offset+int(pktLen) > len(data) {
			break
		}
		packets = append(packets, data[offset:offset+int(pktLen)])
		offset += int(pktLen)
	}

	pkt := packets[14]
	t.Logf("Packet 14: %d bytes", len(pkt))

	// Parse TOC
	toc := pkt[0]
	config := int(toc >> 3)
	stereo := (toc >> 2) & 1

	t.Logf("Config: %d, Stereo: %d", config, stereo)

	// For CELT, data starts at byte 1
	celtData := pkt[1:]

	// Initialize range decoder
	rd := rangecoding.NewDecoder(celtData)

	// Read CELT header flags (uncompressed bits)
	// For 20ms frame at 48kHz: LM=3 (960 samples per frame)
	lm := 3 // log2(shortBlocks) for 20ms

	// Decode silence flag
	silence := rd.DecodeBit(15)
	t.Logf("Silence flag: %d", silence)

	if silence == 0 {
		// Decode post filter
		postfilter := rd.DecodeBit(1)
		t.Logf("Postfilter flag: %d", postfilter)
	}

	// Continue with band energy decoding...
	// This would need the full CELT decoder to trace properly
}

// TestCompareRangeCoderState compares range coder state between gopus and libopus
func TestCompareRangeCoderState(t *testing.T) {
	// For a more detailed analysis, we'd need to trace the range coder state
	// at each step of decoding. The key insight from the error pattern is:
	//
	// M_error = -S_error (exactly opposite)
	//
	// This means the total energy M^2 + S^2 is approximately conserved,
	// but the split between M and S is wrong.
	//
	// The theta angle controls this split via:
	//   imid = cos(theta * pi / 16384) * 32767
	//   iside = cos((16384 - theta) * pi / 16384) * 32767 = sin(theta * pi / 16384) * 32767
	//
	// If theta is wrong, both M and S gains would be wrong in a specific way.

	// Since M/S error ratio is exactly -1.0, let's compute what would cause this:
	// If true mid = m, true side = s
	// And gopus computes mid' = m + δ, side' = s - δ
	// Then M_error/S_error = δ/(-δ) = -1.0
	//
	// This suggests something is adding to M and subtracting from S by the same amount.
	// The stereoMerge function does: L = mid*M - S, R = mid*M + S
	// If there's an xp (cross-product) error, it would affect lgain and rgain asymmetrically.

	t.Log("The M/S error ratio of -1.0 suggests:")
	t.Log("1. The M/S energy split (theta/imid/iside) might be slightly wrong")
	t.Log("2. Or the stereoMerge lgain/rgain calculation has an error")
	t.Log("3. Or the xp (cross-product) used in stereoMerge is computed incorrectly")
}

// TestCheckStereoMergeFormula verifies the stereoMerge formula against reference
func TestCheckStereoMergeFormula(t *testing.T) {
	// Test with known values
	// For a simple case where M and S are orthogonal unit vectors:
	n := 4
	x := []float64{1.0, 0.0, 0.0, 0.0} // "mid" direction
	y := []float64{0.0, 1.0, 0.0, 0.0} // "side" direction
	mid := 0.7071 // cos(45°) - equal energy split

	// Compute expected lgain/rgain
	xp := 0.0
	side := 0.0
	for i := 0; i < n; i++ {
		xp += y[i] * x[i]
		side += y[i] * y[i]
	}
	xp *= mid
	mid2 := mid * mid
	el := mid2 + side - 2.0*xp
	er := mid2 + side + 2.0*xp

	t.Logf("Input: mid=%.4f, xp=%.4f, side=%.4f", mid, xp, side)
	t.Logf("Energy: el=%.4f, er=%.4f", el, er)

	lgain := 1.0 / math.Sqrt(el)
	rgain := 1.0 / math.Sqrt(er)
	t.Logf("Gains: lgain=%.4f, rgain=%.4f", lgain, rgain)

	// Simulate stereoMerge inline
	xCopy := make([]float64, n)
	yCopy := make([]float64, n)
	for i := 0; i < n; i++ {
		l := mid * x[i]
		r := y[i]
		xCopy[i] = (l - r) * lgain
		yCopy[i] = (l + r) * rgain
	}

	t.Logf("After stereoMerge: x=%v, y=%v", xCopy, yCopy)

	// Verify that x and y now represent L and R with correct energies
	lEnergy := 0.0
	rEnergy := 0.0
	for i := 0; i < n; i++ {
		lEnergy += xCopy[i] * xCopy[i]
		rEnergy += yCopy[i] * yCopy[i]
	}
	t.Logf("Output energies: L=%.4f, R=%.4f (should both be ~1.0)", lEnergy, rEnergy)
}
