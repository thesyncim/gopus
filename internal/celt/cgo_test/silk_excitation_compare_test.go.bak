// Package cgo provides CGO wrappers for libopus comparison tests.
package cgo

/*
#cgo CFLAGS: -I${SRCDIR}/../../../tmp_check/opus-1.6.1/include -I${SRCDIR}/../../../tmp_check/opus-1.6.1/celt -I${SRCDIR}/../../../tmp_check/opus-1.6.1 -DHAVE_CONFIG_H
#cgo LDFLAGS: -L${SRCDIR}/../../../tmp_check/opus-1.6.1/.libs -lopus -lm

#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <stdio.h>
#include "silk/main.h"
#include "silk/macros.h"
#include "silk/Inlines.h"

// Test function to compute x_sc_Q10 from int16 input and gain
// This mirrors silk_nsq_scale_states() input scaling
void test_silk_excitation_scale_input(
    const opus_int16 *x16,      // Input samples (Q0)
    opus_int32 gain_Q16,        // Gain in Q16
    opus_int32 *x_sc_Q10,       // Output: scaled input in Q10
    int length)
{
    opus_int32 inv_gain_Q31 = silk_INVERSE32_varQ(silk_max(gain_Q16, 1), 47);
    opus_int32 inv_gain_Q26 = silk_RSHIFT_ROUND(inv_gain_Q31, 5);

    for (int i = 0; i < length; i++) {
        x_sc_Q10[i] = silk_SMULWW(x16[i], inv_gain_Q26);
    }
}

// Get the inverse gain Q31 value (for debugging)
opus_int32 test_silk_excitation_get_inv_gain_Q31(opus_int32 gain_Q16) {
    return silk_INVERSE32_varQ(silk_max(gain_Q16, 1), 47);
}

// Get the inverse gain Q26 value
opus_int32 test_silk_excitation_get_inv_gain_Q26(opus_int32 gain_Q16) {
    opus_int32 inv_gain_Q31 = silk_INVERSE32_varQ(silk_max(gain_Q16, 1), 47);
    return silk_RSHIFT_ROUND(inv_gain_Q31, 5);
}

// silk_SMULWW implementation for verification: (a32 * b32) >> 16
opus_int32 test_silk_excitation_smulww(opus_int32 a32, opus_int32 b32) {
    return silk_SMULWW(a32, b32);
}
*/
import "C"

import (
	"math"
	"testing"
)

// TestSILKExcitationScaling verifies that gopus excitation scaling matches libopus
func TestSILKExcitationScaling(t *testing.T) {
	// Test with typical gain value
	// SILK uses gains in Q16 format, typical values ~6000-65535
	// gainQ16 = 65536 means gain = 1.0

	testCases := []struct {
		name    string
		gainQ16 int32
	}{
		{"gain_1.0", 65536},
		{"gain_0.5", 32768},
		{"gain_2.0", 131072},
		{"gain_typical_low", 6000},
		{"gain_typical_high", 60000},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create test signal: -32768 to 32767 int16 range
			// Simulating 80 samples at 8kHz (10ms subframe at NB)
			const numSamples = 80

			// Generate a simple sine wave in int16 range
			x16 := make([]int16, numSamples)
			for i := range x16 {
				// 300 Hz sine at 8kHz sample rate, amplitude 10000
				x16[i] = int16(10000 * math.Sin(2*math.Pi*300*float64(i)/8000))
			}

			// Get libopus scaled values
			cX16 := make([]C.opus_int16, numSamples)
			cScaled := make([]C.opus_int32, numSamples)
			for i, v := range x16 {
				cX16[i] = C.opus_int16(v)
			}

			C.test_silk_excitation_scale_input(
				&cX16[0],
				C.opus_int32(tc.gainQ16),
				&cScaled[0],
				C.int(numSamples),
			)

			// Log some values for debugging
			invGainQ31 := C.test_silk_excitation_get_inv_gain_Q31(C.opus_int32(tc.gainQ16))
			invGainQ26 := C.test_silk_excitation_get_inv_gain_Q26(C.opus_int32(tc.gainQ16))
			t.Logf("gainQ16=%d, invGainQ31=%d, invGainQ26=%d",
				tc.gainQ16, invGainQ31, invGainQ26)

			// Show a few scaled samples
			t.Logf("Sample scaling examples:")
			for i := 0; i < 5 && i < numSamples; i++ {
				t.Logf("  x16[%d]=%d -> x_sc_Q10[%d]=%d", i, x16[i], i, cScaled[i])
			}

			// Verify the scaling is non-trivial
			var maxScaled int32
			for i := 0; i < numSamples; i++ {
				v := int32(cScaled[i])
				if v < 0 {
					v = -v
				}
				if v > maxScaled {
					maxScaled = v
				}
			}
			t.Logf("Max |x_sc_Q10| = %d", maxScaled)

			// The scaled values should be significantly larger than 0-1 range
			// For gain=1.0, x_sc_Q10 = x16 * (1<<10) = x16 * 1024
			// So for input amplitude 10000, expect max around 10000*1024 = 10240000
			if maxScaled < 1000 {
				t.Errorf("Scaled values too small: max=%d, expected significant magnitude", maxScaled)
			}
		})
	}
}

// TestSILKExcitationFloat32ToInt16 tests converting normalized float32 to int16
func TestSILKExcitationFloat32ToInt16(t *testing.T) {
	// This test demonstrates the scaling needed in gopus

	const numSamples = 80

	// Generate normalized float32 signal [-1, 1]
	pcmFloat := make([]float32, numSamples)
	for i := range pcmFloat {
		pcmFloat[i] = float32(0.3 * math.Sin(2*math.Pi*300*float64(i)/8000))
	}

	// Convert to int16 (Q0) - this is what libopus expects
	pcmInt16 := make([]int16, numSamples)
	for i, v := range pcmFloat {
		// Scale by 32768 to convert to Q0 int16 range
		scaled := v * 32768.0
		if scaled > 32767 {
			scaled = 32767
		} else if scaled < -32768 {
			scaled = -32768
		}
		pcmInt16[i] = int16(scaled)
	}

	// Now scale with libopus
	gainQ16 := int32(65536) // gain = 1.0

	cX16 := make([]C.opus_int16, numSamples)
	cScaled := make([]C.opus_int32, numSamples)
	for i, v := range pcmInt16 {
		cX16[i] = C.opus_int16(v)
	}

	C.test_silk_excitation_scale_input(
		&cX16[0],
		C.opus_int32(gainQ16),
		&cScaled[0],
		C.int(numSamples),
	)

	t.Logf("Float32 to Int16 to x_sc_Q10 scaling:")
	for i := 0; i < 5; i++ {
		t.Logf("  pcmFloat[%d]=%.6f -> pcmInt16[%d]=%d -> x_sc_Q10[%d]=%d",
			i, pcmFloat[i], i, pcmInt16[i], i, cScaled[i])
	}

	// The key insight:
	// - libopus expects Q0 int16 input
	// - gopus has normalized float32 [-1, 1]
	// - Before computing LPC residual, multiply by 32768
	// - The residual (excitation) will then have proper magnitude

	// Verify residual would be properly scaled
	// For a simple case, residual = input (no prediction)
	// If input was just normalized and we round: round(0.3) = 0 (wrong!)
	// If input is scaled by 32768 first: round(0.3 * 32768) = round(9830) = 9830 (correct!)

	t.Logf("\nKey insight for excitation fix:")
	t.Logf("  Without scaling: round(%.6f) = %d", pcmFloat[0], int32(math.Round(float64(pcmFloat[0]))))
	t.Logf("  With 32768 scaling: round(%.6f * 32768) = %d",
		pcmFloat[0], int32(math.Round(float64(pcmFloat[0])*32768)))
}

// TestSILKResidualScalingComparison compares gopus-style vs libopus-style residual
func TestSILKResidualScalingComparison(t *testing.T) {
	// Simulate LPC residual computation

	const numSamples = 80

	// Generate signal
	pcmFloat := make([]float32, numSamples)
	for i := range pcmFloat {
		pcmFloat[i] = float32(0.3 * math.Sin(2*math.Pi*300*float64(i)/8000))
	}

	// Simple LPC residual: for demonstration, assume prediction = 0.8 * prev
	// residual[i] = input[i] - 0.8 * input[i-1]

	// Method 1: gopus current (WRONG) - compute residual on normalized float, then round
	residualWrong := make([]int32, numSamples)
	for i := 0; i < numSamples; i++ {
		var pred float32
		if i > 0 {
			pred = 0.8 * pcmFloat[i-1]
		}
		res := pcmFloat[i] - pred
		residualWrong[i] = int32(math.Round(float64(res)))
	}

	// Method 2: gopus fixed - scale by 32768 BEFORE computing residual
	residualCorrect := make([]int32, numSamples)
	pcmScaled := make([]float32, numSamples)
	for i := range pcmFloat {
		pcmScaled[i] = pcmFloat[i] * 32768.0
	}
	for i := 0; i < numSamples; i++ {
		var pred float32
		if i > 0 {
			pred = 0.8 * pcmScaled[i-1]
		}
		res := pcmScaled[i] - pred
		residualCorrect[i] = int32(math.Round(float64(res)))
	}

	t.Logf("Residual comparison (first 10 samples):")
	t.Logf("%-8s %-12s %-15s %-15s", "Index", "Input", "Wrong", "Correct")
	for i := 0; i < 10; i++ {
		t.Logf("%-8d %-12.6f %-15d %-15d",
			i, pcmFloat[i], residualWrong[i], residualCorrect[i])
	}

	// Count non-zero residuals
	var wrongNonZero, correctNonZero int
	for i := 0; i < numSamples; i++ {
		if residualWrong[i] != 0 {
			wrongNonZero++
		}
		if residualCorrect[i] != 0 {
			correctNonZero++
		}
	}

	t.Logf("\nNon-zero residuals: wrong=%d, correct=%d (of %d samples)",
		wrongNonZero, correctNonZero, numSamples)

	// The wrong method should have mostly zeros
	if wrongNonZero > numSamples/2 {
		t.Errorf("Expected mostly zeros with wrong method, got %d non-zero", wrongNonZero)
	}

	// The correct method should have mostly non-zeros
	if correctNonZero < numSamples/2 {
		t.Errorf("Expected mostly non-zeros with correct method, got %d non-zero", correctNonZero)
	}
}
